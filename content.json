[{"title":"Learn Kubernetes in Under 3 Hours","date":"2018-11-11T15:50:49.000Z","path":"2018/11/11/learn-kubernetes-in-under-3-hours/","text":"本文主要是讲解在Kubernates集群上运行基于微服务的应用程序。 原文内容来自Learn Kubernetes in Under 3 Hours: A Detailed Guide to Orchestrating Containers 零、准备工作0.1 项目介绍这个项目只有一个功能：在Web浏览器上输入一个句子，然后会计算句子所表达的情绪。 从技术的角度看，这个应用程序包含3个微服务，每个都包含特定的功能： SA-Frontend：前端，Nginx网络服务器，提供ReactJS静态文件； SA-WebApp：网络应用，Java网络应用程序，处理来自前端的请求； SA-Logic：逻辑处理，Python应用程序，执行情感分析。 我们可以通过微服务之间的数据流来描述这种交互： 客户端应用程序请求初始页面index.html（index.html页面会加载ReactJS应用程序的脚本） 用户与应用程序的交互请求到基于Spring的WebApp WebApp转发情绪分析到Python应用。 Python应用计算情绪值后返回。 WebApp返回响应到ReactApp，然后ReactApp向用户展示信息。 现在就克隆这个代码库：https://github.com/heqingbao/k8s-mastery，接下来我们要做更精彩的东西。 一、在计算机上运行基于微服务的应用程序我们需要启动所需的3个服务，这里从前端应用程序开始。 1.1 部署 sa-frontend 项目1.1.1 设置React的本地部署为了运行React应用程序，需要先在计算机上安装NodeJS和NPM，安装好这些后，在终端中进入目录sa-frontend，然后运行如下命令： 1npm install 该命令会将 React 应用程序的所有 Javascript 依赖都下载到文件夹 node_modules 中（package.json 文件中定义了所有依赖）。在所有依赖都解决后，运行如下命令： 1npm start 这样就可以了！我们运行了 React 应用程序，现在可以通过默认端口 localhost:3000 访问该应用程序了。你可以自由修改代码，并从浏览器中观察即时效果。 1.1.2 准备好 React 应用的产品环境为了搭建产品环境，我们需要建立应用程序的静态网页，并通过网络服务器提供服务。 首先在终端中进入目录sa-frontend，然后运行如下命令：1npm run build 该命令会在项目的文件目录中生成一个名叫“build”的文件夹。该文件夹内包含了 ReactJS 应用程序所需的所有静态文件。 1.1.3 利用Nginx提供静态文件首先安装并启动 Nginx 网络服务器。然后将 sa-frontend/build 目录内的文件移动到 [nginx安装目录]/html。 如此一来，我们就可以通过 [nginx安装目录]/html/index.html 来访问 index.html 文件了，而它是 Nginx 服务的默认文件。 默认情况下，Nginx 网络服务器会监听端口 80。你可以通过修改 [nginx安装目录]/conf/nginx.conf 文件中的 server.listen 字段来指定不同的端口。 打开浏览器，并访问端口 80，可以看到 ReactJS 应用程序加载成功。 在输入框Type your sentence中输入句子，然后点击SEND，发现没什么反应。因为它会向http://localhost:8080/sentiment发送请求，接下来我们就部署这个服务。 1.2 部署 sa-webapp 项目1.2.1 建议Spring网络应用程序为了编译sa-webapp项目，必须安装JDK8和Maven，并设置它们的环境变量。设置好后继续操作。 1.2.2 将应用程序打包成jar文件在终端中进入sa-webapp目录，并运行如下命令：1mvn install 该命令会在目录 sa-webapp 中生成一个名叫 target 的文件夹。target 文件夹内有打包好的 Java 应用程序包：’sentiment-analysis-web-0.0.1-SNAPSHOT.jar’。 1.2.3 启动应用程序进入target目录，并通过如下命令启动应用程序：1java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar 启动失败，可以看到如下异常信息： 1org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sentimentController': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'sa.logic.api.url' in value \"$&#123;sa.logic.api.url&#125;\" 这里显示的重要信息是sentimentController中的${sa.logic.api.url}无法注入。下面是源码： 12345678910111213@CrossOrigin(origins = \"*\")@RestControllerpublic class SentimentController &#123;@Value(\"$&#123;sa.logic.api.url&#125;\")private String saLogicApiUrl;@PostMapping(\"/sentiment\")public SentimentDto sentimentAnalysis(@RequestBody SentenceDto sentenceDto) &#123; RestTemplate restTemplate = new RestTemplate(); return restTemplate.postForEntity( saLogicApiUrl + \"/analyse/sentiment\", sentenceDto, SentimentDto.class).getBody(); &#125;&#125; 在 Spring 中默认的属性资源是 application.properties（具体位置在 sa-webapp/src/main/resources 中）。但是这不是定义属性的唯一方式，我们可以通过之前的命令完成属性定义： 1java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=WHAT.IS.THE.SA.LOGIC.API.URL 这里应该由Python应用程序运行时定义的值初始化该属性，如此一来String网络应用程序就可以知道在运行时把信息传递到哪里了。 为了简单起见，我们假设在localhost:5000上运行Python应用程序。 运行如下命令，然后我们再部署最后一个服务：Python应用程序。 1java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=http://localhost:5000 1.3 部署 sa-logic 项目为了启动 Python 应用程序，首先我们需要安装 Python3 和 pip，以及设置它们的环境变量。(如果本机只有python2，建议使用virtualenv配置python多环境) 1.3.1 安装依赖在终端中进入 sa-logic/sa目录，然后运行如下命令： 12python -m pip install -r requirements.txtpython -m textblob.download_corpora 注意：如果是新安装的python3，并且通过virtualenv创建的pytho&gt; n3环境，在执行python -m textblob.download_corpora的时候可能会报以下错误：123456789101112131415161718192021(venv) ➜ sa git:(master) ✗ python -m textblob.download_corpora[nltk_data] Error loading brown: &lt;urlopen error [SSL:[nltk_data] CERTIFICATE_VERIFY_FAILED] certificate verify failed:[nltk_data] unable to get local issuer certificate (_ssl.c:1051)&gt;[nltk_data] Error loading punkt: &lt;urlopen error [SSL:[nltk_data] CERTIFICATE_VERIFY_FAILED] certificate verify failed:[nltk_data] unable to get local issuer certificate (_ssl.c:1051)&gt;[nltk_data] Error loading wordnet: &lt;urlopen error [SSL:[nltk_data] CERTIFICATE_VERIFY_FAILED] certificate verify failed:[nltk_data] unable to get local issuer certificate (_ssl.c:1051)&gt;[nltk_data] Error loading averaged_perceptron_tagger: &lt;urlopen error[nltk_data] [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify[nltk_data] failed: unable to get local issuer certificate[nltk_data] (_ssl.c:1051)&gt;[nltk_data] Error loading conll2000: &lt;urlopen error [SSL:[nltk_data] CERTIFICATE_VERIFY_FAILED] certificate verify failed:[nltk_data] unable to get local issuer certificate (_ssl.c:1051)&gt;[nltk_data] Error loading movie_reviews: &lt;urlopen error [SSL:[nltk_data] CERTIFICATE_VERIFY_FAILED] certificate verify failed:[nltk_data] unable to get local issuer certificate (_ssl.c:1051)&gt;Finished. 解决方式是执行一下这个文件：/Applications/Python\\ 3.7/Install\\ Certificates.command，此文件通过Finder-&gt;应用程序里面能够找到，双击就行。 1.3.2 启动应用在利用 Pip 安装好依赖后，我们就可以通过运行如下命令启动应用程序了： 12python sentiment_analysis.py* Running on http://0.0.0.0:5000/ (Press CTRL+C to quit) 这意味着应用程序已经启动，并在 localhost 的端口 5000 上监听 HTTP 请求了。 到此，如果一切顺利，那么在浏览器上访问：http://localhost:3000/，然后在输入框中输入句子，应该就能够显示情绪值了。 后面将介绍如何在Docker容器内启动这些服务，因为这是在Kubernetes集群内运行这些服务的前提条件。 二、为每个服务创建容器镜像Kubernetes 是容器管理平台。可想而知我们需要容器去管理它们。但是容器是什么？Docker 官方文档的最佳答案如下： 容器映像是轻量级的、独立的、可执行软件包，包含所有可运行的东西：代码、运行时、系统工具、系统库、设置。对于基于 Linux 和 Windows 的应用，不论环境如何，容器化的软件都可以照常运行。 这意味着容器可以在任何计算机上运行，甚至是在产品服务器上，都没有任何差别。 为了更形象地描述，让我们来对比一下 React 应用程序在虚拟机上和容器内运行的情况。 通过虚拟机提供 React 静态文件 使用虚拟机的缺点包括： 资源效率低下，每个虚拟机都需要一个完全成熟的操作系统； 对平台有依赖性。本地机器上运行得很好的功能未必能在产品服务器上正常工作； 与容器相比，更重而且规模伸缩较慢。 通过容器提供 React 静态文件 使用容器的优点包括： 资源效率很高，在 Docker 的帮助下使用主机操作系统； 对平台没有依赖性。可以在本地机器上运行的容器可以在任何机器上正常工作； 通过映像层提供轻量级服务。 2.1 为React应用建立容器镜像2.1.1 Docker简介Docker 容器最基本的组件是.dockerfile。该 Dockerfile 文件最基本的组成是容器镜像，我们将通过下列一系列说明，介绍如何创建一个符合应用程序需求的容器镜像。 在开始定义 Dockerfile 之前，让我们先回想一下使用 Nginx 服务 React 静态文件的步骤： 创建静态文件（npm run build）； 启动 Nginx 服务器； 将前端项目的 build 文件夹的内容复制到 nginx/html 目录中。 在下一节中，你会注意到创建容器与建立本地 React 的过程非常相似。 2.1.2 为前端定义Dockerfile前端 Dockerfile 的建立只有两个步骤。这是因为 Nginx 团队为我们提供了基本的 Nginx 映像，我们可以直接利用。这两个步骤如下： 启动基本的 Nginx 映像； 将 sa-frontend/build 目录复制到容器的 nginx/html 中。 转换成的Dockerfile如下所示： 12FROM nginxCOPY build /usr/share/nginx/html 这个文件是可读的，我们可以概括为： 从 Nginx 映像开始（不管里面是什么）。将 build 目录复制到映像的 nginx/html 目录中。然后就好了！ 你可能在想，我应该将 build 文件复制到哪儿呢？例如：/usr/share/nginx/html。非常简单：在 Docker Hub 的 Nginx 映像文档中有记载。 2.1.3 建立并推送容器在推送映像之前，我们需要一个容器注册来托管映像。Docker Hub 是一个免费的云容器服务，我们将使用它来做演示。接下来有 3 个任务需要完成： 安装 Docker CE； 注册 Docker Hub； 在终端中运行如下命令登录： 1docker login -u=\"$DOCKER_USERNAME\" -p=\"$DOCKER_PASSWORD\" 或者执行： 1docker login 然后使用交互模式填写用户名和密码。 在完成上述任何后，请进入目录 sa-frontend。然后运行如下命令（请用你的 docker hub 用户名替换 $DOCKER 用户名，例如：heqingbao/sentiment-analysis-frontend）。 123456789101112131415[root@VM_0_3_centos sa]# docker build -f Dockerfile -t heqingbao/sentiment-analysis-frontend .Sending build context to Docker daemon 1.768 MBStep 1/2 : FROM nginxTrying to pull repository docker.io/library/nginx ... sha256:d59a1aa7866258751a261bae525a1842c7ff0662d4f34a355d5f36826abc0341: Pulling from docker.io/library/nginxf17d81b4b692: Pull complete 82dca86e04c3: Pull complete 046ccb106982: Pull complete Digest: sha256:d59a1aa7866258751a261bae525a1842c7ff0662d4f34a355d5f36826abc0341Status: Downloaded newer image for docker.io/nginx:latest ---&gt; 62f816a209e6Step 2/2 : COPY build /usr/share/nginx/html ---&gt; 8284804168aaRemoving intermediate container f74eb32d3c46Successfully built 8284804168aa 注意：如果是部署在远端服务器上，一定要把App.js里面的http://localhost:8080/sentiment的localhost换成远端主机的IP或容器的IP。 现在我们可以删掉 -f Dockerfile 了，因为我们已经在包含 Dockerfile 的目录中了。 我们可以使用 docker push 命令来推送映像： 1234567[root@VM_0_3_centos sa]# docker push heqingbao/sentiment-analysis-frontendThe push refers to a repository [docker.io/heqingbao/sentiment-analysis-frontend]a5a0d2defc6a: Pushed ad9ac0e6043b: Mounted from library/nginx 6ccbee34dd10: Mounted from library/nginx 237472299760: Mounted from library/nginx latest: digest: sha256:eb5adb74d0685e267771d5bcdc536015a8cb58fe88c1860d10f13d2994d3c063 size: 1158 请确认映像已成功地被推送到 docker hub 代码库。 2.1.4 运行容器现在任何人都可以获取 heqingbao/sentiment-analysis-frontend 中的映像并运行： 12docker pull heqingbao/sentiment-analysis-frontenddocker run -d -p 80:80 heqingbao/sentiment-analysis-frontend Docker 容器已经处于运行状态了！ 访问：http://yourid:80，试试看，你现在应该可以访问React应用程序了。 2.1.5 Dockerignore文件刚才我们看到建立 SA-Frontend 的映像非常慢，不好意思，应该是超级慢。这是因为我们必须将建立过程中的环境文件发送给 Docker 服务。更具体地来说，建立过程中的环境文件指的是在建立映像的时候，所有会用到的 Dockerfile 目录中的数据。 以我们的例子来说，SA-Frontend 文件包括如下文件夹：123456789sa-frontend:| .dockerignore| Dockerfile| package.json| README.md+---build+---node_modules+---public\\---src 但是我们只需要 build 文件夹。上传其他的文件会浪费时间。我们可以通过删除其他目录来节约时间。这就需要用到 .dockerignore。你可能觉得这与 .gitignore 很相似，例如你可以所有想要忽略的目录都添加到 .dockerignore，如下所示： 123node_modulessrcpublic 这个 .dockerignore 文件应该与 Dockerfile 在同一文件夹中。现在建立映像文件只需要几秒钟了。 这里使用了自定义容器镜像的方式，但是如果我们的镜像只使用一次（例如写一些测试Demo），大可不必创建自己的镜像然后再传到仓库，我们可以直接使用官方的Nginx镜像即可。 2.1.6 直接使用官方Nginx镜像部署React应用下载nginx镜像：1docker pull docker.io/nginx 启动nginx容器：123docker run -d -p 80:80 --name mynginx \\--volume \"$PWD/html\":/usr/share/nginx/html \\docker.io/nginx 上面命令的各个参数含义如下： -d: 在后台运行 -p: 容器的80端口映射到宿主机的80端口 –name: 容器的名字为mynginx –volume: 把当前目录下的html目录映射到容器的/usr/share/nginx/html目录 然后把前面sa-frontend项目编译后的build目录里的所有文件拷贝到当前路径下的html目录里。 访问：http://yourid:80，试试看，你现在应该也可以访问React应用程序。 2.2 为Java应用建立容器镜像在 sa-webapp 中打开 Dockerfile：123456FROM openjdk:8-jdk-alpine# Environment Variable that defines the endpoint of sentiment-analysis python api.ENV SA_LOGIC_API_URL http://localhost:5000ADD target/sentiment-analysis-web-0.0.1-SNAPSHOT.jar /EXPOSE 8080CMD [\"java\", \"-jar\", \"sentiment-analysis-web-0.0.1-SNAPSHOT.jar\", \"--sa.logic.api.url=$&#123;SA_LOGIC_API_URL&#125;\"] 关键字 ENV 在 Docker 容器内声明了环境变量。这可以让我们在启动容器的时候为情感分析 API 提供 URL。 另外，关键字 EXPOSE 提供了一个端口，供我们以后访问。但是等等，我们在 SA-Frontend 的时候没有做这一步，说得很对！这个端口仅用于文档，换句话说就是这个端口是用来向阅读 Dockerfile 的人提供信息的。 你应该已经掌握了创建和推送容器映像。 创建镜像：1234567891011121314151617181920212223242526[root@VM_0_3_centos sa-webapp]# docker build -f Dockerfile -t heqingbao/sentiment-analysis-web-app .Sending build context to Docker daemon 20.49 MBStep 1/5 : FROM openjdk:8-jdk-alpineTrying to pull repository docker.io/library/openjdk ... sha256:b18e45570b6f59bf80c15c78d7f0daff1e18e9c19069c323613297057095fda6: Pulling from docker.io/library/openjdk4fe2ade4980c: Pull complete 6fc58a8d4ae4: Pull complete ef87ded15917: Pull complete Digest: sha256:b18e45570b6f59bf80c15c78d7f0daff1e18e9c19069c323613297057095fda6Status: Downloaded newer image for docker.io/openjdk:8-jdk-alpine ---&gt; 97bc1352afdeStep 2/5 : ENV SA_LOGIC_API_URL http://localhost:5000 ---&gt; Running in c3be1ec16ac4 ---&gt; ab213d1b2ce1Removing intermediate container c3be1ec16ac4Step 3/5 : ADD target/sentiment-analysis-web-0.0.1-SNAPSHOT.jar / ---&gt; 5d1ebdbf659dRemoving intermediate container 7e5b7519d9e3Step 4/5 : EXPOSE 8080 ---&gt; Running in e428a3388798 ---&gt; 0893bf90a104Removing intermediate container e428a3388798Step 5/5 : CMD java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=$&#123;SA_LOGIC_API_URL&#125; ---&gt; Running in 065ac2e61dbd ---&gt; cba14182f49fRemoving intermediate container 065ac2e61dbd 启动容器：12[root@VM_0_3_centos sa-webapp]# docker run -d -p 8080:8080 -e SA_LOGIC_API_URL='http://x.x.x.x:5050' heqingbao/sentiment-analysis-web-appb3ab99abecd7a97f091e2362b4eee870037e562347f3996a9a1a2669ca60c651 上传到仓库：1234567[root@VM_0_3_centos sa-webapp]# docker push heqingbao/sentiment-analysis-web-appThe push refers to a repository [docker.io/heqingbao/sentiment-analysis-web-app]4e1c5d0784bf: Pushed ed6f0bd39121: Mounted from library/openjdk 0c3170905795: Mounted from library/openjdk df64d3292fd6: Mounted from library/openjdk latest: digest: sha256:be20fe12c184b6c4d2032141afe9b8cc092a9a083f1cf0a7dc8f73c4b1ebbaf8 size: 1159 2.3 为Python应用建立容器镜像sa-logic 的 Dockerfile：12345678FROM python:3.6.6-alpineCOPY sa /appWORKDIR /appRUN pip3 install -r requirements.txt &amp;&amp; \\ python3 -m textblob.download_corporaEXPOSE 5000ENTRYPOINT [\"python3\"]CMD [\"sentiment_analysis.py\"] 现在你已经是 Docker 达人了。 构建容器镜像：1docker build -f Dockerfile -t heqingbao/sentiment-analysis-logic . 运行Docker容器：1docker run -d -p 5050:5000 heqingbao/sentiment-analysis-logic 2.4 测试容器化应用程序1.运行sa-logic容器，并配置监听端口5050: docker run -d -p 5050:5000 heqingbao/sentiment-analysis-logic 2.运行 sa-webapp 容器，并配置监听端口 8080（因为我们改变了 Python 应用监听的端口，所以我们需要重写环境变量 SA_LOGIC_API_URL）： $ docker run -d -p 8080:8080 -e SA_LOGIC_API_URL=&apos;http://x.x.x.x:5050&apos; heqingbao/sentiment-analysis-web-app 3.运行 sa-frontend 容器： docker run -d -p 80:80 heqingbao/sentiment-analysis-frontend 然后就可以了。在浏览器中打开 x.x.x.x:80。 三、Kubernetes3.1 为什么要使用Kubernetes？本节中，我们学习了 Dockerfile，如何使用它创建映像，以及推送映像到 Docker注册目录的命令。另外，我们探讨了如何通过忽略没用的文件，减少需要发送的建立过程中的环境文件。最后我们从容器上运行了应用程序。 接下来，我们介绍为什么要使用 Kubernetes？我们将在下面深入介绍 Kubernetes，这里我想给你留个智力问答题。 如果我们的情感分析网络应用完成得很好，突然间访问量暴涨到每分钟数百万的请求，那么我们的 sa-webapp 和 sa-logic 将面临巨大的负荷压力。请问，我们如何才能扩大容器的规模？ 3.2 Kubernetes简介我向你保证我没有夸大其词，读完本文你会问“为什么我们不称它为 Supernetes？” 3.2.1 Kubernetes 是什么？从容器启动微服务后，我们有一个问题，让我们通过如下问答的形式具体描述这个问题： 问：我们怎么扩大或缩小容器？ 答：我们启动另外一个容器。 问：我们如何在容器间分摊负荷？如果当前服务器的负荷达到最大，那我们是否需要另外一个服务器？我们如何最大化硬件使用率？ 答：唔……呃……（让我搜一下） 问：如果在打更新补丁的时候，不影响到所有的服务？如果服务出了问题，如何才能返回之前能正常工作的版本？ Kubernetes 可以解决以上所有问题（以及更多问题！）。我可以用一句话总结 Kubernetes：“Kubernetes 是容器控制平台，可以抽象所有的底层基础设施（容器运行用到的基础设施）。” 我们对容器控制平台有个模糊的概念。在本文后续部分，我们将看看它的实际应用，但是这是第一次我们提到“底层基础设施的抽象”，所以我们来详细看看这个概念。 3.2.2 底层基础设施的抽象Kubernetes 通过一个简单的 API 提供底层基础设施的抽象，我们可以向该 API 发送请求。这些请求可以让 Kubernetes 尽最大能力应对。例如，可以简单地要求“Kubernetes 添加映像 x 的 4 个容器。”然后 Kubernetes 会找出使用中的节点，并在内添加新的容器。 这对开发人员来说意味着什么？意味着开发人员不需要在意节点的数目，也不需要在意从哪里运行容器以及如何与它们交流。开发人员不需要管理硬件优化，或担心节点关闭（它们将遵循墨菲法则），因为新的节点会添加到 Kubernetes 集群。同时 Kubernetes 会在其他运行的节点中添加容器。Kubernetes 会发挥最大的作用。 在上图中我们看到了一些新东西： API服务器：与集群交互的唯一方式。负责启动或停止另外一个容器，或检查当前状态，日志等； Kubelet：监视节点内的容器，并与主节点交流； Pod：初始阶段我们可以把 pod 当成容器。 就介绍这么多，跟深入的介绍会导致我们分心，我们可以等到后面一点再介绍，有一些有用的资源，比如官方文档，或者阅读 Marko Lukša 的著作《Kubernetes in Action》。 3.2.3 标准化的云服务提供商Kubernetes 另外一个深入人心的点是：它标准化了云服务提供商。这是一个很大胆的宣言，我们通过如下例子来具体看一看： 比如，有一个 Azure、Google 云平台或其他云服务提供商的专家，他担任了一个搭建在全新的云服务提供商的项目。这可能引起很多后果，比如说：他可能无法在截止期限内完成；公司可能需要招聘更多相关的人员，等等。 相对的，Kubernetes 就没有这个问题。因为不论是哪家云服务提供商，你都可以在上面运行相同的命令。你可以以既定的方式向 API 服务器发送请求。Kubernetes 会负责抽象，并实装这家云服务商。 停一秒钟仔细想一下，这是极其强有力的功能。对公司来说，这意味着他们不需要绑定到一家云服务商。他们可以计算别家云服务商的开销，然后转移到别家。他们依旧可以保留原来的专家，保留原来的人员，他们还可以花更少的钱。 说了这么多，在下一节中让我们来实际使用 Kubernetes。 四、Kubernetes实践 – Pod我们建立了微服务在容器上运行，虽然颇为坎坷，但还是可以工作的。我们还提到这种解决方案不具有伸缩性和弹性，而 Kubernetes 可以解决这些问题。在本文的后续章节，我们会将各个服务转移到由 Kubernetes 管理的容器中，如图所示。 在本文中，我们将使用 Minikube 进行本地调试，尽管所有东西都是运行在 Azure 和 Google 云平台中的。（我这里是部署在腾讯云上的） 4.1 安装和启动Minikube请参阅安装 Minikube 的官方文档： https://kubernetes.io/docs/tasks/tools/install-minikube/ https://k8smeetup.github.io/docs/tasks/ 在Mac上安装minikube:1curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.18.0/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ 在Mac上安装kubectl，Kubectl 是向 Kubernetes API 服务器发送请求的客户端： 1curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.12.2/bin/darwin/amd64/kubectl &amp;&amp; chmod +x kubectl &amp;&amp; sudo mv kubectl /usr/local/bin/ 或者：1curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl &amp;&amp; chmod +x kubectl &amp;&amp; sudo mv kubectl /usr/local/bin/ 通常情况下，上面命令下载都会很慢，甚至根本就无法下载。有两个办法： 如果有shadowsocks代理，可以在终端配置。 直接通过其它方式下载（比如浏览器），然后再改权限，再放到path环境下。 启动minikube: 1minikube start 第一次启动的时候会自动下载Minikube ISO，根据网络情况时间会比较久。 注意：有可能会安装失败，比如出现下面的错误： 12345678910111213141516171819202122&gt; ➜ Desktop minikube start &gt; There is a newer version of minikube available (v0.30.0). Download it here:&gt; https://github.com/kubernetes/minikube/releases/tag/v0.30.0&gt; &gt; To disable this notification, run the following:&gt; minikube config set WantUpdateNotification false&gt; Starting local Kubernetes cluster...&gt; Starting VM...&gt; Downloading Minikube ISO&gt; 89.51 MB / 89.51 MB [==============================================] 100.00% 0s&gt; E1111 20:06:02.564775 4725 start.go:116] Error starting host: Error creating host: Error with pre-create check: \"VBoxManage not found. Make sure VirtualBox is installed and VBoxManage is in the path\".&gt; &gt; Retrying.&gt; E1111 20:06:02.567379 4725 start.go:122] Error starting host: Error creating host: Error with pre-create check: \"VBoxManage not found. Make sure VirtualBox is installed and VBoxManage is in the path\"&gt; ================================================================================&gt; An error has occurred. Would you like to opt in to sending anonymized crash&gt; information to minikube to help prevent future errors?&gt; To opt out of these messages, run the command:&gt; minikube config set WantReportErrorPrompt false&gt; ================================================================================&gt; Please enter your response [Y/n]:&gt; 意思是说没有找到VboxManager命令，需要先安装VirtualBox。安装完VirtualBox后，再执行minikube start时不会重新下载Minikube ISO。 在启动后，运行 kubectl get nodes 命令可以得到如下结果： 123➜ Desktop kubectl get nodesNAME STATUS ROLES AGE VERSIONminikube NotReady &lt;none&gt; 8m v1.6.0 注意：我这里在安装1.12.2版本后，执行kubectl get nodes报错： 123&gt; ➜ Desktop kubectl get nodes&gt; Error from server (NotAcceptable): unknown (get nodes)&gt; 后面重新安装了1.8.7版本就没有这个问题。 Minikube 提供给我们的 Kubernetes 集群只有一个节点，但是记住我们并不在乎有多少个节点，Kubernetes 会负责抽象，对我们来说深入掌握 Kubernetes 并不重要。 下面我们将介绍 Kubernetes 的第一个资源：Pod。 4.2 Pod我大爱容器，相信现在你也很喜欢容器。那为什么 Kubernetes 给我们最小的可部署计算单元 Pod 呢？Pod是干什么的？由一个或一组容器组成的 Pod 可以共享相同的运行环境。 但是我们真的需要在一个 Pod 内运行两个容器吗？呃……一般来说，只会运行一个容器，我们的例子中也是这样的。但是有些情况下，比如两个容器需要共享卷，或它们之间是通过跨进程的交流方式交流的，又或者它们被绑到一起，那么就可以使用 Pod。Pod 的另一个特征是：如果我们希望使用其他 Rke 等技术的话，我们可以做到不依赖 Docker 容器。 总的来说，Pod 的主要属性包括（如上图所示）： 每个 Pod 可以在 Kubernetes 集群内拥有唯一的 IP 地址； Pod 可以拥有多个容器。这些容器共享同一个端口空间，所以他们可以通过 localhost 交流（可想而知它们无法使用相同的端口），与其他 Pod 内容器的交流可以通过结合 Pod 的 IP 完成； 一个 Pod 内的容器共享同一个卷、同一个 IP、端口空间、IPC 命名空间。 注：容器有个自己独立的文件系统，尽管他们可以通过 Kubernetes 的资源卷共享数据。 更多详细内容，请参阅相关的官方文档： https://kubernetes.io/docs/concepts/workloads/pods/pod/ 4.2.1 Pod的定义如下是我们的第一个 pod sa-frontend 的清单文件，我们会对文件内容进行逐一解释。 12345678910apiVersion: v1kind: Pod # 1metadata: name: sa-frontend # 2spec: # 3 containers: - image: rinormaloku/sentiment-analysis-frontend # 4 name: sa-frontend # 5 ports: - containerPort: 80 # 6 #1 kind：指定我们想创建的 Kubernetes 资源的类型。这里是 Pod。 #2 name：定义该资源的名字。我们在这里命名为 sa-frontend。 #3 spec：该对象定义了资源应有的状态。Pod Spec 中最重要的属性是容器的数组。 #4 image：是指我们希望在本 Pod 中启动的容器的映像。 #5 name：Pod 中容器中唯一的名字。 #6 containerPort：是指容器监听的端口号。这只是为了提供文档信息（即便没有这个端口也不会影响访问）。 创建 SA Frontend 的 Pod 你可以在 resource-manifests/sa-frontend-pod.yaml 中找到上述 Pod 的定义。你可以在终端中进入该文件夹，或在命令行输入完整的路径。然后执行如下命令：12kubectl create -f sa-frontend-pod.yamlpod \"sa-frontend\" created 可以通过如下命令确认 Pod：123kubectl get podsNAME READY STATUS RESTARTS AGEsa-frontend 1/1 Running 0 7s 如果该 Pod 还处于容器生成中的状态的话，你可以在运行命令的时候加入参数 –watch，当 Pod 进入运行状态的时候，终端会显示信息。 从外部访问应用程序 为了从外部访问应用程序，我们需要创建服务类型的Kubernetes资源，具体内容我们将在后续章节讲解，虽然通过服务类型的资源支持外部访问是更合适的做法，但是此处为了快速调试，我们还有另外一个办法，即转发端口： 12kubectl port-forward sa-frontend-pod 88:80Forwarding from 127.0.0.1:88 -&gt; 80 在浏览器中访问 127.0.0.1:88，即可打开 React 应用程序。 扩大规模的错误方法 我们说过 Kubernetes 的主要特色之一就是伸缩性，为了证明这一点，让我们运行另外一个 Pod。我们通过如下定义创建另外一个 Pod 资源： 12345678910apiVersion: v1kind: Pod metadata: name: sa-frontend2 # The only changespec: containers: - image: rinormaloku/sentiment-analysis-frontend name: sa-frontend ports: - containerPort: 80 然后，通过如下命令创建新的 Pod：12kubectl create -f sa-frontend-pod2.yamlpod \"sa-frontend2\" created 可以通过如下命令确认第二个 Pod：1234kubectl get podsNAME READY STATUS RESTARTS AGEsa-frontend 1/1 Running 0 7ssa-frontend2 1/1 Running 0 7s 现在我们有两个运行中的 Pod。 请注意：这不是最终的解决方案，还有很多缺陷。我们将在另一个 Kubernetes 资源的部署一节中改善这个方案。 总结 Pod 提供静态文件的 Nginx 网络服务器在另个不同的 Pod 内运行。现在我们有两个问题： 怎样对外开放这些服务，让用户通过 URL 来访问它们？ 怎样平衡 Pod 之间的负荷？ Kubernetes 提供了服务类型的资源。在下一节中我们将详细介绍。 五、Kubernetes 实践——服务Kubernetes 服务资源可以作为一组提供相同服务的 Pod 的入口。这个资源肩负发现服务和平衡 Pod 之间负荷的重任，如图 16 所示。 在 Kubernetes 集群内，我们拥有提供不同服务的 Pod（前端、Spring 网络应用和 Flask Python 应用程序）。所以这里的问题是：服务如何知道该处理哪个 Pod？例如：它如何生成这些 Pod 的终端列表？ 这个问题可以用标签来解决，具体分两个步骤： 给所有服务处理的对象 Pod 贴上标签； 在服务中使用一个选择器，该选择器定义了所有贴有标签的对象 Pod。 下列视图看起来更清晰： 我们可以看到 Pod 都贴着标签“app: sa-frontend”，服务用这个标签找到目标 Pod。 标签 标签提供了一种简单的方法用于管理Kubernetes资源。它们有一对键值表示，且可以用于所有资源。按照图17中的例子，修改清单文件。 在修改完毕后保存文件，并通过如下命令应用这些变更： 123456kubectl apply -f sa-frontend-pod.yamlWarning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl applypod \"sa-frontend\" configuredkubectl apply -f sa-frontend-pod2.yaml Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl applypod \"sa-frontend2\" configured 我们看到了一个警告（在应用的时候，而非创建，明白了）。在第二行我们看到部署了 pod “sa-frontend”和 “sa-frontend2”。我们可以过滤想要查看的 Pod： 1234kubectl get pod -l app=sa-frontendNAME READY STATUS RESTARTS AGEsa-frontend 1/1 Running 0 2hsa-frontend2 1/1 Running 0 2h 验证带有标签的 Pod 的另一种方法是在上述命令中加入标志符 –show-labels，那么结果中会显示每个 Pod 的所有标签。 很好！Pod 已经贴上了标签，我们准备好通过服务找到它们了。让我们定义 LoadBalancer 类型的服务，如图 18 所示。 服务的定义 LoadBalancer 服务的 YAML 定义如下所示：123456789101112apiVersion: v1kind: Service # 1metadata: name: sa-frontend-lbspec: type: LoadBalancer # 2 ports: - port: 80 # 3 protocol: TCP # 4 targetPort: 80 # 5 selector: # 6 app: sa-frontend # 7 #1 kind：服务； #2 type：指定类型，我们选择 LoadBalancer，因为我们想平衡 Pod 之间的负荷； #3 ports：指定服务获取请求的端口； #4 protocol：定义交流； #5 targetPort：可以将来访的请求转发到这个端口； #6 selector：包含选择pod属性的对象； #7 app：sa-frontend定义了哪个是目标 Pod，只有拥有标签“app: sa-frontend”的才是目标 Pod。 通过运行如下命令创建服务： 12kubectl create -f service-sa-frontend-lb.yamlservice \"sa-frontend-lb\" created 可以通过运行如下命令检查的服务的状态：123kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEsa-frontend-lb LoadBalancer 10.101.244.40 &lt;pending&gt; 80:30708/TCP 7m External-IP 处于 pending 状态（不用再等了，这个状态不会变的）。这是因为我们使用的是 Minikube。如果我们在 Azure 或 Google 云服务上运行，那么我们可以得到一个公开的 IP，那么全世界都可以访问我们的服务了。 尽管如此，Minikube 也不会置我们于不顾，它提供一个非常有用的本地调试命令，如下所示：12minikube service sa-frontend-lbOpening kubernetes service default/sa-frontend-lb in default browser... 这可以在浏览器中打开指向该服务的 IP。服务受到请求后，会将请求转发给其中一个 Pod（不用理会是哪个）。通过利用服务作为访问入口，这种抽象可以让我们看到并将多个 Pod 当成一个来交互。 服务的总结 在本节中，我们介绍了给资源贴标签，在服务中使用标签作为选择器，我们还定义并创建了一个 LoadBalancer 的服务。这满足了我们希望伸缩应用程序规模的需求（只需加入新的贴了标签的 Pod），并通过将服务作为访问入口在 Pod 之间做负载均衡。 五、Kubernetes 实践——部署Kubernetes 部署可以帮助每一个应用程序的生命都保持相同的一点：那就是变化。此外，只有挂掉的应用程序才会一尘不变，否则，新的需求会源源不断地涌现，更多代码会被开发出来、打包以及部署。这个过程中的每一步都有可能出错。 部署资源可以自动化应用程序从一版本升迁到另一版本的过程，并保证服务不间断，如果有意外发生，它可以让我们迅速回滚到前一个版本。 部署实践 现在我们有两个 Pod 和一个服务开放，而且它们之间有负载均衡（如图 19 所示）。我们提到过现有的 Pod 还远远不够完美。需要分开管理每一个 Pod（创建、更新、删除和监视他们的情况）。快速更新和迅速回滚根本不可能！这样是不行的，部署 Kubernetes 资源可以解决这里的每个问题。 在继续下面的内容之前，让我们复述下我们的目标，通过概述可以让我们更好的理解部署资源的清单文件的定义。我们想要的是： 映像 rinormaloku/sentiment-analysis-frontend 的两个 Pod； 部署期间服务不间断； Pod 贴有标签 app: sa-frontend，所以我们可以通过 sa-frontend-lb 服务找到各个服务。 在下一节中，我们可以将这些需求反映到部署的定义中。 部署的定义 如下资源定义的YAML文件可以达成以上所有提到的点： 1234567891011121314151617181920212223apiVersion: extensions/v1beta1kind: Deployment # 1metadata: name: sa-frontendspec: replicas: 2 # 2 minReadySeconds: 15 strategy: type: RollingUpdate # 3 rollingUpdate: maxUnavailable: 1 # 4 maxSurge: 1 # 5 template: # 6 metadata: labels: app: sa-frontend # 7 spec: containers: - image: rinormaloku/sentiment-analysis-frontend imagePullPolicy: Always # 8 name: sa-frontend ports: - containerPort: 80 #1 kind：部署； #2 replicas：是部署 Spec 对象的一个属性，定义了我们想运行多少的 Pod。所以是 2； #3 type：指定从当前版本升迁到下个版本的时候，部署使用的策略。此处的策略 RollingUpdate 可以保证部署期间服务不间断； #4 maxUnavailable：是 RollingUpdate 对象的一个属性，定义了在升级的时候，最大允许停止的 Pod 数量（与希望的状态相比）。对我们的部署来说，我们有 2 个副本，这意味着在一个 Pod 停止后，我们还会有另外一个 Pod 运行，所以可以保证应用程序可访问； #5 maxSurge：是 RollingUpdate 对象的另一个属性，定义了添加到部署的最大 Pod 数量（与希望的状态相比）。对我们的部署来说，这意味着在向新版本迁移的时候，我们可以加一个 Pod，那么我们可以同时拥有个 3 个 Pod； #6 template：指定 Pod 的模板，部署在创建新 Pod 的时候，会用到该模板。很可能这个非常相似的 Pod 会立即吸引你； #7 app: sa-frontend：根据模板创建的 Pod 将被贴上该标签； #8 imagePullPolicy：当设置成 Always 的时候，每一次新部署都会重新获取容器映像。 坦白来说，这一堆的文本让我更糊涂了，所以还是让我们来看个例子：12kubectl apply -f sa-frontend-deployment.yamldeployment \"sa-frontend\" created 照例让我们确认是否一切如约履行了： 123456kubectl get podsNAME READY STATUS RESTARTS AGEsa-frontend 1/1 Running 0 2dsa-frontend-5d5987746c-ml6m4 1/1 Running 0 1msa-frontend-5d5987746c-mzsgg 1/1 Running 0 1msa-frontend2 1/1 Running 0 2d 现在我们有 4 个运行中的 Pod，两个是由部署创建的，而另外两个是我们手动创建的。通过 kubectl delete pod 命令删除其中一个手动创建的 Pod。 练习：删除其中一个部署创建的 Pod，看看结果怎样。在阅读如下的解释前，请先想想原因。 解释：删除一个 Pod 后，部署注意到当前的状态（只有 1 个 Pod 在运行）与希望的状态（2 个 Pod 处于运行状态），所以它会再启动一个 Pod。 那么，除了保持希望的状态外，使用部署还有什么好处？让我们先来看看好处。 好处 1：采用零停机时间部署(Zero-downtime) 产品经理带着新的需求来找我们，说客户想要在前端加一个绿色的按钮。开发者写好了代码后，只需提供给我们一样必须的东西，容器映像 rinormaloku/sentiment-analysis-frontend:green。然后就该我们了，我们需要采用零停机时间部署，这项工作很难吗？让我们试试看！ 编辑 deploy-frontend-pods.yaml 文件，将容器映像改为新的映像：rinormaloku/sentiment-analysis-frontend:green。保存变更，并运行如下命令： 12kubectl apply -f deploy-frontend-green-pods.yaml --recorddeployment \"sa-frontend\" configured 让我们通过如下命令检查下上线的状态： 12345678kubectl rollout status deployment sa-frontendWaiting for rollout to finish: 1 old replicas are pending termination...Waiting for rollout to finish: 1 old replicas are pending termination...Waiting for rollout to finish: 1 old replicas are pending termination...Waiting for rollout to finish: 1 old replicas are pending termination...Waiting for rollout to finish: 1 old replicas are pending termination...Waiting for rollout to finish: 1 of 2 updated replicas are available...deployment \"sa-frontend\" successfully rolled out 从部署上看来，上线已经成功。在这个过程中副本被逐个替换。意味着应用程序始终在线。在继续下面的内容前，先让我们来确认一下更新确实有效。 确认部署 让我们在浏览器中确认更新的结果。运行我们之前用到过的命令 minikube service sa-frontend-lb，它会打开浏览器。我们可以看到按钮 SEND 已更新了。 “RollingUpdate”背后的情况 在我们应用了新的部署后，Kubernetes 会将新状态与旧的相比。在我们的例子中，新状态需要两个 rinormaloku/sentiment-analysis-frontend:green 映像的 Pod。这与当前的运行状态不同，所以 Kubernetes 会执行 RollingUpdate。 这里的 RollingUpdate 会根据我们指定的规格执行，也就是“maxUnavailable: 1″和“maxSurge: 1″。这意味着部署需要终止一个 Pod，并且仅可以运行一个新的 Pod。这个过程会不断重复，一直到所有的 Pod被替换（如图 21 所示）。 我们继续介绍第二个好处。 声明：出于娱乐的目的，下面的部分我按照小说的形式来书写。 好处2：回滚到前一个状态 产品经理跑进办公室说，他遇到一个大麻烦！ 产品经理大喊道：“产品环境中的应用程序有一个很关键的 bug！！需要马上回滚到前一个版本”。 你冷静地看着他，眼睛都没有眨一下，就转向了心爱的终端，然后开始敲： 12345kubectl rollout history deployment sa-frontenddeployments \"sa-frontend\"REVISION CHANGE-CAUSE1 &lt;none&gt; 2 kubectl.exe apply --filename=sa-frontend-deployment-green.yaml --record=true 你看了一眼前一个部署，然后问产品经理：“上个版本很多 bug，那前一个版本运行得很完美吗？” 产品经理吼道：“是啊，你没听见我说嘛？！” 你没理他，你知道该如何处理，于是你开始敲： 12kubectl rollout undo deployment sa-frontend --to-revision=1deployment \"sa-frontend\" rolled back 然后，你轻轻地刷新了页面，之前的修改全都不见了！ 产品经理瞠目结舌地看着你。 你拯救了大家！ 完 我知道……这是个很无聊的故事。在 Kubernetes 出现之前，这个故事挺好的，更加戏剧化，让人高度紧张，而且这种状态持续了很长时间。那段旧时光还是很美好的！ 大多数的命令都自带说明，只是有一些细节你需要自己搞清楚。为什么第一个版本中字段 CHANGE-CAUSE 的值为 ，而同时第二次改版的时候，CHANGE-CAUSE 的值为“kubectl.exe apply –filename=sa-frontend-deployment-green.yaml –record=true”。 你应该可以发现这是因为在应用新的映像的时候，我们用到了标志符 –record。 在下一节中，我们将使用之前所有的概念，完成整个架构。 六、Kubernetes 和其他一切的实战应用现在我们学习了完成架构的所有必须的资源，因此这一节会非常快。图 22 中灰色的部分是需要做的事情。让我们从底部开始：部署 sa-logic 的部署。 部署 SA-Logic 在终端中进入资源清单文件所在的目录，然后运行如下命令： 12kubectl apply -f sa-logic-deployment.yaml --recorddeployment \"sa-logic\" created SA-Logic 的部署会创建三个 Pod（Pod 上运行着我们的 Python 应用）。该命令还会给Pod 贴上 app: sa-logic 的标签。有了这个标签，我们就能从 SA-Logic 服务中利用选择器来选择这些 Pod。请花点时间打开 sa-logic-deployment.yaml，查看其内容。 这里的概念都是一样的，因此我们可以直接讲解下一个资源：SA-Logic 服务。 SA Logic 服务 首先来解释下为什么需要该服务。我们的 Java 应用（在 SA-WebApp 部署的 Pod 中运行）依赖于 Python 应用提供的情感分析。但现在，与我们在本地运行一切服务时的状况不同，我们并没有一个单一的 Python 应用监听着某个端口，我们只有两个 Pod，如果需要，我们可以有更多的 Pod。 这就是为什么需要“服务”为一组提供相同功能的 Pod 提供访问入口。这就是说，我们可以利用 SA-Logic 服务作为所有 SA-Logic Pod 的访问入口。 运行如下命令： 12kubectl apply -f service-sa-logic.yamlservice \"sa-logic\" created 更新后的应用程序状态：现在我们有两个 Pod 在运行（包含 Python 应用程序），并且 SA-Logic 服务提供了访问入口，该访问入口将在 SA-WebApp 的 Pod 中使用。 现在需要部署 SA-WebApp Pod，我们需要用到部署资源。 SA-WebApp 部署 我们已经学过了部署，尽管这个部署会用到更多的特性。打开 sa-web-app-deployment.yaml 文件，会发现以下的新内容： 12345678- image: rinormaloku/sentiment-analysis-web-app imagePullPolicy: Always name: sa-web-app env: - name: SA_LOGIC_API_URL value: \"http://sa-logic\" ports: - containerPort: 8080 我们感兴趣的第一件事就是 env 属性。我们猜测它定义了环境变量 SA_LOGIC_API_URl，值为在 Pod 内的值为 http://sa-logic。但为什么要初始化成 http://sa-logic，sa-logic 究竟是什么？ 我们先来介绍下 kube-dns。 KUBE-DNS Kubernetes 有个特殊的 Pod 叫做 kube-dns。默认情况下，所有 Pod 都用它作为 DNS 服务器。kube-dns 的一个重要属性就是它为每个建立的访问都创建一条 DNS 记录。 这就是说当我们创建 sa-logic 服务时，它会获得一个 IP 地址。它的名字会加入到 kube-dns 中（和它的 IP 地址一起）。这样所有 Pod 都能够把 sa-logic 翻译成 SA-Logic 服务的 IP 地址。 好，现在可以继续了： SA WebApp 部署（续） 运行以下命令： 12kubectl apply -f sa-web-app-deployment.yaml --recorddeployment \"sa-web-app\" created 完了。剩下的工作就是通过 LoadBalancer 服务将 SA-WebApp Pod 暴露到外部。LoadBalancer 服务提供了 SA-WebApp Pod 的访问入口，这样 React 应用程序就能发送 HTTP 请求了。 SA-WebApp 服务 打开 service-sa-web-app-lb.yaml 文件，可以看到内容还是挺熟悉的。 所以我们可以运行如下命令： 12kubectl apply -f service-sa-web-app-lb.yamlservice \"sa-web-app-lb\" created 这样架构就完成了。但还有一点不完美的地方。在部署 SA-Frontend Pod 之后，容器映像指向了 http://localhost:8080/sentiment 处的 SA-WebApp。但现在我们需要将其更新为 SA-WebApp LoadBalancer 的 IP 地址（其作用是 SA-WebApp Pod 的访问入口）。 修补该不完美是个快速复习一切的绝佳机会（如果能不参照以下的指南独立完成更好）。下面我们开始： 执行下列命令获取 SA-WebApp LoadBalancer 的 IP： 1234567891011minikube service list|-------------|----------------------|-----------------------------|| NAMESPACE | NAME | URL ||-------------|----------------------|-----------------------------|| default | kubernetes | No node port || default | sa-frontend-lb | http://192.168.99.100:30708 || default | sa-logic | No node port || default | sa-web-app-lb | http://192.168.99.100:31691 || kube-system | kube-dns | No node port || kube-system | kubernetes-dashboard | http://192.168.99.100:30000 ||-------------|----------------------|-----------------------------| 在 sa-frontend/src/App.js 中使用 SA-WebApp LoadBalancer 的 IP，如下： 12345analyzeSentence() &#123; fetch('http://192.168.99.100:31691/sentiment', &#123; /* shortened for brevity */&#125;) .then(response =&gt; response.json()) .then(data =&gt; this.setState(data)); &#125; 构建静态文件 npm build （需要先切换到 sa-front-end 目录）； 构建容器映像： docker build -f Dockerfile -t $DOCKER_USER_ID/sentiment-analysis-frontend:minikube . 将映像推送到 Docker hub： docker push $DOCKER_USER_ID/sentiment-analysis-frontend:minikube 编辑 sa-frontend-deployment.yaml 并使用新的映像； 执行 kubectl apply -f sa-frontend-deployment.yaml 命令。 刷新浏览器（如果你关闭了浏览器，则执行 minikube service sa-frontend-lb）。敲个句子试试看！ 七、全文总结Kubernetes 对团队、项目都很有好处，它能简化部署，提供伸缩性、灵活性，可以让我们使用任何底层基础设施。以后我们叫它 Supernetes 吧！ 本文中覆盖的内容： 构建/打包/运行 ReactJS、Java 和 Python 应用程序； Docker容器，如何利用 Dockerfile 定义并构建容器； 容器注册目录，我们采用 Docker Hub 作为容器的代码库； 介绍了 Kubernetes 的最重要的内容； Pod； 服务； 部署； 新概念，如零停机时间部署； 创建可伸缩的应用； 流程上，我们将整个微服务应用程序转成了 Kubernetes 集群。","tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.heqingbao.net/tags/Docker/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://www.heqingbao.net/tags/Kubernetes/"}]},{"title":"Docker集群之Swarm","date":"2018-11-04T17:11:23.000Z","path":"2018/11/05/docker-cluster-swarm/","text":"介绍Docker三剑客： docker-machine # 提供容器服务 docker-compose # 提供脚本执行服务 docker-swarm # 提供容器的集群技术 docker-swarm集群节点分为manager和worker节点，manager节点是管理swarm集群的，worker是工作节点，是用来运行容器部署项目的。manager节点除了管理集群之外，其自身也会承担work节点的工作。 无论是manager还是work节点，都可以配置多节点。如果一个manger节点挂掉，其它的manager节点就会选举一个新的manager节点来管理swarm集群。worker节点也是一样。 创建swarm集群1docker swarm init 可加参数： --listen-addr ip:port # 管理者节点 --advertise-addr ip # 广播地址 加入swarm集群添加manager或者work节点到集群，只需要执行对应的命令即可：12docker swarm join-token managerdocker swarm join-token worker 查看Swarm集群节点只可以在Manager节点执行该命令：1docker node ls 查看Swarm集群网络docker集群创建完成后，它自带了一个共享的网络。 查看网络信息：1docker network ls 会看找到一个ingress的共享网络，它的类型是overlay，归属于swarm集群。 ingress网络不是用来作容器和容器之间业务通信的，它是用来管理swarm集群的。我们需要创建新的共享网络。 创建共享网络1docker network create -d overlay --attachable swarm_test 这样创建的共享网络就可以作为容器间进行业务通信了。 创建容器如果在创建容器的时候，如果想使用共享网络，只需要加上--net=swarm_test即可： 1docker run -it --net=swarm_test ... 举例：在主机1里面创建docker容器的时候使用swarm_test共享网络，在主机2里面也创建docker容器的时候也使用swarm_test共享网络，那么两个主机的docker容器就可以利用这个共享网络实现业务的通讯。 退出Swarm集群主动退出集群： 1docker swarm leave --forece manager退出集群必须要使用–force参数 被动退出集群： 如果是manager节点想要退出集群，需要在其它节点里面把这个manager节点进行降级成worker节点：1docker node demote 节点名字 删除：1docker node rm 节点名字 删除任何的节点必须要先停止它的Docker服务，Manager节点必须先降级成Worker节点，再删除。","tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.heqingbao.net/tags/Docker/"}]},{"title":"Docker搭建MySQL集群","date":"2018-11-03T18:36:11.000Z","path":"2018/11/04/docker-mysql-cluster/","text":"零、MySQL集群方案介绍常见的MySQL集群方案： Replication 特点：速度快，弱一致性，低价值 应用举例：日志、新闻、帖子 PXC 特点：速度慢，强一致性，高价值 应用举例：订单、账户、财务 本文将讲解PXC文案的使用。 一、安装PXC镜像本文MySQL集群文案使用pxc docker的镜像仓库中包含了pxc数据库的镜像，下载即可：1docker pull percona/percona-xtradb-cluster 也可以从本地导入镜像：1docker load &lt; /home/soft/pxc.tar.gz 下载成功以后，可以看到：123[root@VM_0_3_centos docker_shared]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/percona/percona-xtradb-cluster latest 7ad1b9c338b6 4 weeks ago 413 MB 可以看到，这个镜像名字有点长，方便后面使用，我们修改一下：1docker tag docker.io/percona/percona-xtradb-cluster pxc 然后原来名字的镜像就可以删除了：1docker rmi docker.io/percona/percona-xtradb-cluster 二、创建内部网络出于安全考虑，需要给PXC集群实例创建Docker内部网络 创建网段：1docker network create --subnet=172.18.0.0/24 net1 查看一下：1docker inspect net1 将看到类似如下信息：123456789101112131415161718192021222324[ &#123; \"Name\": \"net1\", \"Id\": \"3d199b40cf4abfcd6f7f9500396fc9a2a0a860f4809e97c386edc494149f2a07\", \"Created\": \"2018-11-04T20:59:38.530177174+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": &#123; \"Driver\": \"default\", \"Options\": &#123;&#125;, \"Config\": [ &#123; \"Subnet\": \"172.18.0.0/24\" &#125; ] &#125;, \"Internal\": false, \"Attachable\": false, \"Containers\": &#123;&#125;, \"Options\": &#123;&#125;, \"Labels\": &#123;&#125; &#125;] 此网段也可以删除：1docker network rm net1 三、创建Docker卷一旦docker容器创建完成后，尽量不要在容器里面保存业务数据，要把数据保存在宿主机上，使用的技术就是通过目录映射，可以把宿主机上的一个目录，映射到容器内，在运行容器的时候，把业务数据保存在这个映射目录里面，也就相当于存储在宿主机上面，这样如果出现什么故障的话，只需要把故障的容器删除掉，重新创建一个新的容器，然后把目录映射给新的容器，那么新容器启动后就自带了这些业务数据。 PXC这种技术，运行在docker容器里面，它无法直接使用映射的目录，这里采用另一种目录映射技术：Docker卷。 创建数据卷：1docker volume create v1 查看数据卷到底是创建在宿主机的位置：1docker inspect v1 将看类似输出：12345678910[ &#123; \"Driver\": \"local\", \"Labels\": &#123;&#125;, \"Mountpoint\": \"/var/lib/docker/volumes/v1/_data\", \"Name\": \"v1\", \"Options\": &#123;&#125;, \"Scope\": \"local\" &#125;] 可以看到数据卷在宿主机上的真实位置是：/var/lib/docker/volumes/v1/_data 如果想删除数据卷：1docker volume rm v1 查看所有的数据卷：1docker volume ls 移除所有未使用的数据卷：1docker volume prune 四、创建PXC容器只需要向PXC镜像传入运行参数就能创建出PXC容器：1234567docker run -d -p 3306:3306 \\-e MYSQL_ROOT_PASSWORD=abc123456 \\-e CLUSTER_NAME=PXC \\-e XTRABACKUP_PASSWORD=abc123456 \\-v v1:/var/lib/mysql \\--privileged --name=node1 \\--net=net1 --ip 172.18.0.2 pxc 参数解释： -d: 创建出来的容器在后台运行 -p: 端口映射，前面是宿主机端口，后面是容器端口 -e: 启动参数： MYSQL_ROOT_PASSWORD：MySQL的Root用户密码 CLUSTER_NAME：PXC集群的名字 XTRABACKUP_PASSWORD：数据库节点同步需要的密码 -v: 目录映射，把v1数据卷映射到容器里mysql的数据目录 --privilleged：给权限 name：容器的名字 --net: 使用的内部网段 --ip: 分到网段的IP地址 pxc: 镜像的名字 以上执行会比较耗时，要耐心等待。 如果第一个pxc容器里的mysql没有启动，你就创建了第2个pxc容器，第2个pxc容器启动会闪退，因为第2个里面的mysql和第一个容器里面的mysql是同步的，它发现第1个容器的mysql未启动成功，它就会出故障，导致闪退。 一定要等第一个容器里mysql成功始化，并且通过客户端能连接这个mysql实例了，再去创建第2个、第3个、第4个、第n个实例。 注：与该实例建立连接的用户名和密码分别是：root和123456，比较简单的方式是使用DataGrip 创建第二个pxc容器：12345678docker run -d -p 3307:3306 \\-e MYSQL_ROOT_PASSWORD=abc123456 \\-e CLUSTER_NAME=PXC \\-e XTRABACKUP_PASSWORD=abc123456 \\-e CLUSTER_JOIN=node1 \\-v v2:/var/lib/mysql \\--privileged --name=node2 \\--net=net1 --ip 172.18.0.3 pxc 参数解释（与第一个容器不一样的参数）： -p: 端口映射，容器的3306端口映射宿主的3307 CLUSTER_JOIN：因为这个节点需要加入集群，需要指定和哪个节点进行同步。这里指定跟第一个容器的节点同步。 -v: 映射的数据卷是v2 –name: 节点名字 –ip: 分配的IP地址不一样 按照以上方式，创建五个pxc容器：12345678910111213[root@VM_0_3_centos _data]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd6f2cf84f2b4 pxc \"/entrypoint.sh \" 2 minutes ago Up 2 minutes 4567-4568/tcp, 0.0.0.0:3310-&gt;3306/tcp node54a98ea2eaad8 pxc \"/entrypoint.sh \" 2 minutes ago Up 2 minutes 4567-4568/tcp, 0.0.0.0:3309-&gt;3306/tcp node4fed9859cc58a pxc \"/entrypoint.sh \" 4 minutes ago Up 3 minutes 4567-4568/tcp, 0.0.0.0:3308-&gt;3306/tcp node38663b08d8ec3 pxc \"/entrypoint.sh \" 5 minutes ago Up 5 minutes 4567-4568/tcp, 0.0.0.0:3307-&gt;3306/tcp node268138538a901 pxc \"/entrypoint.sh \" 20 minutes ago Up 20 minutes 0.0.0.0:3306-&gt;3306/tcp, 4567-4568/tcp node1[root@VM_0_3_centos _data]# netstat -apnlt | grep dockertcp6 0 0 :::3307 :::* LISTEN 13263/docker-proxy- tcp6 0 0 :::3308 :::* LISTEN 14589/docker-proxy- tcp6 0 0 :::3309 :::* LISTEN 15926/docker-proxy- tcp6 0 0 :::3310 :::* LISTEN 17230/docker-proxy- tcp6 0 0 :::3306 :::* LISTEN 11209/docker-proxy- 4.1 测试PXC集群是否成功：用DataGrid创建5个MySQL连接，在其中一个数据里面创建schema，再创建一张表，如果有同步到其它数据库，说成PXC集群搭建成功。或者通过命令行。 注：我这里使用最新版的DataGrid测试有问题，如果遇到同样的情况，建议使用命令行测试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104[root@VM_0_3_centos ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES837a571fbb0b pxc \"/entrypoint.sh \" 9 seconds ago Up 8 seconds 4567-4568/tcp, 0.0.0.0:3307-&gt;3306/tcp node2b7bc29bf17ea pxc \"/entrypoint.sh \" 2 minutes ago Up 2 minutes 0.0.0.0:3306-&gt;3306/tcp, 4567-4568/tcp node1[root@VM_0_3_centos ~]# docker exec -it b7 bashmysql@b7bc29bf17ea:/$ mysql -h localhost -uroot -pabc123456mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 88Server version: 5.7.23-23-57 Percona XtraDB Cluster (GPL), Release rel23, Revision f5578f0, WSREP version 31.31, wsrep_31.31Copyright (c) 2009-2018 Percona LLC and/or its affiliatesCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; create database test;Query OK, 1 row affected (0.03 sec)mysql&gt; use test;Database changedmysql&gt; create table ttt(id int auto_increment primary key);Query OK, 0 rows affected (0.13 sec)mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| ttt |+----------------+1 row in set (0.00 sec)mysql&gt; insert ttt (id) values (100);Query OK, 1 row affected (0.01 sec)mysql&gt; insert ttt (id) values (101);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from ttt;+-----+| id |+-----+| 100 || 101 |+-----+2 rows in set (0.00 sec)mysql&gt; exitByemysql@b7bc29bf17ea:/$ exitexit[root@VM_0_3_centos ~]# docker exec -it 83 bashmysql@837a571fbb0b:/$ mysql -h localhost -uroot -pabc123456 mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 5Server version: 5.7.23-23-57 Percona XtraDB Cluster (GPL), Release rel23, Revision f5578f0, WSREP version 31.31, wsrep_31.31Copyright (c) 2009-2018 Percona LLC and/or its affiliatesCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test |+--------------------+5 rows in set (0.00 sec)mysql&gt; use test;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| ttt |+----------------+1 row in set (0.00 sec)mysql&gt; select * from ttt;+-----+| id |+-----+| 100 || 101 |+-----+2 rows in set (0.00 sec) 以上可以看出，测试成功。 五、使用Haproxy进行负载均衡拉取Haproxy：1docker pull haproxy 创建Haproxy配置文件，这里直接在宿主机上创建，然后映射 到容器中。1touch /root/docker_shared/haproxy.cfg 配置文件详情可以参考：https://zhangge.net/5125.html 启动Haproxy容器:1234docker run -it -d \\-p 4001:8888 -p 4002:3306 \\-v /root/docker_shared:/usr/local/etc/haproxy \\--name h1 --privileged --net=net1 haproxy 参数解释： -p: 端口映射 4002:3306, haproxy对外提供一个数据库负载均衡的服务，映射到宿主机上的4002端口，因为宿主机上的3306端口已经被占用了。 4001:8888，haproxy提供了一个监控页面，在配置文件中定义的8888端口。 -v: 目录映射 –name: 起名，命名h1是因为后面可能会配置成双节点。 –net: 网段，因为haproxy这个负载均衡的实例都是net1网段。 进入到刚才启动的haproxy的容器里：1docker exec -it h1 bash 在容器里启动haproxy（注意，是在容器里执行）:1root@9e41b6d6d1b9:/# haproxy -f /usr/local/etc/haproxy/haproxy.cfg 需要在数据上创建一个haproxy的账号，因为haproxy这个中间件要用这个账号登录数据库，然后发心跳检测。1CREATE USER 'haproxy'@'%' IDENTIFIED BY ''; 表示任何IP都可以以haproxy账号登录到数据库，密码为空。 在浏览器上访问：http://ip:4001/dbs 查看监控状态。（用户名和密码配置haproxy.cfg里面） 测试： 在DataGrid上为Haproxy创建连接进行测试： Host：ip Port: 4002 User: root Passowrd: abc123456 通过操作haproxy这个连接操作数据库，测试是否可以通步到所有集群节点。 六、对Haproxy进行高可用配置6.1 安装KeepalivedKeepalived必须安装在Haproxy所在的容器之内 1docker exec -it h1 bash 更新apt-get:1apt-get update 安装keepalived:1apt-get install keepalived 创建Keepalived配置文件：/etc/keepalived/keepalived.conf1234567891011121314vrrp_instance VI_1 &#123; state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 123456 &#125; virtual_ipaddress &#123; 172.18.0.201 &#125;&#125; 启动Keepalived：1service keepalived start 启动完成后，宿主机可以Ping通虚拟IP：12345678[root@VM_0_3_centos docker_shared]# ping 172.18.0.201PING 172.18.0.201 (172.18.0.201) 56(84) bytes of data.64 bytes from 172.18.0.201: icmp_seq=1 ttl=64 time=0.101 ms64 bytes from 172.18.0.201: icmp_seq=2 ttl=64 time=0.081 ms^C--- 172.18.0.201 ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 999msrtt min/avg/max/mdev = 0.081/0.091/0.101/0.010 ms 七、使用XtraBackup进行数据备份XtraBackup是一款基于InnoDB的在线热备工具，具有开源免费、支持在线热备、占用磁盘空间小等特点，能够非常快速地备份与恢复mysql数据库。 因为该工具需要安装在数据库所在的容器之内，它备份出来的数据就直接保存在容器里了，这么做tvei好，我们应该把备份出的数据保存在宿主机上，应该采用映射的技术。 所以先要在宿主机上创建一个数据卷，然后映射到某一个数据库的节点上。 (以下主要讲解全量数据的热备份和冷恢复) 创建数据卷：1docker volume create backup 挑node1这个节点进行操作(先删掉，然后再创建一个新的，因为之前创建的时候对数据有做映射，所以数据不会丢)12docker stop node1docker rm node1 创建一个新的：123456789docker run -d -p 3306:3306 \\-e MYSQL_ROOT_PASSWORD=abc123456 \\-e CLUSTER_NAME=PXC \\-e XTRABACKUP_PASSWORD=abc123456 \\-e CLUSTER_JOIN=node2 \\-v v2:/var/lib/mysql \\-v backup:/data \\--privileged --name=node1 \\--net=net1 --ip 172.18.0.2 pxc 参数解释(仅列出与前面不同的)： -v backup:/data 映射容器目录 -e CLUSTER_JOIN=node2 现在创建的节点需要跟什么节点同步(以前是其它节点与我同步的)，现在我停止以后，再创建一个新的node1，要与现在的数据库集群里某一个节点进行同步，这里选择node2，现在有的里随便挑一个就行。 PXC容器中安装XtraBackup，并执行全量备份：123apt-get updateapt-get install percona-xtrabackup-24innobackupex --user=root --password=abc123456 /data/backup/full 注意，如果进入容器之后不是管理员身份，可以加–user参数指定：docker exec -it –user root node1 bash 执行完成之后，备份的数据在：/var/lib/docker/volumes/backup/_data/backup/full/2018-11-05_01-51-23 PXC全量恢复步骤： 数据库可以热备份，但是不能热还原。为了避免恢复过程中的数据同步，我们采用空白的MySQL还原数据，然后再建立PXC集群。 还原数据前要将未提交的事务回滚，还原数据之后重启MySQL。 操作：1234docker stop node1 node2 node3docker rm node1 node2 node3docker volume rm v1 v2 v3docker volume create v1 创建一个新的：12345678docker run -d -p 3306:3306 \\-e MYSQL_ROOT_PASSWORD=abc123456 \\-e CLUSTER_NAME=PXC \\-e XTRABACKUP_PASSWORD=abc123456 \\-v v1:/var/lib/mysql \\-v backup:/data \\--privileged --name=node1 \\--net=net1 --ip 172.18.0.2 pxc 再进入这个容器：1docker exec -it node1 bash 执行清空MySQL指令，把没有提交的事务回滚：1innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-11-05_01-51-23 执行冷还原：1innobackupex --user=root --password=abc123456 --copy-back /data/backup/full/2018-11-05_01-51-23 退出容器，然后重新node1节点：123exitdocker stop node1docker start node1 查看node1里面的数据是否有正确恢复。","tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.heqingbao.net/tags/Docker/"},{"name":"MySql","slug":"MySql","permalink":"http://www.heqingbao.net/tags/MySql/"}]},{"title":"CentOS安装Redis","date":"2018-03-18T12:17:35.000Z","path":"2018/03/18/centos-redis/","text":"本文基于CentOS7和Redis3.2.11版本，其它版本的安装方式可能会有些出处，请自行辨别。 目前Redis刚Release 4.0版本，据说有不少改进，对比了各个版本的使用情况，感觉3.x的最后一个版本（也就是4.0的上一个版本）应该目前是稳定的，并且风险最小的。而且文档上有这么一句话： Redis 3.2 is the previous stable release. Does not include all the improvements in Redis 4.0 but is a very battle tested release, probably a good pick for critical applications while 4.0 matures more in the next months.See the release notes or download 3.2.11. 所以本文以3.2.11版本为例，记录各个安装步骤。 一、下载1$ wget http://download.redis.io/releases/redis-3.2.11.tar.gz 二、解压1$ tar -zxvf redis-3.2.11.tar.gz 三、安装1. 安装到/user/local/redis目录12$ cd redis-3.2.11$ make PREFIX=/usr/local/redis install 2. 配置redis.conf是Redis的配置文件，位于源码目录里面，拷贝此配置文件到安装目录下： 123$ cd /usr/local/redis$ mkdir conf$ cp ~/redis-3.2.11/redis.conf . 此时目录结构应该是这样子的： 12345678910|-- bin| |-- dump.rdb| |-- redis-benchmark| |-- redis-check-aof| |-- redis-check-rdb| |-- redis-cli| |-- redis-sentinel -&gt; redis-server| `-- redis-server`-- conf `-- redis.conf 解释一下: cmd comments redis-server Redis服务器 redis-cli Redis命令行客户端 redis-benchmark Redis性能测试工具 redis-check-aof AOF文件修复工具 redis-check-rdb RBD文件修复工具 redis-sentinel Redis集群管理工具 四、启动1. 前端模式启动直接运行bin/redis-server将以前端模式启动，之所以叫前端模式，就是启动后会占用命令行窗口，如果窗口关闭或结束进程，redis-server也会结束，主要用于实时方便测试。 123456789101112131415161718192021222324$ ./redis-server 26093:C 17 Mar 22:45:12.374 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 3.2.11 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 26093 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 26093:M 17 Mar 22:45:12.375 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.26093:M 17 Mar 22:45:12.375 # Server started, Redis version 3.2.1126093:M 17 Mar 22:45:12.375 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.26093:M 17 Mar 22:45:12.375 * The server is now ready to accept connections on port 6379 新开一个终端窗口测试一下： 123$ ./redis-cli 127.0.0.1:6379&gt; pingPONG 2. 后端模式启动后端模式启动需要修改配置文件(redis.conf)，把此文件里面的daemonize改成yes就可以了，默认是no: 123# By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.daemonize yes 启动的时候指定使用我们的配置文件： 12$ ./redis-server ../conf/redis.conf $ 可以看到，启动完成后不会占用终端窗口。 测试一下：12345678$ ./redis-cli 127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set testkey helloOK127.0.0.1:6379&gt; get testkey\"hello\"127.0.0.1:6379&gt; Redis默认使用6379端口，可以更改配置文件(redis.conf)修改此端口号： 123# Accept connections on the specified port, default is 6379 (IANA #815344).# If port 0 is specified Redis will not listen on a TCP socket.port 6379 五、连接和关闭1.连接可以通过/user/local/bin/redis-cli命令来连接本地或远程的Redis。 前面已经测试过连接本地的Redis服务，下面讲一下连接远程的。 默认情况下，Redis不允许远程连接，需要修改配置文件(redis.conf)： 注释掉bind 127.0.0.1 修改protected-mode no 1$ redis-cli -h x.x.x.x -p 6379 2.设置连接密码默认情况下连接redis是不需要密码的。如果打开可远程连接，建议设置密码提高安全性。设置密码也需要修改配置文件(redis.conf)： 打开requirepass的注释，并且设置你自己的密码：1requirepass mypassword 之后在远程连接的时候就需要加上密码参数： 1$ redis-cli -h x.x.x.x -p 6379 -a mypassword 3.关闭在客户端执行：1x.x.x.x:6379&gt; shutdown","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.heqingbao.net/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://www.heqingbao.net/tags/CentOS/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://www.heqingbao.net/tags/Tomcat/"}]},{"title":"CentOS安装Tomcat","date":"2017-12-16T08:52:16.000Z","path":"2017/12/16/centos-tomcat/","text":"第一步 下载本文以安装Tomcat7为例 先下载： 1[root@VM_64_70_centos ~]# wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.82/bin/apache-tomcat-7.0.82.tar.gz 第二步 安装2.1 解压：1[root@VM_64_70_centos ~]# tar zxvf apache-tomcat-7.0.82.tar.gz Tomcat直接是一个压缩包，解压后就可以直接使用。这里为了和其它软件统一，把它放到移到/usr/local目录下：1[root@VM_64_70_centos ~]# mv ~/apache-tomcat-7.0.82 /usr/local/ 启动： 1[root@VM_64_70_centos ~]# /usr/local/apache-tomcat-7.0.82/bin/startup.sh 访问： 1http://localhost:8080/ 停止： 1[root@VM_64_70_centos ~]# /usr/local/apache-tomcat-7.0.82/bin/shutdown.sh 第三步 配置3.1 配置角色管理在/usr/local/apache-tomcat-7.0.82/conf/tomcat-users.xml末尾添加：12345&lt;role rolename=\"admin-gui\"/&gt;&lt;role rolename=\"admin-script\"/&gt;&lt;role rolename=\"manager-gui\"/&gt;&lt;role rolename=\"manager-script\"/&gt;&lt;user username=\"username\" password=\"password\" roles=\"admin-gui,admin-script,manager-gui,manager-script\"/&gt;","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.heqingbao.net/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://www.heqingbao.net/tags/CentOS/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://www.heqingbao.net/tags/Tomcat/"}]},{"title":"CentOS安装nginx","date":"2017-12-16T08:23:52.000Z","path":"2017/12/16/centos-web/","text":"本文使用编译源码的方式安装 第零步 安装依赖1[root@VM_64_70_centos ~]# yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 第一步 下载1[root@VM_64_70_centos ~]# wget https://nginx.org/download/nginx-1.12.2.tar.gz 第二步 安装解压： 1[root@VM_64_70_centos ~]# tar -zxvf nginx-1.12.2.tar.gz 1234567891011121314[root@VM_64_70_centos ~]# cd nginx-1.12.2/[root@VM_64_70_centos nginx-1.12.2]# ./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--with-http_ssl_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgi 上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录： 1[root@VM_64_70_centos nginx-1.12.2]# mkdir -p /var/temp/nginx 编译安装：1[root@VM_64_70_centos nginx-1.12.2]# make &amp;&amp; make install 启动：12[root@VM_64_70_centos nginx-1.12.2]# cd /usr/local/nginx/[root@VM_64_70_centos nginx]# ./sbin/nginx 第三步 验证查询nginx进程：1234[root@VM_64_70_centos nginx]# ps aux | grep nginxroot 16677 0.0 0.0 20008 648 ? Ss 12:29 0:00 nginx: master process ./sbin/nginxnobody 16678 0.0 0.0 20452 1556 ? S 12:29 0:00 nginx: worker processroot 17090 0.0 0.0 6444 696 pts/0 R+ 12:32 0:00 grep nginx 16677是nginx主进程的进程id，16678是nginx工作进程的进程id 访问：http://localhost/ 第四步 配置4.1 停止 方式一：快速停止 1[root@VM_64_70_centos nginx]# ./sbin/nginx -s stop 此方式相当于先查出nginx进程id再使用kill命令强制杀死进程 方式二：完整停止1[root@VM_64_70_centos nginx]# ./sbin/nginx -s quit 此方式会待nginx进程处理任务完毕后停止，推荐使用。 4.2 重启 方式一：先停止再启动 12[root@VM_64_70_centos nginx]# ./sbin/nginx -s quit[root@VM_64_70_centos nginx]# ./sbin/nginx 方式二：重新加载配置文件 当nginx的配置文件nginx-conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止再启动即可将配置信息生效： 1[root@VM_64_70_centos nginx]# ./sbin/nginx -s reload 4.3 配置虚拟主机虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供www服务，这样就可以实现一台主机对外提供多个web服务，每个虚拟主机之间是独立的，互不影响。 Nginx支持三种类型的虚拟主机配置： 基于ip的虚拟主机 基于域名的虚拟主机 基于端口的虚拟主机 4.4 配置SSL这里以免费的Let’s Encrypt证书举例，。 有两种方式安装： 使用certbot自动安装，安装过程中会自动配置当前的nginx，比较适用于通过Yum安装nginx的方式。 使用letsencrypt源码安装。 前面安装Nginx是使用源码安装的，所以这里我还是使用第2种基于源码的方式安装，对于第1种使用certbot的方式应该也可以，可自行尝试。 下载：1git clone https://github.com/letsencrypt/letsencrypt.git 12cd letsencrypt./letsencrypt-auto certonly --standalone 期间会提示输入email和domain等信息 生成的证书会存放在/etc/letsencrypt/live/{domain}/下，Nginx中用到的是fullchain.pem 和 privkey.pem，其它为Apache使用的证书。 接下来需要配置Nginx，开启ssl，编辑/usr/local/nginx/conf/nginx.conf 1234567891011121314151617181920# HTTPS server#server &#123; listen 443 ssl; server_name example.net; ssl_certificate /etc/letsencrypt/live/17club.net/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/17club.net/privkey.pem; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125;&#125; 访问：https://example.net 验证效果。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.heqingbao.net/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://www.heqingbao.net/tags/CentOS/"},{"name":"Nginx","slug":"Nginx","permalink":"http://www.heqingbao.net/tags/Nginx/"}]},{"title":"CentOS 7 安装 JDK","date":"2017-12-16T08:23:39.000Z","path":"2017/12/16/centos-jdk/","text":"第零步 准备更新包1[root@VM_64_70_centos ~]# yum update 检查服务器上是否已安装java1[root@VM_64_70_centos ~]# java --version 如果有安装旧版本，先移除1[root@VM_64_70_centos ~]# yum remove java-1.7.0-openjdk 第一步 下载本文以安装jdk8为例。 先下载对应的rpm包： 1[root@VM_64_70_centos ~]# wget --no-cookies --no-check-certificate --header \"Cookie: oraclelicense=accept-securebackup-cookie\" http://download.oracle.com/otn-pub/java/jdk/8u151-b12/e758a0de34e24606bca991d704f6dcbf/jdk-8u151-linux-x64.rpm 第二步 安装1[root@VM_64_70_centos ~]# rpm -ivh jdk-8u151-linux-x64.rpm 将会安装在/usr/java/jdk1.8.0_151目录下 第三步 配置环境变量在/etc/profile文件后面添加：123export JAVA_HOME=/usr/java/defaultexport PATH=$PATH:$JAVA_HOME/binexport CLASSPATH=.:$JAVA_HOME/jre/lib:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar 使环境变量生效：1[root@VM_64_70_centos ~]# source /etc/profile 第四步 验证1234[root@VM_64_70_centos ~]# java -versionjava version \"1.8.0_151\"Java(TM) SE Runtime Environment (build 1.8.0_151-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.heqingbao.net/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://www.heqingbao.net/tags/CentOS/"},{"name":"JDK","slug":"JDK","permalink":"http://www.heqingbao.net/tags/JDK/"}]},{"title":"CentOS 7 安装 MySQL","date":"2017-12-16T07:29:41.000Z","path":"2017/12/16/centos-mysql/","text":"MySQL是一个开源的数据库管理系统，通常作为流行的LEMP(Linux，Nginx，MySQL/MariaDB，PHP/Python/Perl)堆栈安装，它使用关系数据库和SQL结构化语言。 如果你在CentOS 7上运行yum install mysql，那就是安装了MariaDB，而不是MySQL。如果你想了解MySQL和MariaDB对比，MariaDB通常可以无缝地代替MySQL。具体差异可参考其它相关文档，这篇文章只介绍在CentOS 7系统下安装MySQL。 预备知识要开始这篇文章，你需要有以下预备知识： 一个CentOS 7的系统，并且具有安装软件的权限 基本的Linux命令 第一步 安装MySQL前面提到过，默认情况下使用yum将安装MariaDB，要安装MySQL，我们需要访问MySQL社区提供的Yum资源包。 在浏览器上访问： 1https://dev.mysql.com/downloads/repo/yum/ 下载：1[root@VM_64_70_centos ~]# wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 下载完成后，可以与网站上对比一下md5sum，保证下载文件的完整性。 安装这个包：1[root@VM_64_70_centos ~]# rpm -ivh mysql57-community-release-el7-9.noarch.rpm 这将添加两个新的MySQL源，接下来就可以使用它去安装MySQL服务了。 1[root@VM_64_70_centos ~]# yum install -y mysql-server 第二步 开启MySQL使用下面的命令启动守护进程：1[root@VM_64_70_centos ~]# systemctl start mysqld 如果没有任何输出就表示启动成功了。可以使用下面命令检查运行状态：1234567891011121314[root@VM_64_70_centos ~]# systemctl status mysqld● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: active (running) since Sat 2017-12-16 14:31:26 CST; 15s ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 9334 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS) Process: 9258 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 9339 (mysqld) CGroup: /system.slice/mysqld.service └─9339 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidDec 16 14:31:15 VM_64_70_centos systemd[1]: Starting MySQL Server...Dec 16 14:31:26 VM_64_70_centos systemd[1]: Started MySQL Server. 注：MySQL安装后会自动开机启动，可以执行systemctl disable mysqld改变这种默认行为。 安装完成后，会为root用户生成一个默认的密码：12[root@VM_64_70_centos ~]# grep 'temporary password' /var/log/mysqld.log2017-12-16T06:31:17.089898Z 1 [Note] A temporary password is generated for root@localhost: Ktp#)8eg4fp! 这个密码在下一步的安装配置中将会用到，并且会让你强制修改。 第三步 配置MySQLMySQL包含一个脚本，可以简单配置一些不太安全的默认选项，比如远程root登录。 1[root@VM_64_70_centos ~]# mysql_secure_installation 将会提示你输入root用户的密码，也就是前面自动生成的默认密码。然后会需要修改密码。 注：默认的密码安全策略：至少包含一个大写字母，一个小写字母，一个数字，一个特殊字符。 然后可能会有一些提示问你是否要删除匿名用户、是否开启远程登录，删除测试数据库等，建议这些都关掉，后面需要的时候手动配置。 Ok，到这里就已经安装完了，并且一些基本的配置也搞定了。 第四步 测试MySQL1[root@VM_64_70_centos ~]# mysqladmin -u root -p version 输入root用户密码后，将看到类似这样的输出：1234567891011121314mysqladmin Ver 8.42 Distrib 5.7.20, for Linux on x86_64Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Server version 5.7.20Protocol version 10Connection Localhost via UNIX socketUNIX socket /var/lib/mysql/mysql.sockUptime: 5 min 50 secThreads: 1 Questions: 17 Slow queries: 0 Opens: 113 Flush tables: 1 Open tables: 106 Queries per second avg: 0.048 表明已经安装成功。 第五步 开启远程连接如果在第三步执行配置脚本的时候后面选择了不开启远程登录，那么需要手动配置开启远程登录。 编译MySQL配置文件：1[root@VM_64_70_centos ~]# vim /etc/my.cnf 把下面的配置粘贴到[mysqld]块的最下面1bind-address = * 重启MySQL1[root@VM_64_70_centos ~]# systemctl restart mysqld 下面为远程连接登录一个新用户，并且授予所有的特权：123mysql&gt; create user 'username'@'%' identified by 'password';mysql&gt; grant all privileges on *.* to 'username'@'%' identified by 'password';mysql&gt; flush privileges; 12345678910mysql&gt; select user,host from user;+---------------+-----------+| user | host |+---------------+-----------+| heqingbao | % || mysql.session | localhost || mysql.sys | localhost || root | localhost |+---------------+-----------+4 rows in set (0.00 sec) 可以看到对应的账户已经创建成功。 测试一下：123456789101112131415➜ ~ mysql -h xxx.xxx.xxx.xxx -P 3306 -u heqingbao -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 17Server version: 5.7.20 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; Ok，可以看到已经远程登录成功了。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.heqingbao.net/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://www.heqingbao.net/tags/CentOS/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.heqingbao.net/tags/MySQL/"}]},{"title":"Java动态代理浅析","date":"2017-06-05T12:40:25.000Z","path":"2017/06/05/Java-Dynamic-Proxy/","text":"代理：设计模式代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。 为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。 代码是最好的老师用法示例先通一个简单的使用示例展示一下基本的用法。 12345678/** * 需要动态代理的接口 */public interface Subject &#123; String sayHello(String name);&#125; 1234567891011/** * 实际对象 */public class RealSubject implements Subject &#123; @Override public String sayHello(String name) &#123; return \"Hello \" + name; &#125;&#125; 1234567891011121314151617181920212223242526/** * 调用处理器实现类 * 每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象 */public class InvocationHandlerImpl implements InvocationHandler &#123; private Object subject; public InvocationHandlerImpl(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"Method：\" + method); System.out.println(\"调用之前，我可以做点事情\"); Object returnValue = method.invoke(subject, args); System.out.println(\"调用之后，我也可以做点事情\"); return returnValue; &#125;&#125; 12345678910111213141516171819202122public class Main &#123; public static void main(String args[]) &#123; Subject realSubject = new RealSubject(); InvocationHandler handler = new InvocationHandlerImpl(realSubject); ClassLoader loader = realSubject.getClass().getClassLoader(); Class[] interfaces = realSubject.getClass().getInterfaces(); Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); System.out.println(\"动态代理对象的类型：\" + subject.getClass().getName()); String result = subject.sayHello(\"Tom\"); System.out.println(result); &#125; &#125; 输出结果：12345动态代理对象的类型：com.sun.proxy.$Proxy0Method：public abstract java.lang.String com.demo.proxy.Subject.sayHello(java.lang.String)调用之前，我可以做点事情调用之后，我也可以做点事情Hello Tom 源码分析从上面的使用代码可以看出，生成代码对象的关键位置是： 1Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); 从前面的执行结果可以看出，当代理对象调用真实对象的方法时(sayHello)，其会自动跳转到代理对象关联的handler对象的invoke方法(InvocationHandlerImpl#invoke)来进行调用。 也就是说，当代码执行到subject.sayHello(&quot;Tom&quot;)时，会自动调用InvocationHandlerImpl的invoke方法。这是怎么实现的呢？ 下面基于JDK(1.8.0_45)来看看源码里面是怎么实现的。 既然生成代理对象是调用Proxy.newProxyInstance，那么我们去到源码里看看它做了什么： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package java.lang.reflect;public class Proxy implements java.io.Serializable &#123; /** parameter types of a proxy class constructor */ private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;; @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; // 检查外面传进来的handler，确保不为null Objects.requireNonNull(h); // 通过调试发现，这里就是需要动态代理的接口：com.demo.proxy.Subject final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ // 获得与指定类装载器和一组接口相关的代理类的对象，通过调试发现它是：com.sun.proxy.$Proxy0 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ // 通过反射获取构造函数对象并生成代理类实例 try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; // 注意构造函数的参数类型是：interface java.lang.reflect.InvocationHandler final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; // 生成代理类对象实例并把外面传进来的InvocationHandlerImpl传给它的构造方法 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; ...&#125; 从上面可以看到，通过调用Class&lt;?&gt; cl = getProxyClass0(loader, intfs)生成了代理的类，再来看看它的实现： 123456789101112131415161718/** * a cache of proxy classes */private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces);&#125; 看来关键的地方在proxyClassCache.get方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package java.lang.reflect;final class WeakCache&lt;K, P, V&gt; &#123; private final ReferenceQueue&lt;K&gt; refQueue = new ReferenceQueue&lt;&gt;(); // the key type is Object for supporting null key private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = new ConcurrentHashMap&lt;&gt;(); private final ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = new ConcurrentHashMap&lt;&gt;(); private final BiFunction&lt;K, P, ?&gt; subKeyFactory; private final BiFunction&lt;K, P, V&gt; valueFactory; public V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); expungeStaleEntries(); Object cacheKey = CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; // putIfAbsent这个方法在key不存在的时候加入一个值,如果key存在就不放入 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; while (true) &#123; if (supplier != null) &#123; // supplier might be a Factory or a CacheValue&lt;V&gt; instance V value = supplier.get(); if (value != null) &#123; return value; &#125; &#125; // else no supplier in cache // or a supplier that returned null (could be a cleared CacheValue // or a Factory that wasn't successful in installing the CacheValue) // 从下面可以看出，supplier实现上是Factory对象 // lazily construct a Factory if (factory == null) &#123; factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // successfully installed Factory supplier = factory; &#125; // else retry with winning supplier &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125; &#125;&#125; 可见这里调用了supplier.get()，而supplier实际上是Factory类，这个类是WeakCache的内部类，并且实现了Supplier接口： 123456789101112package java.util.function;@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package java.lang.reflect;final class WeakCache&lt;K, P, V&gt; &#123; ... private final BiFunction&lt;K, P, V&gt; valueFactory; private final class Factory implements Supplier&lt;V&gt; &#123; private final K key; private final P parameter; private final Object subKey; private final ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap; Factory(K key, P parameter, Object subKey, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123; this.key = key; this.parameter = parameter; this.subKey = subKey; this.valuesMap = valuesMap; &#125; @Override public synchronized V get() &#123; // serialize access // re-check Supplier&lt;V&gt; supplier = valuesMap.get(subKey); if (supplier != this) &#123; // something changed while we were waiting: // might be that we were replaced by a CacheValue // or were removed because of failure -&gt; // return null to signal WeakCache.get() to retry // the loop return null; &#125; // else still us (supplier == this) // create new value V value = null; try &#123; // 关键点 value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // remove us on failure valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; // wrap value with CacheValue (WeakReference) CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value); // try replacing us with CacheValue (this should always succeed) if (valuesMap.replace(subKey, this, cacheValue)) &#123; // put also in reverseMap reverseMap.put(cacheValue, Boolean.TRUE); &#125; else &#123; throw new AssertionError(\"Should not reach here\"); &#125; // successfully replaced us with new CacheValue -&gt; return the value // wrapped by it return value; &#125; &#125;&#125; 从上面代码中可以发现，真实对象其实是通过调用valueFactory.apply(key, parameter)得到的，而BiFunction是一个接口： 1234567891011121314package java.util.function;import java.util.Objects;@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; &#123; R apply(T t, U u); default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t, U u) -&gt; after.apply(apply(t, u)); &#125;&#125; 那么它的实现类是谁呢？通过调试发现它是：Proxy$ProxyClassFactory： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package java.lang.reflect;public class Proxy implements java.io.Serializable &#123; private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // prefix for all proxy class names private static final String proxyClassNamePrefix = \"$Proxy\"; // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; // 这里其实是：interface com.demo.proxy.Subject interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ // 生成指定的代理类 // proxyName: com.sun.proxy.$Proxy0 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125; private static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len);&#125; 终于找到了重点：12byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);Class&lt;?&gt; result defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); 可以看到，这里根据代理类文件的字节数组，调用了一个native的方法生成了我们需要的代理类，那么，到底这个类长什么样的呢？接下来试着把这个字节码数组写到文件中，看看它是什么东西。。。 进一步验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Main &#123; public static void main(String args[]) &#123; Subject realSubject = new RealSubject(); InvocationHandler handler = new InvocationHandlerImpl(realSubject); ClassLoader loader = realSubject.getClass().getClassLoader(); Class[] interfaces = realSubject.getClass().getInterfaces(); Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); System.out.println(\"动态代理对象的类型：\" + subject.getClass().getName()); String result = subject.sayHello(\"Tom\"); System.out.println(result); createProxyClassFile(); &#125; private static void createProxyClassFile() &#123; String name = \"ProxySubject\"; byte[] data = ProxyGenerator.generateProxyClass(name, new Class[]&#123;Subject.class&#125;); File file = new File(name + \".class\"); System.out.println(\"文件路径：\" + file.getPath()); FileOutputStream fos = null; try &#123; fos = new FileOutputStream(file); fos.write(data); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException ignore) &#123; &#125; &#125; &#125; &#125;&#125; 主要就是在前面的例子上加了一个方法：createProxyClassFile()，执行完之后，在当前工程主目录里面生成了一个ProxySubject.class文件。因为我这里直接使用的IntelJ IDEA写的测试，所以这个IDE可以直接反编译字节类文件。（如果不是使用IDEA工具，可以使用jd-jui反编译） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//import com.demo.proxy.Subject;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class ProxySubject extends Proxy implements Subject &#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public ProxySubject(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String sayHello(String var1) throws &#123; try &#123; return (String)super.h.invoke(this, m3, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[]&#123;Class.forName(\"java.lang.Object\")&#125;); m3 = Class.forName(\"com.demo.proxy.Subject\").getMethod(\"sayHello\", new Class[]&#123;Class.forName(\"java.lang.String\")&#125;); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 这就是最终自动生成的真正代理类，它继承自java.lang.reflect.Proxy类，并实现了我们自定义的com.demo.proxy.Subject接口。 也就是说： 1Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler); 这里的subject实际是这个类的一个实例！ 那么接下来看看这个类的sayHello方法的实现： 12345678910public final String sayHello(String var1) throws &#123; try &#123; // super.h就是构造方法传进来的InvocationHandler return (String)super.h.invoke(this, m3, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125;&#125; 可以看出，它调用了InvocationHandler的invoke方法！而这个InvocationHandler正是我们前面创建的InvocationHandlerImpl。 结论到这里，终于解答了： subject.sayHello(&quot;Tom&quot;)为什么会自动调用InvocationHandlerImpl的invoke方法？ 因为JDK生成的最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口，在实现Subject接口方法的内部，通过反射调用了InvocationHandlerImpl的invoke方法。 通过分析代码可以看出Java 动态代理，具体有如下四步骤： 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 扩展阅读 Java 动态代理机制分析及扩展，第 1 部分 Java 动态代理机制分析及扩展，第 2 部分","tags":[{"name":"Proxy","slug":"Proxy","permalink":"http://www.heqingbao.net/tags/Proxy/"}]},{"title":"Integer类型自动装箱的一点疑惑","date":"2017-03-09T05:40:35.000Z","path":"2017/03/09/Integer-Autoboxing-128-127/","text":"先看下面这段代码： 1234567public class Demo &#123; public static void main(String args[]) &#123; Integer a = 1000; Integer b = 1000; System.out.println(a == b); &#125;&#125; 到此你可能会想，对Object（包装）类型的对象应用==操作，比较的是对象的内存地址（是否是同一个对象）。这里是两个Object类型的对象，所以返回false！没错，答对了。 那么再看下面这段代码： 1234567public class Demo &#123; public static void main(String args[]) &#123; Integer a = 100; Integer b = 100; System.out.println(a == b); &#125;&#125; 如果你还认为它也返回false的话，你就需要往下看了。。。因为它实际上会返回true！ 那么为什么会有这样的差异呢？上面两段代码并不复杂，所以不会存在逻辑陷阱，那有什么办法可以明确知道是什么原因呢？ 说到这里，肯定有人会想到去看Integer的源码，没错，我们在Integer的源码中发现了这段代码： 1234567public static Integer valueOf(int i) &#123; final int offset = 128; if (i &gt;= -128 &amp;&amp; i &lt;= 127) &#123; // must cache return IntegerCache.cache[i + offset]; &#125; return new Integer(i);&#125; 从这个方法可以看出，如果参数i在[-128~127]这个范围内的话，直接从IntegerCache里面取，否则就创建一个新的Integer对象。这个IntegerCache从命名上来看，有点像是整数缓存的意思，它是Integer的一个静态内部类： 123456789101112131415161718192021222324252627282930313233private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 由此可以看出，调用valueOf(i)创建Integer话，如果i的范围在[-128~127]里面，则创建的对象是同一个引用。这跟我们上面两段代码的结果有点像。到此，你可能会想，要不试试？ 经过试验，你会发现当Integer a = 127, b = 127的时候：a == b，当超过127的时候：a != b。 经过试验，你可能会暗自高兴，不就是这个原因嘛，源码里面写着呢。。。。 但是，有什么能够证明Integer a = 100就是调用valueOf这个方法实现的呢？ 到此，本文的主角该出场了，也是关键点。 我们可以反编译Java的字节码文件，通过查看编译器编译后的字节命令，我们能够更清楚地了解Java在处理一些代码操作的机制。 我们这里需要用到javap命令，这个命令包含在JDK里面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394➜ /Users/heqingbao/Desktop javap -verbose DemoClassfile /Users/heqingbao/Desktop/Demo.class Last modified 2017-3-9; size 569 bytes MD5 checksum 337e4357e76e91e8e3f525fc9a95adb6 Compiled from \"Demo.java\"public class Demo SourceFile: \"Demo.java\" minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#19 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Methodref #20.#21 // java/lang/Integer.valueOf:(I)Ljava/lang/Integer; #3 = Fieldref #22.#23 // java/lang/System.out:Ljava/io/PrintStream; #4 = Methodref #24.#25 // java/io/PrintStream.println:(Z)V #5 = Class #26 // Demo #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 StackMapTable #14 = Class #28 // \"[Ljava/lang/String;\" #15 = Class #29 // java/lang/Integer #16 = Class #30 // java/io/PrintStream #17 = Utf8 SourceFile #18 = Utf8 Demo.java #19 = NameAndType #7:#8 // \"&lt;init&gt;\":()V #20 = Class #29 // java/lang/Integer #21 = NameAndType #31:#32 // valueOf:(I)Ljava/lang/Integer; #22 = Class #33 // java/lang/System #23 = NameAndType #34:#35 // out:Ljava/io/PrintStream; #24 = Class #30 // java/io/PrintStream #25 = NameAndType #36:#37 // println:(Z)V #26 = Utf8 Demo #27 = Utf8 java/lang/Object #28 = Utf8 [Ljava/lang/String; #29 = Utf8 java/lang/Integer #30 = Utf8 java/io/PrintStream #31 = Utf8 valueOf #32 = Utf8 (I)Ljava/lang/Integer; #33 = Utf8 java/lang/System #34 = Utf8 out #35 = Utf8 Ljava/io/PrintStream; #36 = Utf8 println #37 = Utf8 (Z)V&#123; public Demo(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=3, args_size=1 0: bipush 100 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: bipush 100 8: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 11: astore_2 12: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 15: aload_1 16: aload_2 17: if_acmpne 24 20: iconst_1 21: goto 25 24: iconst_0 25: invokevirtual #4 // Method java/io/PrintStream.println:(Z)V 28: return LineNumberTable: line 4: 0 line 5: 6 line 6: 12 line 7: 28 StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 24 locals = [ class \"[Ljava/lang/String;\", class java/lang/Integer, class java/lang/Integer ] stack = [ class java/io/PrintStream ] frame_type = 255 /* full_frame */ offset_delta = 0 locals = [ class \"[Ljava/lang/String;\", class java/lang/Integer, class java/lang/Integer ] stack = [ class java/io/PrintStream, int ]&#125; 我猜你已经看到了Integer.valueOf了。","tags":[{"name":"Integer","slug":"Integer","permalink":"http://www.heqingbao.net/tags/Integer/"},{"name":"自动装箱","slug":"自动装箱","permalink":"http://www.heqingbao.net/tags/自动装箱/"}]},{"title":"Android应用内国际化","date":"2017-02-26T07:22:24.000Z","path":"2017/02/26/android-change-language-in-app/","text":"最近Android项目需要做国际化，支持多种语言，借此机会学习学习。 我们首先看一下微信的。 微信首页： 123➜ /Users/heqingbao adb shell dumpsys activity com.tencent.mm | grep -e 'TASK' -e \"ACTIVITY\"TASK com.tencent.mm id=1801 ACTIVITY com.tencent.mm/.ui.LauncherUI 25527ac4 pid=5962 进入到多语言设置页面后： 123456➜ /Users/heqingbao adb shell dumpsys activity com.tencent.mm | grep -e 'TASK' -e \"ACTIVITY\"TASK com.tencent.mm id=1801 ACTIVITY com.tencent.mm/.plugin.setting.ui.setting.SettingsLanguageUI 1d07a70 pid=5962 ACTIVITY com.tencent.mm/.plugin.setting.ui.setting.SettingsAboutSystemUI 14ce296 pid=5962 ACTIVITY com.tencent.mm/.plugin.setting.ui.setting.SettingsUI 8f2316c pid=5962 ACTIVITY com.tencent.mm/.ui.LauncherUI 25527ac4 pid=5962 切换语言完成后： 123➜ /Users/heqingbao adb shell dumpsys activity com.tencent.mm | grep -e 'TASK' -e \"ACTIVITY\"TASK com.tencent.mm id=1805 ACTIVITY com.tencent.mm/.ui.LauncherUI 2a9c43ff pid=5962 注意上面打印的结果，切换语言后： 栈里只保留了LauncherUI 切换前后LauncherUI不是同一个对象。由25527ac4变成2a9c43ff。 切换前后Task也不是同一个。由1801变成了1805。 由此，我们至少获取了几点信息： 微信切换语言后，会重建Task。 各页面的名称 首页：com.tencent.mm.LauncherUI 语言设置页：com.tencent.mm.SettingsLanguageUI 接下来反编译微信，看看它是怎么实现的。 具体反编译过程就不仔细说了，最后找到切换语言的关键实现： 由此可见，主要是通过更改Resource.Configuration.locale实现的。 写个Demo验证一下呗~ Demo中切换语言的关键代码是操作Resources对象实现的： 12345678Resources res = MainApplication.getContext().getResources();Configuration config = res.getConfiguration();if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; config.setLocale(locale);&#125; else &#123; config.locale = locale;&#125;res.updateConfiguration(config, res.getDisplayMetrics()); 需要注意的地方： 需要在App的入口处（Application）初始化local。 默认情况下，系统切换语言后，各App已经打开的Activity回到前台之前都会自动重建以刷新的语言，这是系统默认处理的。另外切换语言会发一个系统广播android.intent.action.LOCALE_CHANGED，并且调用Application的onConfigurationChanged方法，可以在这两个位置处理避免应用内的语言一直跟随系统设置。 Demo地址：https://android.googlesource.com/platform/packages/apps/Settings/","tags":[{"name":"国际化","slug":"国际化","permalink":"http://www.heqingbao.net/tags/国际化/"}]},{"title":"Android加载外部SO库","date":"2017-02-26T03:52:20.000Z","path":"2017/02/26/Load-External-SO-Library/","text":"如何加载外部的so文件 注意到我们一般加载so的方式是使用System.loadLibrary(libname)，同时我们发现System类还有一个load方法： 1234567891011121314151617/** * Loads a code file with the specified filename from the local file * system as a dynamic library. The filename * argument must be a complete path name. */public static void load(String filename) &#123; Runtime.getRuntime().load0(VMStack.getStackClass1(), filename);&#125;/** * Loads the system library specified by the &lt;code&gt;libname&lt;/code&gt; * argument. The manner in which a library name is mapped to the * actual system library is system dependent. */public static void loadLibrary(String libname) &#123; Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);&#125; 先看看loadLibrary，这里调用了Runtime的loadLibrary，进去一看又是熟悉的ClassLoader，这也说明so库的使用就是一种动态加载的过程。 12345678910111213141516171819202122synchronized void loadLibrary0(ClassLoader loader, String libname) &#123; if (libname.indexOf((int)File.separatorChar) != -1) &#123; throw new UnsatisfiedLinkError(\"Directory separator should not appear in library name: \" + libname); &#125; String libraryName = libname; if (loader != null) &#123; String filename = loader.findLibrary(libraryName); if (filename == null) &#123; // It's not necessarily true that the ClassLoader used // System.mapLibraryName, but the default setup does, and it's // misleading to say we didn't find \"libMyLibrary.so\" when we // actually searched for \"liblibMyLibrary.so.so\". throw new UnsatisfiedLinkError(loader + \" couldn't find \\\"\" + System.mapLibraryName(libraryName) + \"\\\"\"); &#125; String error = doLoad(filename, loader); if (error != null) &#123; throw new UnsatisfiedLinkError(error); &#125; return; &#125; ... 看样子就像是通过库名找到文件，看看loader.findLibrary的实现： 123protected String findLibrary(String libname) &#123; return null;&#125; ClassLoader是个抽象类，它的大部分工作都在BaseDexClassLoader类中实现： 123public String findLibrary(String name) &#123; throw new RuntimeException(\"Stub!\");&#125; 不对呀，为什么这里直接抛了一个RuntimeException？ 其实在看源码的时候经常看到这样的实现，这里有一个误区，这里我们看的源码只是Android SDK的源码，是给我们开发者参考的，Google不会把整个Android系统的源码放到这里来，整个项目非常大，ClassLoader类平时我们接触的少，所以它的具体实现的源码并没有打包到SDK里，如果想查看的话，我们需要到官方AOSP项目里面去看。如果本地没有下载源码，可以在线看BaseDexClassLoader.java BaseDexClassLoader.java1234@Overridepublic String findLibrary(String name) &#123; return pathList.findLibrary(name);&#125; DexPathList.java12345678910public String findLibrary(String libraryName) &#123; String fileName = System.mapLibraryName(libraryName); for (File directory : nativeLibraryDirectories) &#123; File file = new File(directory, fileName); if (file.exists() &amp;&amp; file.isFile() &amp;&amp; file.canRead()) &#123; return file.getPath(); &#125; &#125; return null;&#125; 根据传进来的libraryName，扫描apk内部的nativeLibrary目录，获取并返回内部so库文件的完整路径filename。再回到Runtime类，获取filename后调用doLoad方法： 再调用doLoad方法加载这个文件： 12345private String doLoad(String name, ClassLoader loader) &#123; synchronized (this) &#123; return nativeLoad(name, loader, librarySearchPath); &#125;&#125; 到这里就彻底清楚了，调用Native方法“nativeLoad”，通过完整的SO库路径filename，把目标SO库加载进来。 由此可以想到，如果使用loadLibrary方法，到最后还是要找到目标so库的完整路径，再把so库加载进来，那我们能不能直接加载一个外部的so呢？（System.load(filename有点像，来看看吧） Runtime.java12345678910111213synchronized void load0(Class fromClass, String filename) &#123; if (!(new File(filename).isAbsolute())) &#123; throw new UnsatisfiedLinkError( \"Expecting an absolute path of the library: \" + filename); &#125; if (filename == null) &#123; throw new NullPointerException(\"filename == null\"); &#125; String error = doLoad(filename, fromClass.getClassLoader()); if (error != null) &#123; throw new UnsatisfiedLinkError(error); &#125;&#125; 这里直接就调用了doLoad方法，所以到此感觉System.load与System.loadLibrary的区别只是是否要查找so的文件路径。那试试呗~ 这里我们尝试从asset里面手动加载一个so，看看是否能成功。 12345678910111213141516171819202122232425262728293031323334private void customLoadLibrary() &#123; String soName = \"test.so\"; File soFile = getFileStreamPath(soName); if (soFile.exists()) &#123; System.load(soFile.getAbsolutePath()); &#125; else &#123; if (copyFromAssets(soName, soFile)) &#123; System.load(soFile.getAbsolutePath()); &#125; else &#123; // 无法拷贝!!! throw new IllegalStateException(); &#125; &#125;&#125;private boolean copyFromAssets(String name, File dest) &#123; int len; byte[] buf = new byte[4096]; InputStream in = null; FileOutputStream out = null; try &#123; in = getAssets().open(name); out = new FileOutputStream(dest); while ((len = in.read(buf)) != -1) &#123; out.write(buf, 0, len); &#125; &#125; catch (IOException e) &#123; return false; &#125; finally &#123; DemoUtils.closeQuietly(in); DemoUtils.closeQuietly(out); &#125; return true;&#125; 这里测试结果一切正常！ 那能不能直接加载SDCard上的so呢，试试吧： 12D/dalvikvm: Trying to load lib /storage/emulated/0/libtest.so 0x422490a8D/dalvikvm: Added shared lib /storage/emulated/0/libtest.so 0x422490a8 你没有看错，加载成功了！","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"jni","slug":"jni","permalink":"http://www.heqingbao.net/tags/jni/"}]},{"title":"Android加载SO库测试","date":"2017-02-25T10:24:24.000Z","path":"2017/02/25/android_load_so_library/","text":"Android应用开发中会经常遇到引用第三方库的情况，特别是一些第三方的SDK，往往会携带一些必须的so静态库文件。正常情况下我们只需要将不同ABI结构下的.so文件分别放置。但很多时候第三方SDK并没有提供全量的ABI编译版本，比如有些SDK只提供了armeabi，有些只提供了armeabi-v7a，还有一些armeabi``armeabi-v7a都提供了，那么遇到这些情况的时候，我们应该怎样放置这些.so呢？（关于什么是ABI等这些问题参考官方文档） 下面来看几个例子： 测试环境： Meizu M355： armeabi-v7a 模拟器：armeabi 测试一 如下图所示，我们分别在工程中的armeabi和armeabi-v7a中都放了相应的.so文件，但是注意名字是不一样的： 下图是我在Meizu M355手机上看到的结果（注意这个目录需要root权限才能查看，如果没有Root的手机，使用模拟器也可以）： 在模拟器上运行的结果： 123root@android:/data/data/com.heqingbao.demo/lib # ll-rwxr-xr-x system system 28076 1979-11-30 00:30 liba.so-rwxr-xr-x system system 28076 1979-11-30 00:30 libb.so 从上图可以看出来，Meizu M355只加载了armeabi-v7a里面的so文件，而模拟器却只加载了armeabi中的so文件。 测试二 下面我们删除工程中的armeabi-v7a，只保留armeabi： 仍然使用Meizu M355查看结果： 在模拟器上运行的结果： 123root@android:/data/data/com.heqingbao.demo/lib # ll-rwxr-xr-x system system 28076 1979-11-30 00:30 liba.so-rwxr-xr-x system system 28076 1979-11-30 00:30 libb.so 可以看出，此时Meizu M355和模拟器都只加载了armeabi中的so文件。 测试三 举个实际点的例子，假设我们的工程中需要依赖mars： 1compile 'com.tencent.mars:mars-wrapper:1.1.3' 待依赖同步完成后， 可以看出，mars自己有对应的so库依赖（注意这个目录在build/intermediates/exploded-aar目录里面），并且mars只提供了armeabi和x86两种。 如果我们的代码工程中只提供了armeabi，在Meizu M355上面运行起来后的结果： 可以看到，mars的相关so文件都被安装到了这部手机上。 如果我们的代码工程既提供了armeabi也提供了armeabi-v7a呢？ 可以看出来，mars所依赖的so文件并没有安装到手机上。自然也就不能使用mars的相关功能。 总结： armeabi-v7a向前兼容ARM v5，所以，对只提供armeabi版本的.so，可以原样复制一份到armeabi-v7a文件夹。 为了保证 apk 体积，只保留 armeabi 和 armeabi-v7a 两个文件夹，并保证这两个文件夹中 .so 数量一致。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"jni","slug":"jni","permalink":"http://www.heqingbao.net/tags/jni/"}]},{"title":"Java四则运算","date":"2016-07-16T14:42:10.000Z","path":"2016/07/16/si-ze-yun-suan/","text":"遇到数字则直接压到数字栈顶 遇到运算符（+-*/）时，若操作符栈为空，则直接放到操作符栈顶，否则，见3 若操作符栈顶元素的优先级比当前运算符的优先级小，则直接压入栈顶，否则执行步骤4 弹出数字栈顶的两个数字并弹出操作符栈顶的运算符进行运算，把运算结果压入数字栈顶，重复2和3直到当前运算符被压入操作符栈顶 遇到左括号(时则直接压入操作符栈顶。 到右括号)时则依次弹出操作符栈顶的运算符运算数字栈的最顶上两个数字，直到弹出的操作符为左括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Demo &#123; public static void main(String[] args) &#123; String str = \"12 + 3 * (2 + 5) - 44 / (12 - 8) + 4 * ( 12 + 2 * (4 + 16) + 3)\"; double result = new Demo().computeWithStack(str); System.out.println(result); &#125; public double computeWithStack(String computeExpr) &#123; StringTokenizer tokenizer = new StringTokenizer(computeExpr, \"+-*/()\", true); Stack&lt;Double&gt; numStack = new Stack&lt;Double&gt;(); Stack&lt;Operator&gt; operatorStack = new Stack&lt;Operator&gt;(); Map&lt;String, Operator&gt; operatorMap = getOperatorMap(); String current; while (tokenizer.hasMoreTokens()) &#123; current = tokenizer.nextToken().trim(); if (current == null || current.length() == 0) &#123; continue; &#125; if (this.isNum(current)) &#123; numStack.push(Double.valueOf(current)); continue; &#125; Operator operator = operatorMap.get(current); if (operator != null) &#123; while (!operatorStack.empty() &amp;&amp; operatorStack.peek().priority() &gt;= operator.priority()) &#123; compute(numStack, operatorStack); &#125; operatorStack.push(operator); &#125; else &#123; if (\"(\".equals(current)) &#123; operatorStack.push(Operator.BRACKETS); &#125; else &#123; while (!operatorStack.peek().equals(Operator.BRACKETS)) &#123; compute(numStack, operatorStack); &#125; operatorStack.pop(); &#125; &#125; &#125; while (!operatorStack.empty()) &#123; compute(numStack, operatorStack); &#125; return numStack.pop(); &#125; private boolean isNum(String str) &#123; String numRegex = \"^\\\\d+(\\\\.\\\\d+)?$\"; return Pattern.matches(numRegex, str); &#125; private Map&lt;String, Operator&gt; getOperatorMap() &#123; Map&lt;String, Operator&gt; map = new HashMap&lt;&gt;(); map.put(\"+\", Operator.PLUS); map.put(\"-\", Operator.MINUS); map.put(\"*\", Operator.MULTIPLY); map.put(\"/\", Operator.DIVIDE); return map; &#125; private void compute(Stack&lt;Double&gt; numStack, Stack&lt;Operator&gt; operStack) &#123; Double num2 = numStack.pop(); Double num1 = numStack.pop(); Double result = operStack.pop().compute(num1, num2); numStack.push(result); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public enum Operator &#123; PLUS &#123; @Override public int priority() &#123; return 1; &#125; @Override public double compute(double num1, double num2) &#123; return num1 + num2; &#125; &#125;, MINUS &#123; @Override public int priority() &#123; return 1; &#125; @Override public double compute(double num1, double num2) &#123; return num1 - num2; &#125; &#125;, MULTIPLY &#123; @Override public int priority() &#123; return 2; &#125; @Override public double compute(double num1, double num2) &#123; return num1 * num2; &#125; &#125;, DIVIDE &#123; @Override public int priority() &#123; return 2; &#125; @Override public double compute(double num1, double num2) &#123; return num1 / num2; &#125; &#125;, BRACKETS &#123; @Override public int priority() &#123; return 0; &#125; @Override public double compute(double num1, double num2) &#123; return 0; &#125; &#125;; public abstract int priority(); public abstract double compute(double num1, double num2);&#125;","tags":[{"name":"Arithmetic","slug":"Arithmetic","permalink":"http://www.heqingbao.net/tags/Arithmetic/"}]},{"title":"Java内存模型与线程","date":"2016-07-10T06:49:49.000Z","path":"2016/07/10/Java-Memory-Mode-Thread/","text":"硬件的效率与一致性在正式讲解Java虚拟机并发相关的知识之前，我们先花费一点时间去了解一下物理计算机中并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。 “让计算机并发执行若干个运算任务”与“更充分地利用计算机处理器的效能”之间的因果关系，看起来顺理成章，实际上它们的关系并没有想象 中的那么简单，其中一个重要的复杂性来源是绝大多数的运算任务都不可能有只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有的运算任务）。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂度，因为它引入了一个新的问题：缓存 一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存（Main Memory）。当多个处理器的运算任务都涉及到同一块主存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，以读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。这里将会多次提到“内存模型”一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。 除了增加高速缓存以外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果一致的，但并不保证程序中各个语句计算的先后顺序与输入代中的顺序一致，因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Recorder）优化。 Java内存模型Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model, JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 主内存与工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则 ，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争的问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。 Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作再和中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作线程中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互的关系如图所示。 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定了以下8种操作来完成，虚拟机实现时必须保证下面的电脑的每一种操作都是原子的、不可再分的（对于double和long型类型的变量来说，load、store、read和write操作在某些平台上允许有例外）。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。 read（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后 的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存变量中。 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步到主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行的。也就是说，read和load之间、store和write之间是可插入其它指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量人主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之间，必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load和assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其它线程锁定住的变量。 对一个变量执行unlock之前，必须先把此变量同步回主内存中（执行store、write操作）。 这8种内存访问操作以及上述规则限定，再加上稍后介绍的对volatile的一些特殊规定，就已经完成确定了Java程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，所以后面将介绍这种定义的一个等效判断原则——先行发生原则，用来确定个访问在并发环境下是否安全。 对volatile型变量的特殊规则关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完事地理解，以至于这么多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。了解volatile变量的语义对后面了解多线程操作的其它特性很有意义，在本节中我们将多花费一些时间去弄清楚volatile的语义到底是什么。 Java内存模型对volatile专门定义了一些特殊的的访问规则，在介绍这些比较拗口的规则定义之前，笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。 当一个变量定义为volatile后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对其他线程来说可以立即得知的。而普通变量不可能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改了一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量的值才会对线程B可见。 关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其它线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因。 123456789101112131415161718192021222324252627public class VolatileTest &#123; public static volatile int race = 0; public static void increase() &#123; race++; &#125; private static final int THREADS_COUNT = 20; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i] = new Thread(new Runnable() &#123; for (int i = 0; i &lt; 10000; i++) &#123; increase(); &#125; &#125;); threads[i].start(); &#125; // 等待所有累加线程都结束 while (Thread.activeCount() &gt; 1) &#123; Thread.yield(); &#125; System.out.println(race); &#125;&#125; 这段代码发起了20个线程，每个线程对race变量进行了10000次自增操作，如果这段代码能够正确并发的我讨厌，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？ 问题就出现在自增运行“race++”之中，我们用javap反编译这段代码： 1234567891011public static void increase(): Code: Stack=2, Locals=0, Args_size=0 0: getstatic #13; // Field race:I 3: iconst_1 4: iadd 5: putstatic #13; //Field race:I 8: return LineNumberTable: line 14: 0 line 15: 8 我们发现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成的（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当getstatic指令把rece的值读取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其它线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 而在像如下情景就很适合使用volatile变量来控制并发，当shutdown()方法被调用时，能保证所有线程中执行的doWork()方法都立即停止下来。 1234567891011volatile boolean shutdownRequested;public void shutdown() &#123; shutdownRequested = true;&#125;public void doWork() &#123; while (!shutdownRequested) &#123; // do stuff &#125;&#125; 使用volatile的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程表现为串行的语义”（Within-Thread As-If-Serial Semantics）。 上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何指令重排序会干扰程序的并发执行： 12345678910111213141516171819Map configOptions；char[] configText;// 此变量必须定义为volatilevolatile boolean initialized = false;// 假设以下代码在线程A中执行// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用igOptions = new HashMap()configText = readConfigFile(fileName);processConfigOptions(configText, configOptions);initalized = true;// 假设以下代码在线程B中执行// 等待initialized为true,代表线程A已经把配置信息初始化完成while (!initialized) &#123; sleep();&#125;// 使用线程A中初始化好的配置信息doSomethingWithConfig(); 上面是一段伪代码，其中描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果定义initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码“initialized=true”被提前执行（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。 解决了volatile的语义问题，再来看看众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的这么多消除和优化，使得我们很难量化地认为volatile变会比synchronized快多少。如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入这么多内存屏障指令来保证处理器不发生乱序执行。不过即使如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。 原子性、可见性与有序性介绍完Java内存模型的相关操作和规则，我们再整体回顾一下这个模型的特征。Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，我们逐个看一下哪些操作实现了这3个特征。 原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定） 如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。 可见性（Visibility）：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个个修改。上文在讨论volatile变量的时候我们已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说voaltile保证了多线程操作时变量的可见性，而普通 变量则不能保证这一点。 除了voaltile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见是由“由一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则 获得的，则final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其它线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看到final字段的值。 有序性（Ordering）：Java内存模型的有序性在前面讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。 Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则 获得的，这条规则 决定了持有同一个锁的两个同步块只能串行地进入。 先行并发原则如果Java内存模型中所有的有序性都仅仅依靠volatile和synchronized来完成，那么有一些操作将变得很麻烦，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是在为Java语言有一个“先行发生原则”（happens-before）的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子解决并发环境下两个操作之间是否存在冲突的所有问题。 现在就来看看“先行并发”原则指的是什么。先行发生原则是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在操作B发生之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。这句话不难理解，但它意味着什么呢？我们可以举个例子来说明一下： 12345678// 以下操作在线程A中执行i = 1;// 以下操作在线程B中执行j = i;// 以下操作在线程C中执行i = 2; 假设线程A中操作“i=1”先行发生于线程B的操作“j=i”，那么可以确定在线程B的操作执行后，变量j的值一定等于1，得出这个结论的依据有以下两个：一是根据先行发生原则，“i=1”的结果可以被观察到； 二是线程C还没“登场”，线程A操作结束之后没有其它线程会修改变量i的值。现在再来考虑线程C，我们依然保持线程A和线程B之间的先行发生关系，而线程C出现在线程A和B的操作之间，但是线程C与线程B没有先行发生关系，那j的值会是多少呢？答案是不确定！1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候线程B就存在读取过期数据的风险，不具备多线程安全性。 下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则中推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。 程序次序规则（Program Order Rule）:在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须要强制的是同一个锁，而“后面”是指时间上的先后顺序。 volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行于发生于它的finalize()方法的开始。 传递性（Transitivity）：如果操作A先行发生操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 Java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些了，笔者演示一下如何使用这些规则去判定操作间是否具备顺序性，对于读写共享变量的操作来说，就是线程是否安全，读者还可以从下面这个例子中感受一下“时间上的先后顺序”与“先行发生”之间有什么不同。 123456789private int value = 0;public void setValue(int value) &#123; this.value = value;&#125;public int getValue() &#123; return value;&#125; 上面是一组再普通不过的getter/setter方法，假设存在线程A和线程B，线程A先（时间上的先后）调用了“setValue()”方法，然后线程B调用了同一个对象的“getValue()”方法，那么线程B收到返回值是什么？ 我们依次分析一下先行发生原则中的各项规则，由于两个方法分别由线程A和线程B调用，不在一个线程中，所以程序依次规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定尽管线程A在操作时间上先于线程B，但是无法确定线程B中“getValue()”方法返回的结果，换句话说，这里面的操作不是线程安全的。 那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：要么把getter/setter方法都定义成synchronized方法，这样就可以套用管程锁定规则；要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系。 通过上面的例子，我们可得出结论：一个操作“时间上的先行发生”不代表这个操作会是“先行发生”，那如果一个操作“先行发生”是否就能推导出这个操作必定是“时间上的先发生”呢？很遗憾，这个推论也不成立，一个典型的例子就是多闪提到的“指令重排序”。 123// 以下操作在同个线程中执行int i = 1;int j = 2; 两条赋值语句在同一个线程中，根据程序次序规则，“int i = 1”的操作先行发生于“int j = 2”，但是“int j = 2”的代码完全有可能被处理器执行，这并不影响先行发生原则 的正确性，因为我们在这条线程之中没有办法感知到这点。 上面两个例子综合起来证明了一个结论：时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。 参考自：《深入理解Java虚拟机 JVM高级特性与最佳实践》第二版 - 周志明","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"}]},{"title":"HashMap与HashSet","date":"2016-05-01T06:25:17.000Z","path":"2016/05/01/HashMap-HashSet/","text":"HashMap和HashSet的区别是Java面试中最常被问到的问题，如果没有涉及到Collections框架和多线程的面试，可以说是不完整的。而Collections框架的问题不涉及到HashMap和HashSet，也可以说是不完整的。HashMap和HashSet都是Collections框架的一部分，它们让我们能够使用对象的集合。Collections框架有自己的接口和实现，主要分为Set接口，List接口和Queue接口。它们有各自的特点，Set的集合里面不允许对象有重复的值，List允许有重复，它对集合中的对象进行索引，Queue的工作原理是FCFS算法（First Come，First Server）。 关于HashMap可以参考HashMap工作原理。这里主要分析HashSet，以及它与HashMap的区别。 什么是HashSetHashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保Set中没有存储相等的对象，如果我们没有重写这两个方法，将会使用这两个方法的默认实现。 public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时会立即返回False，如果添加成功则返回True。 什么是HashMapHashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但Collections框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。 public Object put(Object key, Object value)方法用来将元素添加到Map中。 HashSet和HashMap的区别： HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashCode值 HashSet使用成员对象来计算hashCode值，对于两个对象来说hashCode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 这里从源码的角度来分析下HashSet的内部实现。 Read the fuck source code —— Linus 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; static final long serialVersionUID = -5024744406713321676L; private transient HashMap&lt;E,Object&gt; map; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125; public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125; public int size() &#123; return map.size(); &#125; public boolean isEmpty() &#123; return map.isEmpty(); &#125; public boolean contains(Object o) &#123; return map.containsKey(o); &#125; public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; public void clear() &#123; map.clear(); &#125; public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; &#125; private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // Write out HashMap capacity and load factor s.writeInt(map.capacity()); s.writeFloat(map.loadFactor()); // Write out size s.writeInt(map.size()); // Write out all elements in the proper order. for (E e : map.keySet()) s.writeObject(e); &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // Read in HashMap capacity and load factor and create backing HashMap int capacity = s.readInt(); float loadFactor = s.readFloat(); map = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) : new HashMap&lt;E,Object&gt;(capacity, loadFactor)); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; E e = (E) s.readObject(); map.put(e, PRESENT); &#125; &#125;&#125; 这个是JDK1.7.0_79里面HashSet的完整源码（去除了部分注释），从源码来看有没有很熟悉？ 对，你没有看错，它内部就是通过HashMap实现的！！！ 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 向HashSet里面add元素的时候，直接把元素作为Key，put到HashMap里面，Value直接是一个new Object()。对于HashMap的put(key, vlaue)方法，如果key存在，则返回对应的value。这里根据map.put方法返回是否为空来标记是否add成功。同理remove(Object o)实现也是类似的。","tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://www.heqingbao.net/tags/HashMap/"},{"name":"HashSet","slug":"HashSet","permalink":"http://www.heqingbao.net/tags/HashSet/"}]},{"title":"Android消息处理机制(Handler、Looper、MessageQueue与Message)","date":"2016-04-21T10:18:22.000Z","path":"2016/04/21/Android-Handle-Message/","text":"原文 http://www.cnblogs.com/angeldevil/p/3340644.html作者 AngelDevil 此篇结合Android底层源码分析Android的消息处理机制，涉及到C/C++相关知识，关于Android应用层上的源码分析参考Android Handler源码解析 Android是消息驱动的，实现消息驱动有几个要素： 消息的表示：Message 消息队列：MessageQueue 消息循环，用于循环取出消息进行处理：Looper 消息处理，消息循环从消息队列中取出消息后要对消息进行处理：Handler 平时我们最常使用的就是Message与Hadnler了，如果使用过HandlerThread或者自己实现类似HandlerThread的东西可能还会接触到Looper，而MessageQueue是Looper内部使用的，对于标准的SDK，我们是无法实例化并使用的（构造函数是包可见性）。 我们平时接触到的Looper、Message、Handler都是用Java实现的，Android作为基于Linux的系统，底层用C/C++实现的，而且还有NDK的存在，消息驱动的模型怎么可能只存在于Java层，实际上，在Native层存在与Java层对应的类如Looper、MessageQueue等。 初始化消息队列首先来看一下如果一个线程想实现消息循环应该怎么做，以HandlerThread为例： 12345678910111213141516public class HandlerThread extends Thread &#123; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); // 注释1 synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); // 注释2 mTid = -1; &#125;&#125; 主要是标记注释的两句，首先调用prepare初始化MessageQueue与Looper，然后调用loop进入消息循环。先看一下Looper.prepare()方法： 123456789101112public final class Looper &#123; public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125;&#125; 重载函数，quitAllowed默认为true，从名字可以看出来就是消息循环是否可以退出，默认是可退出的，Main线程（UI线程）初始化消息循环时会调用prepareMainLooper，传进去的是false。使用了ThreadLocal，每个线程可以初始化一个Looper。 再来看一下Looper在初始化时都做了什么： 123456public final class Looper &#123; private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125;&#125; 123456public final class MessageQueue &#123; MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit(); &#125;&#125; 在Looper初始化时，新建了一个MessageQueue的对象保存了在成员mQueue中。MessageQueue的构造函数是包可见的，所以我们是无法直接使用的，在MessageQueue初始化的时候调用了nativeInti，这是一个Native方法： 路径 F:\\WORKING_DIRECTORY\\frameworks\\base\\core\\jni\\android_os_MessageQueue.cpp 这里我使用的QourceInsight查看的源码，也可以在googlesource上在线查看android_os_MessageQueue.cpp 1234567891011static jint android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jint&gt;(nativeMessageQueue);&#125; 在nativeInit中，new了一个Native层的MessageQueue对象，并将其地址保存在了Java层MessageQueue的成员mPtr中，Android中有好多这样的实现，一个类在Java层与Native层都有实现。 再看NativeMessageQueue的实现NativeMessageQueue： 12345678NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 在NativeMessageQueue的构造函数中获得了一个Native层的Looper对象，Native层的Looper也使用了线程本地存储，注意new Looper时传入了参数false： 123456789101112131415161718192021222324252627282930Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123; int wakeFds[2]; int result = pipe(wakeFds); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not create wake pipe. errno=%d\", errno); mWakeReadPipeFd = wakeFds[0]; mWakeWritePipeFd = wakeFds[1]; result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake read pipe non-blocking. errno=%d\", errno); result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake write pipe non-blocking. errno=%d\", errno); // Allocate the epoll instance and register the wake pipe. mEpollFd = epoll_create(EPOLL_SIZE_HINT); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance. errno=%d\", errno); struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union eventItem.events = EPOLLIN; eventItem.data.fd = mWakeReadPipeFd; result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake read pipe to epoll instance. errno=%d\", errno);&#125; Native层的Looper使用了epoll。初始化了一个管道，用mWakeReadPipeFd与mWakeWritePipeFd分别保存了管道的读端与写端，并监听了读端的EPOLLIN事件。注意下初始化列表的值，mAllowNonCallbacks的值为false. mAllowNonCallbacks是做什么的？使用epoll仅为了监听mWakeReadPipeFd的事件？其实Native Looper不仅可监听这一个描述符，Looper还提供了addFd方法： 12int addFd(int fd, int ident, int events, ALooper_callbackFunc callback, void* data);int addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data); fd表示要监听的描述符。ident表示要监听的事件的标识，值必须&gt;=0或者为ALOOPER_POLL_CALLBACK(-2)，event表示要监听的事件，callback是事件发生时的回调函数，mAllowNonCallbacks的作用就在于此，当mAllowNonCallbacks为true时允许callback为NULL，在pollOnce中ident作为结果返回，否则不允许callback为空，当callback不为NULL时，ident的值会被忽略。还是直接看代码方便理解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data) &#123;#if DEBUG_CALLBACKS ALOGD(\"%p ~ addFd - fd=%d, ident=%d, events=0x%x, callback=%p, data=%p\", this, fd, ident, events, callback.get(), data);#endif if (!callback.get()) &#123; if (! mAllowNonCallbacks) &#123; ALOGE(\"Invalid attempt to set NULL callback but not allowed for this looper.\"); return -1; &#125; if (ident &lt; 0) &#123; ALOGE(\"Invalid attempt to set NULL callback with ident &lt; 0.\"); return -1; &#125; &#125; else &#123; ident = ALOOPER_POLL_CALLBACK; &#125; int epollEvents = 0; if (events &amp; ALOOPER_EVENT_INPUT) epollEvents |= EPOLLIN; if (events &amp; ALOOPER_EVENT_OUTPUT) epollEvents |= EPOLLOUT; &#123; // acquire lock AutoMutex _l(mLock); Request request; request.fd = fd; request.ident = ident; request.callback = callback; request.data = data; struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union eventItem.events = epollEvents; eventItem.data.fd = fd; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error adding epoll events for fd %d, errno=%d\", fd, errno); return -1; &#125; mRequests.add(fd, request); &#125; else &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error modifying epoll events for fd %d, errno=%d\", fd, errno); return -1; &#125; mRequests.replaceValueAt(requestIndex, request); &#125; &#125; // release lock return 1;&#125; 如果callback为空会检查mAllowNonCallbacks看是否允许callback为空，如果允许callback为空还会检测ident是否&gt;=0。如果callback不为空会把ident的值赋值为ALOOPER_POLL_CALLBACK，不管传进来的是什么值。 接下来把传进来的参数值封装到一个Request结构体中，并以描述符为键保存到一个KeyedVector mRequests中，然后通过epoll_ctl添加或替换（如果这个描述符之前有调用addFD添加监听）对这个描述符事件的监听。 类图： 发送消息通过Looper.prepare初始化好消息队列后就可以调用Looper.loop进入消息循环了，然后我们就可以向消息队列发送消息，消息循环就会取出消息进行处理，在看消息处理之前，先看一下消息是怎么被添加到消息队列的。 在Java层，Message类表示一个消息对象，要发送消息首先就要先获得一个消息对象，Message类的构造函数是public的，但是不建议直接new Message，Message内部保存了一个缓存的消息池，我们可以用obtain从缓存池获得一个消息，Message使用完后系统会调用recycle回收，如果自己new很多Message，每次使用完后系统放入缓存池，会占用很多内存的，如下所示： 123456789101112131415161718192021222324public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; sPoolSize--; return m; &#125; &#125; return new Message();&#125;public void recycle() &#123; clearForRecycle(); synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; Message内部通过next成员实现了一个链表，这样sPool就了为了一个Messages的缓存链表。 消息对象获取到了怎么发送呢，大家都知道是通过Handler的post、sendMessage等方法，其实这些方法最终都是调用的同一个方法sendMessageAtTime: 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; sendMessageAtTime获取到消息队列然后调用enqueueMessage方法，消息队列mQueue是从与Handler关联的Looper获得的。 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; enqueueMessage将message的target设置为当前的handler，然后调用MessageQueue的enqueueMessage，在调用queue.enqueueMessage之前判断了mAsynchronous，从名字看是异步消息的意思，要明白Asynchronous的作用，需要先了解一个概念Barrier。 Barrier与Asynchronous MessageBarrier是什么意思呢，从名字看是一个拦截器，在这个拦截器后面的消息都暂时无法执行，直到这个拦截器被移除了，MessageQueue有一个函数叫enqueueSyncBarier可以添加一个Barrier。 1234567891011121314151617181920212223242526int enqueueSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don't need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; 在enqueueSyncBarrier中，obtain了一个Message，并设置msg.arg1=token，token仅是一个每次调用enqueueSyncBarrier时自增的int值，目的是每次调用enqueueSyncBarrier时返回唯一的一个token，这个Message同样需要设置执行时间，然后插入到消息队列，特殊的是这个Message没有设置target，即msg.target为null。 进入消息循环后会不停地从MessageQueue中取消息执行，调用的是MessageQueue的next函数，其中有这么一段： 12345678Message msg = mMessages;if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());&#125; 如果队列头部的消息的target为null就表示它是个Barrier，因为只有两种方法往mMessages中添加消息，一种是enqueueMessage，另一种是enqueueBarrier，而enqueueMessage中如果mst.target为null是直接抛异常的，后面会看到。 所谓的异步消息其实就是这样的，我们可以通过enqueueBarrier往消息队列中插入一个Barrier，那么队列中执行时间在这个Barrier以后的同步消息都会被这个Barrier拦截住无法执行，直到我们调用removeBarrier移除了这个Barrier，而异步消息则没有影响，消息默认就是同步消息，除非我们调用了Message的setAsynchronous，这个方法是隐藏的。只有在初始化Handler时通过参数指定往这个Handler发送的消息都是异步的，这样在Handler的enqueueMessage中就会调用Message的setAsynchronous设置消息是异步的，从上面Handler.enqueueMessage的代码中可以看到。 所谓异步消息，其实只有一个作用，就是在设置Barrier时仍可以不受Barrier的影响被正常处理，如果没有设置Barrier，异步消息就与同步消息没有区别，可以通过removeSyncBarrier移除Barrier： 12345678910111213141516171819202122232425262728 void removeSyncBarrier(int token) &#123; // Remove a sync barrier token from the queue. // If the queue is no longer stalled by a barrier then wake it. final boolean needWake; synchronized (this) &#123; Message prev = null; Message p = mMessages; while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123; prev = p; p = p.next; &#125; if (p == null) &#123; throw new IllegalStateException(\"The specified message queue synchronization \" + \" barrier token has not been posted or has already been removed.\"); &#125; if (prev != null) &#123; prev.next = p.next; needWake = false; &#125; else &#123; mMessages = p.next; needWake = mMessages == null || mMessages.target != null; &#125; p.recycle(); &#125; if (needWake) &#123; nativeWake(mPtr); &#125;&#125; 参数token就是enqueueSyncBarrier的返回值，如果没有调用指定的token不存在是会抛异常的。 enqueueMessage 接下来看一下是怎么MessageQueue的enqueueMessage。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 final boolean enqueueMessage(Message msg, long when) &#123; if (msg.isInUse()) &#123; throw new AndroidRuntimeException(msg + \" This message is already in use.\"); &#125; if (msg.target == null) &#123; throw new AndroidRuntimeException(\"Message must have a target.\"); &#125; boolean needWake; synchronized (this) &#123; if (mQuiting) &#123; RuntimeException e = new RuntimeException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(\"MessageQueue\", e.getMessage(), e); return false; &#125; msg.when = when; Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; return true;&#125; 注意上面代码红色的部分，当msg.target为null时是直接抛异常的。 在enqueueMessage中首先判断，如果当前的消息队列为空，或者新添加的消息的执行时间when是0，或者新添加的消息的执行时间比消息队列头的消息的执行时间还早，就把消息添加到消息队列头（消息队列按时间排序），否则就要找到合适的位置将当前消息添加到消息队列。 Native发送消息消息模型不只是Java层用的，Native层也可以用，前面也看到了消息队列初始化时也同时初始化了Native层的Looper与NativeMessageQueue，所以Native层应该也是可以发送消息的。与Java层不同的是，Native层是通过Looper发消息的，同样所有的发送方法最终是调用sendMessageAtTime： 123456789101112131415161718192021222324252627282930313233void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123;#if DEBUG_CALLBACKS ALOGD(\"%p ~ sendMessageAtTime - uptime=%lld, handler=%p, what=%d\", this, uptime, handler.get(), message.what);#endif size_t i = 0; &#123; // acquire lock AutoMutex _l(mLock); size_t messageCount = mMessageEnvelopes.size(); while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123; i += 1; &#125; MessageEnvelope messageEnvelope(uptime, handler, message); mMessageEnvelopes.insertAt(messageEnvelope, i, 1); // Optimization: If the Looper is currently sending a message, then we can skip // the call to wake() because the next thing the Looper will do after processing // messages is to decide when the next wakeup time should be. In fact, it does // not even matter whether this code is running on the Looper thread. if (mSendingMessage) &#123; return; &#125; &#125; // release lock // Wake the poll loop only when we enqueue a new message at the head. if (i == 0) &#123; wake(); &#125;&#125; Native Message只有一个int型的what字段用来区分不同的消息，sendMessageAtTime指定了Message，Message要执行的时间when，与处理这个消息的Handler：MessageHandler，然后用MessageEnvelope封装了time, MessageHandler与Message，Native层发的消息都保存到了mMessageEnvelopes中，mMessageEnvelopes是一个Vector。Native层消息同样是按时间排序，与Java层的消息分别保存在两个队列里。 消息循环消息队列初始化好了，也知道怎么发消息了，下面就是怎么处理消息了，看Handler.loop函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycle(); &#125;&#125; loop每次从MessageQueue取出一个Message，调用msg.target.dispatchMessage(msg)，target就是发送message时跟message关联的handler，这样就调用到了熟悉的dispatchMessage，Message被处理后会被recycle。当queue.next返回null时会退出消息循环，接下来就看一下MessageQueue.next是怎么取出消息的，又会在什么时候返回null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495final Message next() &#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(mPtr, nextPollTimeoutMillis); synchronized (this) &#123; if (mQuiting) &#123; return null; &#125; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; MessageQueue.next首先会调用nativePollOnce，然后如果mQuiting为true就返回null，Looper就会退出消息循环。 接下来取消息队列头部的消息，如果头部消息是Barrier（target==null）就往后遍历找到第一个异步消息，接下来检测获取到的消息（消息队列头部的消息或者第一个异步消息），如果为null表示没有消息要执行，设置nextPollTimeoutMillis = -1；否则检测这个消息要执行的时间，如果到执行时间了就将这个消息markInUse并从消息队列移除，然后从next返回到loop；否则设置nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE)，即距离最近要执行的消息还需要多久，无论是当前消息队列没有消息可以执行（设置了Barrier并且没有异步消息或消息队列为空）还是队列头部的消息未到执行时间，都会执行后面的代码，看有没有设置IdleHandler，如果有就运行IdleHandler，当IdleHandler被执行之后会设置nextPollTimeoutMillis ＝ 0。 首先看一下nativePollOnce，native方法，调用JNI，最后调到了Native Looper::pollOnce，并从Java层传进去了nextPollTimeMillis，即Java层的消息队列中执行时间最近的消息还要多久到执行时间。 1234567891011121314151617181920212223242526272829303132333435int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; while (mResponseIndex &lt; mResponses.size()) &#123; const Response&amp; response = mResponses.itemAt(mResponseIndex++); int ident = response.request.ident; if (ident &gt;= 0) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \" \"fd=%d, events=0x%x, data=%p\", this, ident, fd, events, data);#endif if (outFd != NULL) *outFd = fd; if (outEvents != NULL) *outEvents = events; if (outData != NULL) *outData = data; return ident; &#125; &#125; if (result != 0) &#123;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);#endif if (outFd != NULL) *outFd = 0; if (outEvents != NULL) *outEvents = 0; if (outData != NULL) *outData = NULL; return result; &#125; result = pollInner(timeoutMillis); &#125;&#125; 先不看开始的一大串代码，先看一下pollInner： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140int Looper::pollInner(int timeoutMillis) &#123;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - waiting: timeoutMillis=%d\", this, timeoutMillis);#endif // Adjust the timeout based on when the next message is due. if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime); if (messageTimeoutMillis &gt;= 0 &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) &#123; timeoutMillis = messageTimeoutMillis; &#125;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - next message in %lldns, adjusted timeout: timeoutMillis=%d\", this, mNextMessageUptime - now, timeoutMillis);#endif &#125; // Poll. int result = ALOOPER_POLL_WAKE; mResponses.clear(); mResponseIndex = 0; struct epoll_event eventItems[EPOLL_MAX_EVENTS]; int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); // Acquire lock. mLock.lock(); // Check for poll error. if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; ALOGW(\"Poll failed with an unexpected error, errno=%d\", errno); result = ALOOPER_POLL_ERROR; goto Done; &#125; // Check for poll timeout. if (eventCount == 0) &#123;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - timeout\", this);#endif result = ALOOPER_POLL_TIMEOUT; goto Done; &#125; // Handle all events.#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - handling events from %d fds\", this, eventCount);#endif for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents); &#125; &#125; else &#123; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP; pushResponse(events, mRequests.valueAt(requestIndex)); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on fd %d that is \" \"no longer registered.\", epollEvents, fd); &#125; &#125; &#125;Done: ; // Invoke pending message callbacks. mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; // Remove the envelope from the list. // We keep a strong reference to the handler until the call to handleMessage // finishes. Then we drop it so that the handler can be deleted *before* // we reacquire our lock. &#123; // obtain handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock();#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS ALOGD(\"%p ~ pollOnce - sending message: handler=%p, what=%d\", this, handler.get(), message.what);#endif handler-&gt;handleMessage(message); &#125; // release handler mLock.lock(); mSendingMessage = false; result = ALOOPER_POLL_CALLBACK; &#125; else &#123; // The last message left at the head of the queue determines the next wakeup time. mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; // Release lock. mLock.unlock(); // Invoke all response callbacks. for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == ALOOPER_POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data;#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS ALOGD(\"%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p\", this, response.request.callback.get(), fd, events, data);#endif int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd); &#125; // Clear the callback reference in the response structure promptly because we // will not clear the response vector itself until the next poll. response.request.callback.clear(); result = ALOOPER_POLL_CALLBACK; &#125; &#125; return result;&#125; Java层的消息都保存在了Java层MessageQueue的成员mMessages中，Native层的消息都保存在了Native Looper的mMessageEnvelopes中，这就可以说有两个消息队列，而且都是按时间排列的。timeOutMillis表示Java层下个要执行的消息还要多久执行，mNextMessageUpdate表示Native层下个要执行的消息还要多久执行，如果timeOutMillis为0，epoll_wait不设置TimeOut直接返回；如果为-1说明Java层无消息直接用Native的time out；否则pollInner取这两个中的最小值作为timeOut调用epoll_wait。当epoll_wait返回时就可能有以下几种情况： 出错返回。 Time Out 正常返回，描述符上有事件产生。 如果是前两种情况直接goto DONE。 否则就说明FD上有事件发生了，如果是mWakeReadPipeFd的EPOLLIN事件就调用awoken，如果不是mWakeReadPipeFd，那就是通过addFD添加的fd，在addFD中将要监听的fd及其events，callback,data封装成了Request对象，并以fd为键保存到了KeyedVector mRequests中，所以在这里就以fd为键获得在addFD时关联的Request，并连同events通过pushResonse加入mResonse队列（Vector），Resonse仅是对events与Request的封装。如果是epoll_wait出错或timeout，就没有描述符上有事件，就不用执行这一段代码，所以直接goto DONE了。 123456void Looper::pushResponse(int events, const Request&amp; request) &#123; Response response; response.events = events; response.request = request; mResponses.push(response);&#125; 接下来进入DONE部分，从mMessageEnvelopes取出头部的Native消息，如果到达了执行时间就调用它内部保存的MessageeHandler的handleMessage处理并从Native 消息队列移除，设置result为ALOOPER_POLL_CALLBACK，否则计算mNextMessageUptime表示Native消息队列下一次消息要执行的时间。如果未到头部消息的执行时间有可能是Java层消息队列消息的执行时间小于Native层消息队列头部消息的执行时间，到达了Java层消息的执行时间epoll_wait TimeOut返回了，或都通过addFd添加的描述符上有事件发生导致epoll_wait返回，或者epoll_wait是出错返回。Native消息是没有Barrier与Asynchronous的。 最后，遍历mResponses（前面刚通过pushResponse存进去的），如果response.request.ident == ALOOPER_POLL_CALLBACK，就调用注册的callback的handleEvent(fd, events, data)进行处理，然后从mResonses队列中移除，这次遍历完之后，mResponses中保留来来的就都是ident&gt;=0并且callback为NULL的了。在NativeMessageQueue初始化Looper时传入了mAllowNonCallbacks为false，所以这次处理完后mResponses一定为空。 接下来返回到pollOnce。pollOnce是一个for循环，pollInner中处理了所有response.request.ident==ALOOPER_POLL_CALLBACK的Response，在第二次进入for循环后如果mResponses不为空就可以找到ident&gt;0的Response，将其ident作为返回值返回由调用pollOnce的函数自己处理，在这里我们是在NativeMessageQueue中调用的Loope的pollOnce，没对返回值进行处理，而且mAllowNonCallbacks为false也就不可能进入这个循环。pollInner返回值不可能是0，或者说只可能是负数，所以pollOnce中的for循环只会执行两次，在第二次就返回了。 Native Looper可以单独使用，也有一个prepare函数，这时mAllowNonCallbakcs值可能为true，pollOnce中对mResponses的处理就有意义了。 wake与awoken在Native Looper的构造函数中，通过pipe打开了一个管道，并用mWakeReadPipeFd与mWakeWritePipeFd分别保存了管道的读端与写端，然后用epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd,&amp; eventItem)监听了读端的EPOLLIN事件，在pollInner中通过epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis)读取事件，那是在什么时候往mWakeWritePipeFd写，又是在什么时候读的mWakeReadPipeFd呢？ 在Looper.cpp中我们可以发现如下两个函数： 12345678910111213141516171819202122232425262728void Looper::wake() &#123;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ wake\", this);#endif ssize_t nWrite; do &#123; nWrite = write(mWakeWritePipeFd, \"W\", 1); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); if (nWrite != 1) &#123; if (errno != EAGAIN) &#123; ALOGW(\"Could not write wake signal, errno=%d\", errno); &#125; &#125;&#125;void Looper::awoken() &#123;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ awoken\", this);#endif char buffer[16]; ssize_t nRead; do &#123; nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer)); &#125; while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer));&#125; wake函数向mWakeWritePipeFd写入了一个“W”字符，awoken从mWakeReadPipeFd读，往mWakeWritePipeFd写数据只是为了在pollInner中的epoll_wait可以监听到事件返回。在pollInner也可以看到如果是mWakeReadPipeFd的EPOLLIN事件只是调用了awoken消耗掉了写入的字符就往后处理了。 那什么时候调用wake呢？这个只要找到调用的地方分析一下就行了，先看Looper.cpp，在sendMessageAtTime即发送Native Message的时候，根据发送的Message的执行时间查找mMessageEnvelopes计算应该插入的位置，如果是在头部插入，就调用wake唤醒epoll_wait，因为在进入pollInner时根据Java层消息队列头部消息的执行时间与Native层消息队列头部消息的执行时间计算出了一个timeout，如果这个新消息是在头部插入，说明执行时间至少在上述两个消息中的一个之前，所以应该唤醒epoll_wait，epoll_wait返回后，检查Native消息队列，看头部消息即刚插入的消息是否到执行时间了，到了就执行，否则就可能需要设置新的timeout。同样在Java层的MessageQueue中，有一个函数nativeWake也同样可以通过JNI调用wake，调用nativeWake的时机与在Native调用wake的时机类似，在消息队列头部插入消息，还有一种情况就是，消息队列头部是一个Barrier，而且插入的消息是第一个异步消息。 123456789101112131415161718192021222324if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked;&#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();//如果头部是Barrier并且新消息是异步消息则“有可能”需要唤醒 Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; // 消息队列中有异步消息并且执行时间在新消息之前，所以不需要唤醒。 needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg;&#125; 在头部插入消息不一定调用nativeWake，因为之前可能正在执行IdleHandler，如果执行了IdleHandler，就在IdleHandler执行后把nextPollTimeoutMillis设置为0，下次进入for循环就用0调用nativePollOnce，不需要wake，只有在没有消息可以执行（消息队列为空或没到执行时间）并且没有设置IdleHandler时mBlocked才会为true。 如果Java层的消息队列被Barrier Block住了并且当前插入的是一个异步消息有可能需要唤醒Looper，因为异步消息可以在Barrier下执行，但是这个异步消息一定要是执行时间最早的异步消息。 退出Looper也需要wake，removeSyncBarrier时也可能需要。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"Message","slug":"Message","permalink":"http://www.heqingbao.net/tags/Message/"}]},{"title":"Android Handler源码分析","date":"2016-04-20T12:55:14.000Z","path":"2016/04/20/Android-Handler/","text":"Handler在Android开发中，Handler被经常用来更新UI，先通过一个例子看一下Handler的用法： 12345678910111213141516171819202122232425262728293031public class MainActivity extends Activity &#123; private TextView mTextView; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; mTextView.setText(\"UI成功更新\"); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView) findViewById(R.id.text_view); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; mHandler.sendEmptyMessage(1); &#125; &#125;).start(); &#125;&#125; 上面的代码先创建了一个Handler实例，并且重写了handleMessage方法，在这个方法里，便是根据接受到的消息类型进行相应的UI更新。那么看一下Handler的构造方法的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Handler &#123; /** * Default constructor associates this handler with the &#123;@link Looper&#125; for the * current thread. * * If this thread does not have a looper, this handler won't be able to receive messages * so an exception is thrown. */ public Handler() &#123; this(null, false); &#125; /** * Use the &#123;@link Looper&#125; for the current thread with the specified callback interface * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */ public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125;&#125; 在构造方法中，通过调用Looper.myLooper()获得了Looper对象。如果mLooper为空，那么会抛异常Can&#39;t create handler inside thread that has not called Looper.prepare()，意思是：不能在未调用Looper.prepare()的线程创建Handler。上面的例子并没有调用这个方法，但是却没有抛出异常。其实是因为主线程在启动的时候已经帮我们调用过了(在ActivityThread里面)，所以可以直接创建Handler。如果是在其它子线程，直接创建Handler是会抛异常的。 在得到Handler之后，又获取了它的内部变量mQueue，这是MessageQueue对象，也就是消息队列，用于保存Handler发送的消息。 到此，Android的消息机制的三个重要角色全部出现了，分别是Handler，Looper和MessageQueue。一般在代码中我们接触比较多的是Handler，但Looper和MessageQueue却是Handler运行时不可或缺的。 Looper前面分析了Handler的构造方法，其中调用了Looper.myLooper()方法，下面是它的源码： 12345678910111213public final class Looper &#123; // sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static Looper myLooper() &#123; return sThreadLocal.get(); &#125;&#125; 这个方法代码很简单，就是从sThreadLocal中获取Looper对象，sThreadLocal是ThreadLocal对象，这说明Looper是线程独立的。 在Handler的构造方法中，从抛出的异常可知，每个线程想要获得Looper需要调用prepare()方法。那这个prepare()是在哪里调用的呢？答案在ActivityThread里面： 1234567891011121314151617181920212223242526272829303132/** * This manages the execution of the main thread in an * application process, scheduling and executing activities, * broadcasts, and other operations on it as the activity * manager requests. * * &#123;@hide&#125; */public final class ActivityThread &#123; public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ... Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125;&#125; 看到main方法有没有种很熟悉的感觉？这里是我们的main线程，也是App的入口 。从源码可知，在main方法里面调用了Looper.prepareMainLooper()，再来看看Looper： 123456789101112131415161718192021222324252627/** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 从上面可以看出，sThreadLocal设置了一个全新的Looper，不过需要注意的是如果sThreadLocal已经设置过了，那么会抛出异常，也就是说一个线程只会有一个Looper。创建Looper的时候，内部会创建一个消息列队。 现在的问题是，Looper看上去很重要的样子，它到底是干嘛的？这里不防先告诉答案：Looper开启消息循环，不断从消息队列MessageQueue取出消息交由Handler处理。 为什么这样说呢，看一下Looper的loop方法： 1234567891011121314151617181920212223242526272829/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; ... for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... msg.target.dispatchMessage(msg); ... msg.recycleUnchecked(); &#125;&#125; 可以看出，在这个方法内部有个死循环，里面通过MessageQueue的next()方法获取下一条消息，没有获取到会阻塞。如果成功获取，便调用msg.target.dispatchMessage(msg)，msg.target是Handler对象(下面会讲到)，dispatchMessage则是分发消息（此时已经运行在UI线程），下面分析消息的发送及处理流程。 MessageQueue这部分在下篇文章里面分析，暂时略过，不影响后面的理解。 消息发送与处理在调用Handler程发送消息时，是调用一系列的sendMessage方法，最终会辗转调用sendMessageAtTime(Message msg, long uptimeMillis)，代码如下： 123456789101112131415161718192021public class Handler &#123; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125;&#125; 这个方法就是调用enqueueMessage在消息队列中插入一条消息，在enqueueMessage中，会把msg.target设置为当前的Handler对象。 消息插入到队列后，Looper负责从队列中取出，然后调用Handler的dispatchMessage方法。接下来看看这个方法怎么处理消息的： 12345678910111213141516171819202122232425public class Handler &#123; public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; private static void handleCallback(Message message) &#123; message.callback.run(); &#125; /** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) &#123; &#125;&#125; 首先，如果消息的callback不是空，便调用handleCallback处理。否则判断Handler的mCallback是否为空，不为空则调用它的handleMessage方法。如果仍然为空（或者Handler的mCallback返回false），才调用Handler的handleMessage，也就是我们创建Handler时重写的那个方法。 如果发送消息时调用Handler的post(Runnable r)方法，会把Runnable封装到消息对象的callback，然后调用sendMessageDelayed，相关代码如下 ： 1234567891011public class Handler &#123; public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125;&#125; 此时在dispatchMessage中便会调用handleCallback进行处理。可以发现它是直接调用run方法处理消息。 如果在创建Handler时，直接提供一个Callback对象，消息就交给这个对象的handleMessage方法处理。Callback是Handler内部的一个接口： 12345public class Handler &#123; public interface Callback &#123; public boolean handleMessage(Message msg); &#125;&#125; 以上便是消息发送与处理的流程，发送时是在子线程，但处理时dispatchMessage方法运行在主线程。 终上，我们发现在App启动的时候，在主线程（UI线程）中创建了Looper，然后我们在UI线程中创建一个Handler（new Handler()/new Handler(Looper.getMainLooper()))，这样在子线程中不用做任何处理，即可使用handler发送消息。那么我们可以在子线程中创建Handler吗？前面已经提到过，这里仔细分析一下为什么不行。 在前面所贴的源码中，有一段 1234567891011121314151617181920212223public class Handler &#123; public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static Looper myLooper() &#123; return sThreadLocal.get(); &#125;&#125; 从源码来看，如果直接在子线程中new Handler()会抛RuntimeException。因为从myLooper()方法的注释也可以看出来，这里的myLooper()方法返回的是与当前线程相关联的Looper（还记得ThreadLocal的作用吧？），很显然，我们并没有给sThreadLocal设置Looper。 那么难道在子线程中就不能使用Handler/Looper机制吗？当然不是，从上面的异常信息也可以看出，需要先调用Looper.prepare()。其实从另一个角度去想也很好理解，主线程也是一个线程（看上去比较特殊而已），子线程也是一个线程，常规来说主线程能实现的，子线程应该也能实现。从前面的源码分析可以知道，ActivityThread在main方法里面调用了Looper.prepare()，而Looper.prepare()方法里面会给sThreadLocal设置一个Looper，然后再调用Looper.loop()开启消息循环。 所以，如果我们要在子线程中创建Handler处理消息的话，一样需要先调用Looper.prepare()方法，再new Handler()就不会有问题了，当然最后不要忘了调用Looper.loop()开启消息循环。并且注意在子线程中事情处理完成后调用quit()退出消息循环。 总结至此，Android的消息处理机制的原理就分析结束了，现在可以知道，消息处理是通过Handler、Looper以及MessageQueue共同完成。Handler负责发送以及处理消息，Looper创建消息队列并不断从队列中取出消息交给Handler，MessageQueue则用于保存消息。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"http://www.heqingbao.net/tags/Handler/"}]},{"title":"Effective Java笔记","date":"2016-04-13T13:05:50.000Z","path":"2016/04/13/Effective-Java-Notes/","text":"第二章 创建和销毁对象第1条：考虑用静态工厂方法代替构造器 第2条：遇到多个构造器参数时要考虑用构建器 第3条：用私有构造器或枚举类型强化Singleton属性 第4条：通过私有构造器强化不可实例化的能力 第5条：避免创建不必要的对象 第6条：消除过期的对象引用 第7条：避免使用终结方法 第三章 对于所有对象都通用的方法第8条：覆盖equals时请遵守通用约定 第9条：覆盖equals时总要覆盖hashCode 第10条：始终要覆盖toString 第11条：谨慎地覆盖clone 第12条：考虑实现Comparable接口 第四章 类和接口第13条：使类和成员的可访问性最小化 第14条：在公有类中使用访问方法而非公有域 第15条：使可变性最小化 第16条：复合优先于继承 第17条：要么为继承而设计，并提供文档说明，要么就禁止继承 第18条：接口优于抽象类 第19条：接口只用于定义类型 第20条：类层次优于标签类 第21条：用函数对象表示策略 第22条：优先考虑静态成员类 第五章 泛型第23条：请不要在新代码中使用原生态类型 第24条：消除非受检警告 第25条：列表优先于数组 第26条：优先考虑泛型 第27条：优先考虑泛型方法 第28条：利用有限制通配符来提升API的灵活性 第29条：优先考虑类型安全的异构容器 第六章 枚举和注解第30条：用enum代替int常量 第31条：用实例域代替序数 第32条：用EnumSet代替位域 第33条：用EnumMap代替序数索引 第34条：用接口模拟可伸缩的枚举 第35条：注解优先于命名模式 第36条：坚持使用Override注解 第37条：用标记接口定义类型 第七章 方法第38条：检查参数的有效性 第39条：必要时进行保护性拷贝 第40条：谨慎设计方法签名 第41条：慎用重载 第42条：慎用可变参数 第43条：返回零长度的数组或者集合，而不是null 第44条：为所有导出的API元素编写文档注释 第八章 通用程序设计第45条：将局部变量的作用域最小化 第46条：for-each循环优先于传统的for循环 第47条：了解和使用类库 第48条：如果需要精确的答案，请避免使用float和double 第49条：基本类型优先于装箱基本类型 第50条：如果其他类型更适合，则尽量避免使用字符串 第51条：当心字符串连接的性能 第52条：通过接口引用对象 第53条：接口优先于反射机制 第54条：谨慎地使用本地方法 第55条：谨慎地进行优化 第56条：遵守普遍的命名惯例 第九章 异常第57条：只针对异常的情况才使用异常 第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常 第59条：避免不必要地使用受检的异常 第60条：优先使用标准的异常 第61条：抛出与抽象相对应的异常 第62条：每个方法抛出的异常都要有文档 第63条：在细节消息中包含能捕获失败的信息 第64条：努力使失败保持原子性 第65条：不要忽略异常 第十章 并发第66条：同步访问共享的可变数据 第67条：避免过度同步 第68条：executor和task优先于线程 第69条：并发工具优先于await和notify 第70条：线程安全性的文档化 第71条：慎用延迟初始化 第72条：不要依赖于线程调度器 第73条：避免使用线程组 第十一章 序列化第74条：谨慎地实现Serializable接口 第75条：考虑使用自定义的序列化形式 第76条：保护性地编写readObject方法 第77条：对于实例控制，枚举类型优先于readResolve 第78条：考虑用序列化代理代替序列化实例","tags":[{"name":"java","slug":"java","permalink":"http://www.heqingbao.net/tags/java/"}]},{"title":"理解targetSdkVersion","date":"2016-04-02T05:05:00.000Z","path":"2016/04/02/Android-targetSdkVersion/","text":"上一篇文章介绍了compileSdkVersion、minSdkVersion和targetSdkVersion的含义，以及合理设置各个值的意义。其中compileSdkVersion和minSdkVersion都非常好理解，前者表示编译的SDK版本，后者表示应用兼容的最低SDK版本。但是对于targetSdkVersion其实很难一句话解释清楚，本文试图彻底解决这个问题。 随着Android系统的升级，某个系统的API或者模块的行为可能会发生变化，但是为了保证老APK的行为还是和以前兼容，只要APK的targetSdkVersion不变，即使这个APK安装在新Android系统上，其行为还是保持老的系统上的行为，这样就保证了对老应用的向前兼容性。 这里还是用原文的例子，在Android 4.4 (API 19)以后，AlarmManager的set()和setRepeat()这两个API的行为发生了变化。在Android 4.4以前，这两个API设置的都是精确的时间，系统能保证在API设置的时间点上唤醒Alarm。因为省电原因Android 4.4系统实现了AlarmManager的对齐唤醒，这两个API设置唤醒的时间，系统都对待成不精确的时间，系统只能保证在你设置的时间点之后某个时间唤醒。 这时，虽然API没有任何变化，但是实际上API的行为却发生了变化，如果老的APK中使用了此API，并且在应用中的行为非常依赖AlarmManager在精确的时间唤醒，例如闹钟应用。如果Android系统不能保证兼容，老的APK安装在新的系统上，就会出现问题。 1public void set (int type, long triggerAtMillis, PendingIntent operation) Note: Beginning in API 19, the trigger time passed to this method is treated as inexact: the alarm will not be delivered before this time, but may be deferred and delivered some time later. The OS will use this policy in order to “batch” alarms together across the entire system, minimizing the number of times the device needs to “wake up” and minimizing battery use. In general, alarms scheduled in the near future will not be deferred as long as alarms scheduled far in the future. With the new batching policy, delivery ordering guarantees are not as strong as they were previously. If the application sets multiple alarms, it is possible that these alarms’ actual delivery ordering may not match the order of their requested delivery times. If your application has strong ordering requirements there are other APIs that you can use to get the necessary behavior; see setWindow(int, long, long, PendingIntent) and setExact(int, long, PendingIntent). Applications whose targetSdkVersion is before API 19 will continue to get the previous alarm behavior: all of their scheduled alarms will be treated as exact. Android系统是怎么保证这种兼容性的呢？这时候targetSdkVersion就起作用了。APK在调用系统AlarmManager的set()或setRepeat()的时候，系统首先会检查调用的APK的targetSdkVersion信息，如果小于19，就还是按照老的行为，即精确设置唤醒时间，否则执行新的行为。 我们来看一下Android 4.4上AlarmManager的一部分源码： 12345678private final boolean mAlwaysExact;AlarmManager(IAlarmManager service, Context ctx) &#123; mService = service; final int sdkVersion = ctx.getApplicationInfo().targetSdkVersion; mAlwaysExact = (sdkVersion &lt; Build.VERSION_CODES.KITKAT);&#125; 看到这里，首选获取应用的 targetSdkVersion，判断是否是小于 Build.VERSION_CODES.KITKAT (即 API Level 19)，来设置 mAlwaysExact 变量，表示是否使用精确时间模式。 1234567private long legacyExactLength() &#123; return (mAlwaysExact ? WINDOW_EXACT : WINDOW_HEURISTIC);&#125;public void set(int type, long triggerAtMillis, PendingIntent operation) &#123; setImpl(type, triggerAtMillis, legacyExactLength(), 0, operation, null, null);&#125; 这里看到，直接影响到 set() 方法给 setImpl() 传入不同的参数，从而影响到了 set() 的执行行为。具体的实现在 AlarmManagerService.java，这里就不往下深究了。 看到这里，发现其实 Android 的 targetSdkVersion 并没有什么特别的，系统使用它也非常直接，甚至很“粗糙”。仅仅是用过下面的 API 来获取 targetSdkVersion，来判断是否执行哪种行为： 1getApplicationInfo().targetSdkVersion 所以，我们可以猜测到，如果 Android 系统升级，发生这种兼容行为的变化时，一般都会在原来的保存新旧两种逻辑，并通过 if-else 方法来判断执行哪种逻辑。果然，在源码中搜索，我们会发现不少类似 getApplicationInfo().targetSdkVersion &lt; Buid.XXXX 这样的代码，相对于浩瀚的 Android 源码量来说，这些还是相对较少了。其实原则上，这种会导致兼容性问题的修改还是越少越好，所以每次发布新的 Android 版本的时候，Android 开发者网站都会列出做了哪些改变，在这里，开发者需要特别注意。 最后，我们也可以理解原文中说的那句话的含义，明白了为什么修改了 APK 的 targetSdkVersion 行为会发生变化，也明白了为什么修改 targetSdkVersion 需要做完整的测试了。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"targetSdkVersion","slug":"targetSdkVersion","permalink":"http://www.heqingbao.net/tags/targetSdkVersion/"}]},{"title":"如何选择compileSdkVersion,minSdkVersion和targetSdkVersion","date":"2016-03-31T12:05:00.000Z","path":"2016/03/31/Android-SdkVersion/","text":"原文 https://medium.com/google-developers/picking-your-compilesdkversion-minsdkversion-targetsdkversion-a098a0341ebd#.gik7kj532作者 Ian Lake 当你发布一个应用之后，可能没过几个月Android系统就发布了一个新版本。这对你的应用意味着什么？所有东西都不能用了？ 别提心，向前兼容是Android非常关注的事情。用户在升级到新版Android的时候，用以前版本的SDK构建的现有应用应该不会出问题。这就是compileSdkVersion,minSdkVersion和targetSdkVersion的作用：它们分别控制可以使用哪些API，要求的API级别是什么，以及应用的兼容模式。 compileSdkVersioncompileSdkVersion告诉Gradle用哪个Android SDK版本编译你的应用，使用任何新添加的API就需要使用对应在Level的Android SDK。 需要强调的是修改compileSdkVersion不会改变运行时的行为。当你修改了compileSdkVersion的时候，可能会出现新的编译警告、编译错误，但新的compileSdkVersion不会被包含到APK中：它纯粹只是在编译的时候使用。（你真的应用修复这些警告，他们的出现一定是有原因的） 因此强烈推荐总是使用最新的SDK进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的API，并且为使用新的API做好准备。 注意，如果使用 Support Library ，那么使用最新发布的 Support Library 就需要使用最新的 SDK 编译。例如，要使用 23.1.1 版本的 Support Library ，compileSdkVersion 就必需至少是 23 （大版本号要一致！）。通常，新版的 Support Library 随着新的系统版本而发布，它为系统新增加的 API 和新特性提供兼容性支持。 minSdkVersion如果 compileSdkVersion 设置为可用的最新 API，那么 minSdkVersion 则是应用可以运行的最低要求。minSdkVersion 是 Google Play 商店用来判断用户设备是否可以安装某个应用的标志之一。 在开发时 minSdkVersion 也起到一个重要角色：lint 默认会在项目中运行，它在你使用了高于 minSdkVersion 的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。如果只在较高版本的系统上才使用某些 API，通常使用运行时检查系统版本的方式解决。 请记住，你所使用的库，如 Support Library 或 Google Play services，可能有他们自己的 minSdkVersion 。你的应用设置的 minSdkVersion 必需大于等于这些库的 minSdkVersion 。例如有三个库，它们的 minSdkVersion 分别是 4, 7 和 9 ，那么你的 minSdkVersion 必需至少是 9 才能使用它们。在少数情况下，你仍然想用一个比你应用的 minSdkVersion 还高的库（处理所有的边缘情况，确保它只在较新的平台上使用），你可以使用 tools:overrideLibrary 标记，但请做彻底的测试！ 当你决定使用什么 minSdkVersion 时候，你应该参考当前的 Android 分布统计，它显示了最近 7 天所有访问 Google Play 的设备信息。他们就是你把应用发布到 Google Play 时的潜在用户。最终这是一个商业决策问题，取决于为了支持额外 3% 的设备，确保最佳体验而付出的开发和测试成本是否值得。 当然，如果某个新的 API 是你整个应用的关键，那么确定 minSdkVersion 的值就比较容易了。不过要记得 14 亿设备中的 0.7％ 也是个不小的数字。 targetSdkVersion三个版本号中最有意义的就是targetSdkVersion了。targetSdkVersion是Android提供向前兼容的主要依据，在应用的targetSdkVersion没有更新之前系统不会应用最新的行为变化。这允许你在适应新的行为变化之前就可以使用新的API（因为你已经更新了compileSdkVersion不是吗？） targetSdkVersion所暗示的这么多行为变化都记录在Build.VERSION_CODES文档中了，但是所有恐怖的细节也都列在每次发布的平台这点中了，在这个API Level表中可以方便地找到相应的链接。 例如，Android 6.0变化文档中谈了target为API23时会如何把你的应用转到运行时权限模型上，Android 4.4行为变化阐述了target为API19及以上时使用set()和setRepeating()设置alarm会有怎样的行为变化。 由于某些行为的变化对用户是非常明显的（弃用menu按钮，运行时权限等]，所以将target更新为最新的SDK是所有应用都应该优先处理的事情。但这不意味着你一定要使用所有新引入的功能，也不意味着你可以不做任何测试就盲目地更新targetSdkVersion，请一定在更新targetSdkVersion之前做测试！你的用户会感谢你的。 Gradle和SDK版本所以设置正确的compileSdkVersion，minSdkVersion和targetSdkVersion很重要。如你所想，Gradle和Android Studio都在构建系统中集成了它们。在你的模块的build.gradle文件中（也可以在Android Studio的项目结构选项中）设置： 123456789101112android &#123; compileSdkVersion 23 buildToolsVersion \"23.0.1\" defaultConfig &#123; applicationId \"com.example.checkyourtargetsdk\" minSdkVersion 7 targetSdkVersion 23 versionCode 1 versionName \"1.0\" &#125;&#125; 编译时用到的 compileSdkVersion 是和构建工具版本一起设置的。其他两个稍有不同，他们在构建变体(build variant)的那里声明。defaultConfig 是所有构建变体的基础，也是设置这些默认值的地方。你可以想象在一个更复杂的系统中，应用的某些版本可能会有不同的 minSdkVersion 。 minSdkVersion 和 targetSdkVersion 与 compileSdkVersion 的另一个不同之处是它们会被包含进最终的 APK 文件中，如果你查看生成的 AndroidManifest.xml 文件，你会看到类似下面这样的标签： 1&lt;uses-sdk android:targetSdkVersion=\"23\" android:minSdkVersion=\"7\" /&gt; 如果你在 manifest 文件中手工设置，你会发现 Gradle 在构建时会忽略它们（尽管其它构建系统可能会明确依赖它们）。 综合来看如果你按照上面示例那样配置，你会发现这三个值的关系是： 1minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion 这种直觉是合理的，如果 compileSdkVersion 是你的最大值，minSdkVersion 是最小值，那么最大值必需至少和最小值一样大且 target 必需在二者之间。 理想上，在稳定状态下三者的关系应该更像这样： 1minSdkVersion (lowest possible) &lt;= targetSdkVersion == compileSdkVersion (latest SDK) 用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 target 和 compile 来获得最好的外观和行为。#BuildBetterApps 关于本文的内容您可以参与我们 Google+帖子上的讨论，关注我们的 Android Development Patterns 信息流获得更多信息。","tags":[{"name":"sdk-version","slug":"sdk-version","permalink":"http://www.heqingbao.net/tags/sdk-version/"}]},{"title":"深入分析Java ClassLoader原理","date":"2016-03-15T07:16:33.000Z","path":"2016/03/15/Java-ClassLoader/","text":"原文链接 http://blog.csdn.net/xyang81/article/details/7292380作者 xyang0917内容有改动 什么是ClassLoader大家都知道，当我们写好一个Java程序之后，不管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中调用另外一个class文件中的方法，如果另外一个文件不存在，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。 Java默认提供三个ClassLoader BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件： 1234567891011import java.net.URL;public class HelloWorld &#123; public static void main(String[] args) &#123; URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for (int i = 0; i &lt; urls.length; i++) &#123; System.out.println(urls[i].toExternalForm()); &#125; &#125;&#125; 注意以上代码如果在IDE中可能会有编译异常，通过javac HelloWorld.java编译会有一个警告，但不影响运行。 以下内容是上述程序从本机JDK环境所获得的结果： 12345678file:/C:/Program%20Files/Java/jdk1.7.0_79/jre/lib/resources.jarfile:/C:/Program%20Files/Java/jdk1.7.0_79/jre/lib/rt.jarfile:/C:/Program%20Files/Java/jdk1.7.0_79/jre/lib/sunrsasign.jarfile:/C:/Program%20Files/Java/jdk1.7.0_79/jre/lib/jsse.jarfile:/C:/Program%20Files/Java/jdk1.7.0_79/jre/lib/jce.jarfile:/C:/Program%20Files/Java/jdk1.7.0_79/jre/lib/charsets.jarfile:/C:/Program%20Files/Java/jdk1.7.0_79/jre/lib/jfr.jarfile:/C:/Program%20Files/Java/jdk1.7.0_79/jre/classes 其实上述结果也是通过查找sun.boot.class.path这个系统属性所得知的。 1System.out.println(System.getProperty(\"sun.boot.class.path\")); 打印结果：C:\\Program Files\\Java\\jdk1.7.0_79\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.7.0_79\\jre\\lib\\rt.jar;C:\\Program Files\\Java\\jdk1.7.0_79\\jre\\lib\\sunrsasign.jar;C:\\Program Files\\Java\\jdk1.7.0_79\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.7.0_79\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.7.0_79\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.7.0_79\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.7.0_79\\jre\\classes Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext目录下的所有jar。 App ClassLoader：称为系类加载器，负责加载应用程序classpath目录下的所有jar和class文件。 注意除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。 ClassLoader加载类的原理原理介绍ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。 为什么要使用双亲委托这种模型呢因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。 但是JVM在搜索类的时候又是如何判定两个class是相同的呢？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。现在通过实例来验证上述所描述的是否正确： 在Web服务器上创建一个org.classloader.simple.NetClassLoaderSimple.java类 12345678910package org.classloader.simple; public class NetClassLoaderSimple &#123; private NetClassLoaderSimple instance; public void setNetClassLoaderSimple(Object obj) &#123; this.instance = (NetClassLoaderSimple)obj; &#125; &#125; org.classloader.simple.NetClassLoaderSimple类的setNetClassLoaderSimple方法接收一个Object类型参数，并将它强制转换成org.classloader.simple.NetClassLoaderSimple类型。 测试两个class是否相同（NetWorkClassLoader.java) 123456789101112131415161718192021package classloader; public class NewworkClassLoaderTest &#123; public static void main(String[] args) &#123; try &#123; //测试加载网络中的class文件 String rootUrl = \"http://localhost:8080/httpweb/classes\"; String className = \"org.classloader.simple.NetClassLoaderSimple\"; NetworkClassLoader ncl1 = new NetworkClassLoader(rootUrl); NetworkClassLoader ncl2 = new NetworkClassLoader(rootUrl); Class&lt;?&gt; clazz1 = ncl1.loadClass(className); Class&lt;?&gt; clazz2 = ncl2.loadClass(className); Object obj1 = clazz1.newInstance(); Object obj2 = clazz2.newInstance(); clazz1.getMethod(\"setNetClassLoaderSimple\", Object.class).invoke(obj1, obj2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 首先获得网络上一个class文件的二进制名称，然后通过自定义的类加载器NetworkClassLoader创建两个实例，并根据网络地址分别加载这份class，并得到这两个ClassLoader实例加载后生成的Class实例clazz1和clazz2，最后将这两个Class实例分别生成具体的实例对象obj1和obj2，再通过反射调用clazz1中的setNetClassLoaderSimple方法。 查看测试结果 结论：从结果中可以看出，虽然是同一份class字节码文件，但是由于被两个不同的ClassLoader实例所加载，所以JVM认为它们就是两个不同的类。 ClassLoader的体系架构 验证ClassLoader加载类的原理 测试1：打印ClassLoader类的层次结构，请看下面这段代码 ： 123456ClassLoader loader = ClassLoaderTest.class.getClassLoader(); //获得加载ClassLoaderTest.class这个类的类加载器 while(loader != null) &#123; System.out.println(loader); loader = loader.getParent(); //获得父类加载器的引用 &#125; System.out.println(loader); 打印结果： 第一行结果说明：ClassLoaderTest的类加载器是AppClassLoader。第二行结果说明：AppClassLoader的类加器是ExtClassLoader，即parent=ExtClassLoader。第三行结果说明：ExtClassLoader的类加器是Bootstrap ClassLoader，因为Bootstrap ClassLoader不是一个普通的Java类，所以ExtClassLoader的parent=null，所以第三行的打印结果为null就是这个原因。 测试2：将ClassLoaderTest.class打包成ClassLoaderTest.jar，放到Extension ClassLoader的加载目录下（JAVA_HOME/jre/lib/ext），然后重新运行这个程序，得到的结果会是什么样呢？ 打印结果： 打印结果分析： 为什么第一行的结果是ExtClassLoader呢？因为ClassLoader的委托模型机制，当我们要用ClassLoaderTest.class这个类的时候，AppClassLoader在试图加载之前，先委托给Bootstrcp ClassLoader，Bootstracp ClassLoader发现自己没找到，它就告诉ExtClassLoader，兄弟，我这里没有这个类，你去加载看看，然后Extension ClassLoader拿着这个类去它指定的类路径（JAVA_HOME/jre/lib/ext）试图加载，唉，它发现在ClassLoaderTest.jar这样一个文件中包含ClassLoaderTest.class这样的一个文件，然后它把找到的这个类加载到内存当中，并生成这个类的Class实例对象，最后把这个实例返回。所以ClassLoaderTest.class的类加载器是ExtClassLoader。 第二行的结果为null，是因为ExtClassLoader的父类加载器是Bootstrap ClassLoader。 测试3：用Bootstrap ClassLoader来加载ClassLoaderTest.class，有两种方式： 在jvm中添加-Xbootclasspath参数，指定Bootstrcp ClassLoader加载类的路径，并追加我们自已的jar（ClassTestLoader.jar） 将class文件放到JAVA_HOME/jre/classes/目录下（上面有提到） 方式1：（我用的是Eclipse开发工具，用命令行是在java命令后面添加-Xbootclasspath参数） 打开Run配置对话框： 配置好如图中所述的参数后，重新运行程序，产的结果如下所示：（类加载的过程，只摘下了一部份） 打印结果： 1234567891011121314151617181920212223242526272829303132333435363738[Loaded java.io.FileReader from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded sun.nio.cs.StreamDecoder from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.ArrayList from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.lang.reflect.Array from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.Locale from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.ConcurrentMap from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.ConcurrentHashMap from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.locks.Lock from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.locks.ReentrantLock from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.ConcurrentHashMap$Segment from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.locks.AbstractOwnableSynchronizer from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.locks.AbstractQueuedSynchronizer from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.locks.ReentrantLock$Sync from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.locks.ReentrantLock$NonfairSync from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.locks.AbstractQueuedSynchronizer$Node from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.concurrent.ConcurrentHashMap$HashEntry from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.lang.CharacterDataLatin1 from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.io.ObjectStreamClass from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded sun.net.www.ParseUtil from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.BitSet from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.net.Parts from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.net.URLStreamHandler from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded sun.net.www.protocol.file.Handler from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.util.HashSet from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded sun.net.www.protocol.jar.Handler from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded sun.misc.Launcher$AppClassLoader from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded sun.misc.Launcher$AppClassLoader$1 from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.lang.SystemClassLoaderAction from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Path C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\classes] [Loaded classloader.ClassLoaderTest from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\classes] null //这是打印的结果 C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar; C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\sunrsasign.jar;C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\jsse.jar; C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\charsets.jar; C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\classes;c:\\ClassLoaderTest.jar //这一段是System.out.println(System.getProperty(\"sun.boot.class.path\"));打印出来的。这个路径就是Bootstrcp ClassLoader默认搜索类的路径 [Loaded java.lang.Shutdown from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] [Loaded java.lang.Shutdown$Lock from C:\\Program Files\\Java\\jdk1.6.0_22\\jre\\lib\\rt.jar] 方式2：将ClassLoaderTest.jar解压后，放到JAVA_HOME/jre/classes目录下，如下图所示： 提示：jre目录下默认没有classes目录，需要自己手动创建一个 打印结果： 从结果中可以看出，两种方式都实现了将ClassLoaderTest.class由Bootstrcp ClassLoader加载成功了。 定义自已的ClassLoader既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？ 因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。 定义自已的类加载器分为两步： 继承java.lang.ClassLoader 重写父类的findClass方法 可能在这里有疑问，父类有那么多方法，为什么偏偏只重写findClass方法？ 因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。下图是API中ClassLoader的loadClass方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // 首先检查是否已经加载类 Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; // 在父类加载器上调用loadClass方法 c = parent.loadClass(name, false); &#125; else &#123; // 父加载器为null，使用虚拟机的内置类加载器 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); // 调用findClass(String)方法查找类 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; // 如果使用上述步骤找到类，并且resolve标志为真，则此方法将在得到的Class对象上调用resolveClass(Class)方法。 if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; loadClass(String name, boolean resolve)方法的注释： 示例：自定义一个NetworkClassLoader，用于加载网络上的class文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.demo.classloader;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.URL;public class NetWorkClassLoader extends ClassLoader &#123; private String rootUrl; public NetWorkClassLoader(String rootUrl) &#123; this.rootUrl = rootUrl; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = null; byte[] classData = getClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; clazz = defineClass(name, classData, 0, classData.length); return clazz; &#125; private byte[] getClassData(String name) &#123; InputStream input = null; try &#123; String path = classNameToPath(name); URL url = new URL(path); byte[] buff = new byte[1024 * 4]; int len = -1; input = url.openStream(); ByteArrayOutputStream boas = new ByteArrayOutputStream(); while ((len = input.read(buff)) != -1) &#123; boas.write(buff, 0, len); &#125; return boas.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (input != null) &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125; private String classNameToPath(String name) &#123; return rootUrl + \"/\" + name.replace(\".\", \"/\") + \".class\"; &#125;&#125; 测试类： 123456789101112131415161718192021222324package com.demo.classloader;public class ClassLoaderTest &#123; public static void main(String[] args) &#123; try &#123; /*ClassLoader loader = ClassLoaderTest.class.getClassLoader(); //获得ClassLoaderTest这个类的类加载器 while(loader != null) &#123; System.out.println(loader); loader = loader.getParent(); //获得父加载器的引用 &#125; System.out.println(loader);*/ String rootUrl = \"http://localhost:8080/httpweb/classes\"; NetWorkClassLoader networkClassLoader = new NetWorkClassLoader(rootUrl); String classname = \"org.classloader.simple.NetClassLoaderTest\"; Class&lt;?&gt; clazz = networkClassLoader.loadClass(classname); System.out.println(clazz.getClassLoader()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印结果： 下图是我机器上web服务器的目录结构： 目前常用web服务器中都定义了自己的类加载器，用于加载web应用指定目录下的类库（jar或class），如：Weblogic、Jboss、tomcat等，下面我以Tomcat为例，展示该web容器都定义了哪些个类加载器： 新建一个web工程httpweb 新建一个ClassLoaderServletTest，用于打印web容器中的ClassLoader层次结构 12345678910111213141516171819202122232425262728293031import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ClassLoaderServletTest extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html\"); PrintWriter out = response.getWriter(); ClassLoader loader = this.getClass().getClassLoader(); while(loader != null) &#123; out.write(loader.getClass().getName()+\"&lt;br/&gt;\"); loader = loader.getParent(); &#125; out.write(String.valueOf(loader)); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125; &#125; 配置Servlet，并启动服务 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;ClassLoaderServletTest&lt;/servlet-name&gt; &lt;servlet-class&gt;ClassLoaderServletTest&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ClassLoaderServletTest&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ClassLoaderServletTest&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 访问Servlet，获得显示结果","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"ClassLoader","slug":"ClassLoader","permalink":"http://www.heqingbao.net/tags/ClassLoader/"}]},{"title":"HashMap工作原理","date":"2016-03-14T11:02:30.000Z","path":"2016/03/14/Java_HashMap/","text":"原文 https://www.javacodegeeks.com/2014/03/how-hashmap-works-in-java.html作者 Arpit Mandliya 内容有改动 面试的时候经常会遇见诸如：“java中的HashMap是怎么工作的”，“HashMap的get和put内部的工作原理”这样的问题。本文将用一个简单的例子来解释下HashMap内部的工作原理。首先我们从一个例子开始，而不仅仅是从理论上，这样，有助于更好地理解，然后，我们来看下get和put到底是怎样工作的。 我们来看个非常简单的例子。有一个”国家”(Country)类，我们将要用Country对象作为key，它的首都的名字（String类型）作为value。下面的例子有助于我们理解key-value对在HashMap中是如何存储的。 Country.java12345678910111213141516171819202122232425262728293031323334353637383940414243public class Country &#123; private String name; private int population; public Country(String name, int population) &#123; this.name = name; this.population = population; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getPopulation() &#123; return population; &#125; public void setPopulation(int population) &#123; this.population = population; &#125; // If length of name in country object is even then return 31(any random number) and if odd then return 95(any random number). // This is not a good practice to generate hashcode as below method but I am doing so to give better and easy understanding of hashmap. @Override public int hashCode() &#123; if (this.name.length() % 2 == 0) &#123; return 31; &#125; else &#123; return 95; &#125; &#125; @Override public boolean equals(Object obj) &#123; Country other = (Country) obj; return name.equalsIgnoreCase(other.getName()); &#125;&#125; 如果你想更多地了解hashCode和equals方法，可以参考hashcode() and equals() method in java。 HashMapStructure.java1234567891011121314151617181920212223public class HashMapStructure &#123; public static void main(String[] args) &#123; Country india = new Country(\"India\", 1000); Country japan = new Country(\"Japan\", 10000); Country france = new Country(\"France\", 2000); Country russia = new Country(\"Russia\", 20000); HashMap&lt;Country, String&gt; map = new HashMap&lt;&gt;(); map.put(india, \"Delhi\"); map.put(japan, \"Tokyo\"); map.put(france, \"Paris\"); map.put(russia, \"Moscow\"); Iterator&lt;Country&gt; it = map.keySet().iterator(); // 在这一行加入断点调试 while (it.hasNext()) &#123; Country country = it.next(); String capital = map.get(country); System.out.println(country.getName() + \"---\" + capital); &#125; &#125;&#125; 在迭代器那一行加入断点，Debug到此位置。然后我们看一下map里面的内容： 从上图可以观察到以下几点： 有一个叫做table大小是16的Entry数组。 这个table数组存储了Entry类的对象。HashMap类有一个叫做Entry的内部类。这个Entry类包含了key-value作为实例变量。我们来看一下Entry类的结构： HashMap$Entry：123456789101112131415161718static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; ...&#125; 每当往HashMap里面存放key-value对的时候，都会为它们实例化一个Entry对象，这个Entry对象就会存储在前面提到的Entry数组table中。现在你一定很想知道，上面创建的Entry对象将会存放在具体哪个位置（在table中的精确位置）。答案就是，根据Key的hashCode()方法计算出来的hash值来决定。hash值用来计算key在Entry数组中的索引。 现在，如果你看下上图中数组索引10，它有一个叫做HashMap$Entry的Entry对象。 我们往HashMap放了4个key-value对，但是看上去好像只有2个元素！！！这是因为，如果两个元素有相同的hashCode，它们会被放在同一个索引上。问题出现了，该怎么放呢？原来它是以链表（LinkedList）的形式来存储（逻辑上）。 我们来看一下上面几个Country的hashCode. 1234Hashcode for Japan = 95 as its length is odd.Hashcode for India =95 as its length is oddHashCode for Russia=31 as its length is even.HashCode for France=31 as its length is even. 下图会清晰的从概念上解释下链表： 所以，现在假如你已经很好地了解了HashMap的结构，让我们看下put和get方法。 HashMap#put 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125;final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;/** * Returns index for hash code h. */static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\"; return h &amp; (length-1);&#125;/** * Adds a new entry with the specified key, value and hash code to * the specified bucket. It is the responsibility of this * method to resize the table if appropriate. * * Subclass overrides this to alter the behavior of put method. */void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; 现在一步一步来看上面的代码： 对key做null检查。如果key是null，会被存储到table[0]，因为null的hash值总是0. key的hashCode()方法会被调用，然后计算hash值。hash值用来找到存储Entry对象的数组的索引。有时候hash函数可能写的很不好，所以JDK的设计者添加了另一个叫做hash()的方法，它接收刚才计算的hash值作为参数。 indexFor(int h, int length)用来计算在table数组中存储Entry对象的精确位置。 在我们的例子已经看到，如果两个key有相同的hash值（也叫冲突），他们会以链表的形式莱存储。所以，这里我们就迭代链表。 如果刚才计算出来的索引位置没有元素，则直接把Entry对象放到那个索引上。 如果索引上有元素，则已有的Entry对象将作为新添加Entry对象的下一个节点。(If There is element present at that index then it will iterate until it gets Entry-&gt;next as null.Then current Entry object become next node in that linkedlist，原文好像有问题，根据createEntry方法的逻辑来看，是把当前index上的元素取出来传给了new Entry的next) 如果我们再次放入同样的key会怎样呢？逻辑上，它应该替换老的value。事实上，它确实是这么做的。在迭代的过程中，会调用equals()方法来检查key的相等性(key.equals(k))，如果这个方法返回true，它就会用当前的Entry的value来替换之前的value。 HashMap#get1234567891011121314151617181920212223242526272829303132333435public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125;private V getForNullKey() &#123; if (size == 0) &#123; return null; &#125; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null;&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; 当你理解了HashMap的put的工作原理，理解get的工作原理就非常简单了。当你传递一个key从HashMap中获取value的时候： 对key进行null检查。如果Key为null，table[0]这个位置的元素将被返回（如果size==0则返回null）。 key的hashCode方法被调用，然后计算hash值。 indexFor(hash, table.length)用来计算要获取的Entry对象在table数组中精确的位置，使用刚才计算的hash值。 在获取了table数组索引之后，会迭代链表，调用equals()方法检查key的相等性，如果equals()方法返回true，get方法返回Entry对象的value，否则返回null. 要牢记以下关键点 HashMap有一个叫做Entry的内部类，它用来存储kye-value对。 上面的Entry对象是存储在一个叫做table的Entry数组中。 table的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。 key的hashCode方法用来找到Entry对象所在的桶。 如果两个key有相同的hash值，他们会被放在table数组的同一个桶里面。 key的equals()方法用来确保key的唯一性。 value对象的equals()和hashcode()方法根本一点用也没有。 问题一：为什么初始化table数组的时候，我们看到的是size==16呢？ 构造方法：123456789101112131415161718192021222324252627282930313233343536373839404142/** * The default initial capacity - MUST be a power of two. */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f;static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;/** * The table, resized as necessary. Length MUST Always be a power of two. */transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125;public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init();&#125;void init() &#123;&#125; 虽然构造方法里面把threshold初始化成16了，并且init是空实现，但是threshold是个什么东西？此时table仍是EMPTY_TABLE。再看put方法： 12345678910111213141516171819202122232425262728293031323334/** * The next size value at which to resize (capacity * load factor). * @serial */// If table == EMPTY_TABLE then this is the initial capacity at which the// table will be created when inflated.int threshold;public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; ...&#125;/** * Inflates the table. */private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize int capacity = roundUpToPowerOf2(toSize); threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; initHashSeedAsNeeded(capacity);&#125;private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : \"number must be non-negative\"; return number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;&#125; 原来是在inflateTable里面new了一个新的Entry数组。 问题二：根据上面看到的，初始化table数组的size==16（不同的JDK版本可能有所不同），那假设要存储的数据超过16个怎么办呢？再看put方法： 1234567891011121314151617181920212223242526272829public V put(K key, V value) &#123; ... addEntry(hash, key, value, i); return null;&#125;void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; 从源码中可以看到，扩容的时候是按照2 * table.length作为newCapacity。 另外关于loadFactory，俗称加载因子，在put的时候，判断是否需要扩容是根据当前的size和threshold来判断的，而threshold又跟加载因子有关threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1)，可见，并不是等到table数组存满了再扩容。这里的加载因子默认是0.75（static final float DEFAULT_LOAD_FACTOR = 0.75f）","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"http://www.heqingbao.net/tags/HashMap/"}]},{"title":"Activity的启动过程","date":"2016-03-13T11:37:30.000Z","path":"2016/03/13/Activity-Start-Process/","text":"注：本文所分析的源码基于Android 7.0 我们从Activity的startActivity方法开始分析，startActivity有好几种重载方式，但最终它们都会调用startActivityForResult方法。 12345678910111213141516171819202122232425262728293031323334public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123;if (mParent == null) &#123; Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125;&#125; 在上面的代码中，我们只需要关注mParent == null的这部分逻辑即可。mParent代表是ActivityGroup，ActivityGroup最开始初用来在一个界面中嵌入多个Activity，但是在API13中已经被废弃了，系统推荐采用Fragment来代替ActivityGroup。 上面代码中需要注意mMainThread.getApplicationThread()这个参数，它的类型是ApplicationThread，mMainThread的类型是ActivityThread，ApplicationThread是ActivityThread的一个内部类。接着看Instrumentation的execStartActivity方法： 12345678910111213141516171819202122232425262728293031323334353637public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 通过上面的代码可以看出，启动Activity的真正实现是由ActivityManagerNative.getDefault()的startActivity方法来完成的 。ActivityManagerService（下面简称AMS）继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并且实现了IActivityManager这个Binder接口，因此AMS也是一个Binder，它是IActivityManager的具体实现。由于ActivityManagerNative.getDefault()其实是一个IActivityManager类型的Binder对象，因此它的具体实现是AMS。在ActivityManagerNative中，AMS这个Binder对象采用单例模式对外提供，Singleton是一个单例的封装类，第一次调用它的get()方法时它会通过create方法来初始化AMS这个Binder对象。 1234567891011121314151617static public IActivityManager getDefault() &#123; return gDefault.get();&#125;private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; 1234567891011121314151617181920212223package android.util;/** * Singleton helper class for lazily initialization. * * Modeled after frameworks/base/include/utils/Singleton.h * * @hide */public abstract class Singleton&lt;T&gt; &#123; private T mInstance; protected abstract T create(); public final T get() &#123; synchronized (this) &#123; if (mInstance == null) &#123; mInstance = create(); &#125; return mInstance; &#125; &#125;&#125; 从上面的分析可知，Activity由ActivityManagerNative.getDefault()来启动，而ActivityManagerNative.getDefault()实际上是AMS，因此，Activity的启动过程又转移到了AMS中。 先来看一下Instrumentation的execStartActivity方法，其中有一行代码：checkStartActivityResult(result, intent);，它的具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/** @hide */public static void checkStartActivityResult(int res, Object intent) &#123; if (res &gt;= ActivityManager.START_SUCCESS) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( \"Unable to find explicit activity class \" + ((Intent)intent).getComponent().toShortString() + \"; have you declared this activity in your AndroidManifest.xml?\"); throw new ActivityNotFoundException( \"No Activity found to handle \" + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException(\"Not allowed to start activity \" + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( \"FORWARD_RESULT_FLAG used while also requesting a result\"); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( \"PendingIntent is not an activity\"); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( \"Starting under voice control not allowed for: \" + intent); case ActivityManager.START_NOT_CURRENT_USER_ACTIVITY: // Fail silently for this case so we don't break current apps. // TODO(b/22929608): Instead of failing silently or throwing an exception, // we should properly position the activity in the stack (i.e. behind all current // user activity/task) and not change the positioning of stacks. Log.e(TAG, \"Not allowed to start background user activity that shouldn't be displayed\" + \" for all users. Failing silently...\"); break; default: throw new AndroidRuntimeException(\"Unknown error code \" + res + \" when starting \" + intent); &#125;&#125; 从上面可以看出，checkStartActivityResult就是检查启动Activity的结果。当无法正确地启动一个Activity时，这个方法会抛出异常，其中最熟悉不过的Unable to find explicit activity class; have you declared this activity in your AndroidManifest.xml?就是在这里抛出的，当待启动的Activity没有在AndroidManifest中注册时，就会抛这个异常。 接着看AMS的startActivity方法： 123456789101112131415161718192021@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); // TODO: Switch to user app stacks here. return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null);&#125; 可见，Activity的启动过程又转移到了ActivityStarter中的startActivityMayWait方法中了。在startActivityMayWait又调用了startActivityLocked，然后startActivityLocked方法中又调用了startActivityUnchecked方法，接着startActivityUnchecked又调用了ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法： 1234567891011boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; return false;&#125; 可以看到又调用了ActivityStack的resumeTopActivityUncheckedLocked方法： 1234567891011121314151617181920212223242526boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125;private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... mStackSupervisor.startSpecificActivityLocked(next, true, true); ...&#125; 这个时候Activity启动过程又从ActivityStack转移到了ActivityStackSupervisor中。 ActivityStackSupervisor#startSpecificActivityLocked 123456789101112131415161718void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; ... realStartActivityLocked(r, app, andResume, checkConfig); ...&#125;final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ...&#125; 从源码中看到，startSpecificActivityLocked里面又调用了realStartActivityLocked。在ActivityStackSupervisor的realStartActivityLocked方法有如下一段代码： 12345app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); app.thread的类型为IApplicationThread： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/** * System private API for communicating with the application. This is given to * the activity manager by an application when it starts up, for the activity * manager to tell the application about things it needs to do. * * &#123;@hide&#125; */public interface IApplicationThread extends IInterface &#123; void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) throws RemoteException; void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) throws RemoteException; void scheduleWindowVisibility(IBinder token, boolean showWindow) throws RemoteException; void scheduleSleeping(IBinder token, boolean sleeping) throws RemoteException; void scheduleResumeActivity(IBinder token, int procState, boolean isForward, Bundle resumeArgs) throws RemoteException; void scheduleSendResult(IBinder token, List&lt;ResultInfo&gt; results) throws RemoteException; void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) throws RemoteException; void scheduleRelaunchActivity(IBinder token, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, int configChanges, boolean notResumed, Configuration config, Configuration overrideConfig) throws RemoteException; void scheduleNewIntent(List&lt;ReferrerIntent&gt; intent, IBinder token) throws RemoteException; void scheduleDestroyActivity(IBinder token, boolean finished, int configChanges) throws RemoteException; void scheduleReceiver(Intent intent, ActivityInfo info, CompatibilityInfo compatInfo, int resultCode, String data, Bundle extras, boolean sync, int sendingUser, int processState) throws RemoteException; static final int BACKUP_MODE_INCREMENTAL = 0; static final int BACKUP_MODE_FULL = 1; static final int BACKUP_MODE_RESTORE = 2; static final int BACKUP_MODE_RESTORE_FULL = 3; void scheduleCreateBackupAgent(ApplicationInfo app, CompatibilityInfo compatInfo, int backupMode) throws RemoteException; void scheduleDestroyBackupAgent(ApplicationInfo app, CompatibilityInfo compatInfo) throws RemoteException; void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) throws RemoteException; void scheduleBindService(IBinder token, Intent intent, boolean rebind, int processState) throws RemoteException; void scheduleUnbindService(IBinder token, Intent intent) throws RemoteException; void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId, int flags, Intent args) throws RemoteException; void scheduleStopService(IBinder token) throws RemoteException; static final int DEBUG_OFF = 0; static final int DEBUG_ON = 1; static final int DEBUG_WAIT = 2; void bindApplication(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo, Bundle testArguments, IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection, int debugMode, boolean openGlTrace, boolean restrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) throws RemoteException; void scheduleExit() throws RemoteException; void scheduleSuicide() throws RemoteException; void scheduleConfigurationChanged(Configuration config) throws RemoteException; void updateTimeZone() throws RemoteException; void clearDnsCache() throws RemoteException; void setHttpProxy(String proxy, String port, String exclList, Uri pacFileUrl) throws RemoteException; void processInBackground() throws RemoteException; void dumpService(FileDescriptor fd, IBinder servicetoken, String[] args) throws RemoteException; void dumpProvider(FileDescriptor fd, IBinder servicetoken, String[] args) throws RemoteException; void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException; void scheduleLowMemory() throws RemoteException; void scheduleActivityConfigurationChanged(IBinder token, Configuration overrideConfig) throws RemoteException; void profilerControl(boolean start, ProfilerInfo profilerInfo, int profileType) throws RemoteException; void dumpHeap(boolean managed, String path, ParcelFileDescriptor fd) throws RemoteException; void setSchedulingGroup(int group) throws RemoteException; static final int PACKAGE_REMOVED = 0; static final int EXTERNAL_STORAGE_UNAVAILABLE = 1; void dispatchPackageBroadcast(int cmd, String[] packages) throws RemoteException; void scheduleCrash(String msg) throws RemoteException; void dumpActivity(FileDescriptor fd, IBinder servicetoken, String prefix, String[] args) throws RemoteException; void setCoreSettings(Bundle coreSettings) throws RemoteException; void updatePackageCompatibilityInfo(String pkg, CompatibilityInfo info) throws RemoteException; void scheduleTrimMemory(int level) throws RemoteException; void dumpMemInfo(FileDescriptor fd, Debug.MemoryInfo mem, boolean checkin, boolean dumpInfo, boolean dumpDalvik, boolean dumpSummaryOnly, String[] args) throws RemoteException; void dumpGfxInfo(FileDescriptor fd, String[] args) throws RemoteException; void dumpDbInfo(FileDescriptor fd, String[] args) throws RemoteException; void unstableProviderDied(IBinder provider) throws RemoteException; void requestAssistContextExtras(IBinder activityToken, IBinder requestToken, int requestType) throws RemoteException; void scheduleTranslucentConversionComplete(IBinder token, boolean timeout) throws RemoteException; void scheduleOnNewActivityOptions(IBinder token, ActivityOptions options) throws RemoteException; void setProcessState(int state) throws RemoteException; void scheduleInstallProvider(ProviderInfo provider) throws RemoteException; void updateTimePrefs(boolean is24Hour) throws RemoteException; void scheduleCancelVisibleBehind(IBinder token) throws RemoteException; void scheduleBackgroundVisibleBehindChanged(IBinder token, boolean enabled) throws RemoteException; void scheduleEnterAnimationComplete(IBinder token) throws RemoteException; void notifyCleartextNetwork(byte[] firstPacket) throws RemoteException; String descriptor = \"android.app.IApplicationThread\"; int SCHEDULE_PAUSE_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION; int SCHEDULE_STOP_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+2; int SCHEDULE_WINDOW_VISIBILITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+3; int SCHEDULE_RESUME_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+4; int SCHEDULE_SEND_RESULT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+5; int SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+6; int SCHEDULE_NEW_INTENT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+7; int SCHEDULE_FINISH_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+8; int SCHEDULE_RECEIVER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+9; int SCHEDULE_CREATE_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+10; int SCHEDULE_STOP_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+11; int BIND_APPLICATION_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+12; int SCHEDULE_EXIT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+13; int SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+15; int SCHEDULE_SERVICE_ARGS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+16; int UPDATE_TIME_ZONE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+17; int PROCESS_IN_BACKGROUND_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+18; int SCHEDULE_BIND_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+19; int SCHEDULE_UNBIND_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+20; int DUMP_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+21; int SCHEDULE_REGISTERED_RECEIVER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+22; int SCHEDULE_LOW_MEMORY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+23; int SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+24; int SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+25; int SCHEDULE_SLEEPING_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+26; int PROFILER_CONTROL_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+27; int SET_SCHEDULING_GROUP_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+28; int SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+29; int SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+30; int SCHEDULE_ON_NEW_ACTIVITY_OPTIONS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+31; int SCHEDULE_SUICIDE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+32; int DISPATCH_PACKAGE_BROADCAST_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+33; int SCHEDULE_CRASH_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+34; int DUMP_HEAP_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+35; int DUMP_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+36; int CLEAR_DNS_CACHE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+37; int SET_HTTP_PROXY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+38; int SET_CORE_SETTINGS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+39; int UPDATE_PACKAGE_COMPATIBILITY_INFO_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+40; int SCHEDULE_TRIM_MEMORY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+41; int DUMP_MEM_INFO_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+42; int DUMP_GFX_INFO_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+43; int DUMP_PROVIDER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+44; int DUMP_DB_INFO_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+45; int UNSTABLE_PROVIDER_DIED_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+46; int REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+47; int SCHEDULE_TRANSLUCENT_CONVERSION_COMPLETE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+48; int SET_PROCESS_STATE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+49; int SCHEDULE_INSTALL_PROVIDER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+50; int UPDATE_TIME_PREFS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+51; int CANCEL_VISIBLE_BEHIND_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+52; int BACKGROUND_VISIBLE_BEHIND_CHANGED_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+53; int ENTER_ANIMATION_COMPLETE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+54; int NOTIFY_CLEARTEXT_NETWORK_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+55;&#125; 因为它继承了IInterface接口，所以它是一个Binder类型的接口。从IApplicationThread声明的接口方法可以看出，其内部包含了大量的启动、停止Activity的接口，此外还包含了启动/停止服务的接口。从接口的方法命名可以猜测，IApplicationThread这个Binder接口的实现者完成了大量和Activity以及Service启动/停止相关的功能。 IApplicationThread的实现者就是ActivityThread中的内部类ApplicationThread 12345public final class ActivityThread &#123; ... private class ApplicationThread extends ApplicationThreadNative &#123;...&#125; ...&#125; 123public abstract class ApplicationThreadNative extends Binder implements IApplicationThread &#123;...&#125;class ApplicationThreadProxy implements IApplicationThread &#123;...&#125; 这个ApplicationThreadNative类的结构很像系统为AIDL文件自动生成的Stub类。种种迹象表明，ApplicationThreadNative就是IApplicationThread的实现者，由于ApplicationThreadNative被定义成抽象的，所以ApplicationThread就成了IApplicationThread的实现者。 绕了一大圈，Activity的启动过程最终回到了ApplicationThread中，ApplicationThread通过scheduleLaunchActivity方法来启动Activity： 1234567891011121314151617181920212223242526272829303132333435@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; ActivityThread:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void sendMessage(int what, Object obj) &#123; sendMessage(what, obj, 0, 0, false);&#125;private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what) + \": \" + arg1 + \" / \" + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125;final H mH = new H();private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case RELAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityRestart\"); ActivityClientRecord r = (ActivityClientRecord)msg.obj; handleRelaunchActivity(r); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case PAUSE_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); handlePauseActivity((IBinder)msg.obj, false, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;2) != 0); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; .... &#125;&#125; 从Handler H对LAUNCH_ACTIVITY这个消息的处理可以知道，Activity的启动过程由ActivityThread的handleLaunchActivity方法来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, \"Handling launch of \" + r); // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; // The activity manager actually wants this one to start out // paused, because it needs to be visible but isn't in the // foreground. We accomplish this by going through the // normal startup (because activities expect to go through // onResume() the first time they run, before their window // is displayed), and then pausing it. However, in this case // we do -not- need to do the full pause cycle (of freezing // and such) because the activity manager assumes it can just // retain the current state it has. try &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); // We need to keep around the original state, in case // we need to be created again. But we only do this // for pre-Honeycomb apps, which always save their state // when pausing, so we can not have them save their state // when restarting from a paused state. For HC and later, // we want to (and can) let the state be saved as the normal // part of stopping the activity. if (r.isPreHoneycomb()) &#123; r.state = oldState; &#125; if (!r.activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onPause()\"); &#125; &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(r.activity, e)) &#123; throw new RuntimeException( \"Unable to pause activity \" + r.intent.getComponent().toShortString() + \": \" + e.toString(), e); &#125; &#125; r.paused = true; &#125; &#125; else &#123; // If there was an error, for any reason, tell the activity // manager to stop us. try &#123; ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125;&#125; 从上面的源码可以看出，performLaunchActivity方法最终完成了Activity对象的创建和启动过程。并且ActivityThread通过handleResumeActivity方法来调用被启动Activity的onResume这一生命周期方法。 ActivityThread#performLaunchActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // System.out.println(\"##### [\" + System.currentTimeMillis() + \"] ActivityThread.performLaunchActivity(\" + r + \")\"); ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, \"Performing launch of \" + r); if (localLOGV) Slog.v( TAG, r + \": app=\" + app + \", appName=\" + app.getPackageName() + \", pkg=\" + r.packageInfo.getPackageName() + \", comp=\" + r.intent.getComponent().toShortString() + \", dir=\" + r.packageInfo.getAppDir()); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onPostCreate()\"); &#125; &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to start activity \" + component + \": \" + e.toString(), e); &#125; &#125; return activity;&#125; 这个方法主要完成了以下几件事件： 从ActivityClientRecord获取待启动的Activity的组件信息 通过Instrumentation的newActivity方法使用类加载器创建Activity对象 Instrumentation.newActivity: 123456public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance();&#125; 通过LoadedApk#makeApplication方法来尝试创建Application对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = \"android.app.Application\"; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(\"android\")) &#123; initializeJavaContextClassLoader(); &#125; ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; if (!mActivityThread.mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to instantiate application \" + appClass + \": \" + e.toString(), e); &#125; &#125; mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; try &#123; instrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!instrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to create application \" + app.getClass().getName() + \": \" + e.toString(), e); &#125; &#125; &#125; // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) &#123; final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) &#123; continue; &#125; rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); &#125; return app;&#125; 从makeApplication的实现来看，如果mApplication被已经被创建过了那么就不会重新创建了，这也意味着一个应用只有一个Application对象.Application对象的创建也是由Instrumentation#newApplication完成的，这个过程和Activity的创建一样，都是通过类加载器来实现的。Application创建完成后，系统会通过Instrumenttation的callApplicationOnCreate来调用Application的onCreate方法。 创建ContextImpl对象并通过Activity的attach方法来完成一些重要数据的初始化 123456789Context appContext = createBaseContextForActivity(r, activity);CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());Configuration config = new Configuration(mCompatConfiguration);if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config);activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ContextImpl是一个很重要的数据结构，它是Context的具体实现，Context中的大部分逻辑都由ContextImpl来完成的。ContextImpl是通过Activity的attatch方法来和Activity建立关联的，除此以外，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当Window接收到外部输入事件后就可以将事件传递给Activity。 调用Activity的onCreate方法 mInstrumentation.callActivityOnCreate(activity, r.state)，由于Activity已经被调用，这也意味着Activity已经完成了整个启动过程。 最后借用一张别人疏理好的图，可以直观的展示各个调用流程，感谢作者。","tags":[{"name":"Activity","slug":"Activity","permalink":"http://www.heqingbao.net/tags/Activity/"}]},{"title":"Android中点击事件的来源","date":"2016-03-13T07:52:02.000Z","path":"2016/03/13/Android-MotionEvent-Source/","text":"原文 http://blog.csdn.net/singwhatiwanna/article/details/50775201#rd作者 任玉刚 首先看Activity的实现，如下，Activity实现了一个特殊的接口：Window.Callback 1234567public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback &#123;...&#125; Window.Callback:123456789101112131415161718192021222324252627282930313233343536373839404142434445public abstract class Window &#123; /** * API from a Window back to its caller. This allows the client to * intercept key dispatching, panels and menus, etc. */ public interface Callback &#123; /** * Called to process key events. At the very least your * implementation must call * &#123;@link android.view.Window#superDispatchKeyEvent&#125; to do the * standard key processing. * * @param event The key event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchKeyEvent(KeyEvent event); /** * Called to process a key shortcut event. * At the very least your implementation must call * &#123;@link android.view.Window#superDispatchKeyShortcutEvent&#125; to do the * standard key shortcut processing. * * @param event The key shortcut event. * @return True if this event was consumed. */ public boolean dispatchKeyShortcutEvent(KeyEvent event); /** * Called to process touch screen events. At the very least your * implementation must call * &#123;@link android.view.Window#superDispatchTouchEvent&#125; to do the * standard touch screen processing. * * @param event The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent event); ... &#125;&#125; 然后我们似乎看出了一些端倪，难道这个接口和点击事件的传递有关？嗯，你猜对了。在艺术探索这本书中，并没有描述事件是如何传递给Activity的，但是这里我们可以猜测，如果外界想要传递点击事件给Activity，那么它就必须持有Activity的引用，这没错，在Activity的attach方法中，有如下一段： 12345678910111213141516final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123; attachBaseContext(context); mFragments.attachActivity(this, mContainer, null); mWindow = PolicyManager.makeNewWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); ...&#125; 显然，mWindow持有了Activity的引用，它通过setCallback方法来持有Activity，因此，事件是从Window传递给了Activity。也许你会说：“我不信，这理由不充分！”，没关系，我们继续分析。 我们知道，Activity启动以后，在它的onResume以后，DecorView才开始attach给WindowManager从而显示出来。（什么？你不知道？回去看艺术探索第8章），请看Activity的makeVisible方法，代码如下： 12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; 123456789101112131415161718192021222324252627282930313233public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125;&#125; 可以看到，ViewRootImpl创建了，在ViewRootImpl的setView方法（此方法运行在UI线程）中，会通过跨进程的方式向WMS（WindowManagerService）发起一个调用，从而将DecorView最终添加到Window上，在这个过程中，ViewRootImpl、DecorView和WMS会彼此向关联，同时会创建InputChannel、InputQueue和WindowInputEventReceiver来接受点击事件的消息。 好了，言归正传，下面来说，点击事件到底怎么传递给Activity的。首先要明白，点击事件是由用户的触摸行为所产生的，因此它必须要通过硬件来捕获，然后点击事件会交给WMS来处理。 在ViewRootImpl中，有一个方法，叫做dispatchInputEvent，如下： 12345678public void dispatchInputEvent(InputEvent event, InputEventReceiver receiver) &#123; SomeArgs args = SomeArgs.obtain(); args.arg1 = event; args.arg2 = receiver; Message msg = mHandler.obtainMessage(MSG_DISPATCH_INPUT_EVENT, args); msg.setAsynchronous(true); mHandler.sendMessage(msg);&#125; 那么什么是InputEvent呢？InputEvent有2个子类：KeyEvent和MotionEvent，其中KeyEvent表示键盘事件，而MotionEvent表示点击事件。在上面的代码中，mHandler是一个在UI线程创建的Handder，所以它会把执行逻辑切换到UI线程中。 1final ViewRootHandler mHandler = new ViewRootHandler(); 这个消息的处理如下： 1234567case MSG_DISPATCH_INPUT_EVENT: &#123; SomeArgs args = (SomeArgs)msg.obj; InputEvent event = (InputEvent)args.arg1; InputEventReceiver receiver = (InputEventReceiver)args.arg2; enqueueInputEvent(event, receiver, 0, true); args.recycle();&#125; break; 除此之外，WindowInputEventReceiver也可以来接收点击事件的消息，同样它也有一个dispatchInputEvent方法，注意，WindowInputEventReceiver中的Looper为UI线程的Looper。 123456789101112131415161718192021222324final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; // Called from native code. @SuppressWarnings(\"unused\") private void dispatchInputEvent(int seq, InputEvent event) &#123; mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event); &#125; @Override public void onInputEvent(InputEvent event) &#123; enqueueInputEvent(event, this, 0, true); &#125;&#125;WindowInputEventReceiver mInputEventReceiver;...mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); 可以发现，不管是ViewRootImpl的dispatchInputEvent方法，还是WindowInputEventReceiver的dispatchInputEvent方法，它们本质上都是调用deliverInputEvent方法来处理点击事件的消息，如下： 1234567891011121314151617181920private void deliverInputEvent(QueuedInputEvent q) &#123; Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\", q.mEvent.getSequenceNumber()); if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0); &#125; InputStage stage; if (q.shouldSendToSynthesizer()) &#123; stage = mSyntheticInputStage; &#125; else &#123; stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; &#125; if (stage != null) &#123; stage.deliver(q); &#125; else &#123; finishInputEvent(q); &#125;&#125; 在ViewRootImpl中，有一系列类似于InputStage（输入事件舞台）的概念，每种InputStage可以处理一定的事件类型，比如AsyncInputStage、ViewPreImeInputStage、ViewPostImeInputStage等。当一个InputEvent到来时，ViewRootImpl会寻找合适它的InputStage来处理。对于点击事件来说，ViewPostImeInputStage可以处理它，ViewPostImeInputStage中，有一个processPointerEvent方法，如下，它会调用mView的dispatchPointerEvent方法，注意，这里的mView其实就是DecorView。 12345678910111213private int processPointerEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; mAttachInfo.mUnbufferedDispatchRequested = false; boolean handled = mView.dispatchPointerEvent(event); if (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) &#123; mUnbufferedInputDispatch = true; if (mConsumeBatchedInputScheduled) &#123; scheduleConsumeBatchedInputImmediately(); &#125; &#125; return handled ? FINISH_HANDLED : FORWARD;&#125; 在View的实现中，dispatchPointerEvent的逻辑如下，这样一来，点击事件就传递给了DecorView的dispatchTouchEvent方法。 1234567public final boolean dispatchPointerEvent(MotionEvent event) &#123; if (event.isTouchEvent()) &#123; return dispatchTouchEvent(event); &#125; else &#123; return dispatchGenericMotionEvent(event); &#125;&#125; DecorView的dispatchTouchEvent的实现如下，需要强调的是，DecorView是PhoneWindow的内部类，还记得前面提到的Window.Callback吗？没错，在下面的代码中，这个cb对象其实就是Activity，就这样点击事件就传递给了Activity了。 PhoneWindow#DecorView: 12345678910private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; ... @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; final Callback cb = getCallback(); return cb != null &amp;&amp; !isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev); &#125; ...&#125; Window:12345678910public void setCallback(Callback callback) &#123; mCallback = callback;&#125;/** * Return the current Callback interface for this window. */public final Callback getCallback() &#123; return mCallback;&#125; 这个mCallback就是前面Activity的attach方法里面调用的mWindow.setCallback(this) 这样点击事件就传给Activity了。 例子写一个简单的例子，验证下。选择一个View，重写其onTouchEvent方法，然后通过dumpStack方法来打印出当前线程的调用栈信息。 123456@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Log.d(TAG, \"onTouchEvent, ev=\" + event.getAction()); Thread.dumpStack(); return true;&#125; 选择Google nexus 6运行一下，log如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424306-22 13:25:21.368 7365 7365 D FrameLayoutEx: onTouchEvent, ev=006-22 13:25:21.368 7365 7365 W System.err: java.lang.Throwable: stack dump06-22 13:25:21.368 7365 7365 W System.err: at java.lang.Thread.dumpStack(Thread.java:490)06-22 13:25:21.368 7365 7365 W System.err: at com.ryg.reveallayout.ui.FrameLayoutEx.onTouchEvent(FrameLayoutEx.java:27)06-22 13:25:21.368 7365 7365 W System.err: at android.view.View.dispatchTouchEvent(View.java:9294)06-22 13:25:21.368 7365 7365 W System.err: at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2547)06-22 13:25:21.368 7365 7365 W System.err: at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2240)06-22 13:25:21.368 7365 7365 W System.err: at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2553)06-22 13:25:21.369 7365 7365 W System.err: at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2197)06-22 13:25:21.369 7365 7365 W System.err: at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2553)06-22 13:25:21.369 7365 7365 W System.err: at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2197)06-22 13:25:21.369 7365 7365 W System.err: at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:2553)06-22 13:25:21.369 7365 7365 W System.err: at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2197)06-22 13:25:21.369 7365 7365 W System.err: at com.android.internal.policy.PhoneWindow$DecorView.superDispatchTouchEvent(PhoneWindow.java:2403)06-22 13:25:21.369 7365 7365 W System.err: at com.android.internal.policy.PhoneWindow.superDispatchTouchEvent(PhoneWindow.java:1737)06-22 13:25:21.369 7365 7365 W System.err: at android.app.Activity.dispatchTouchEvent(Activity.java:2765)06-22 13:25:21.369 7365 7365 W System.err: at com.android.internal.policy.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:2364)06-22 13:25:21.369 7365 7365 W System.err: at android.view.View.dispatchPointerEvent(View.java:9514)06-22 13:25:21.369 7365 7365 W System.err: at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:4230)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4096)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3642)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3695)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3661)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3787)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3669)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:3844)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3642)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3695)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3661)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3669)06-22 13:25:21.370 7365 7365 W System.err: at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3642)06-22 13:25:21.371 7365 7365 W System.err: at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:5922)06-22 13:25:21.371 7365 7365 W System.err: at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:5896)06-22 13:25:21.371 7365 7365 W System.err: at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:5857)06-22 13:25:21.371 7365 7365 W System.err: at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:6025)06-22 13:25:21.371 7365 7365 W System.err: at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185)06-22 13:25:21.371 7365 7365 W System.err: at android.os.MessageQueue.nativePollOnce(Native Method)06-22 13:25:21.371 7365 7365 W System.err: at android.os.MessageQueue.next(MessageQueue.java:323)06-22 13:25:21.371 7365 7365 W System.err: at android.os.Looper.loop(Looper.java:135)06-22 13:25:21.371 7365 7365 W System.err: at android.app.ActivityThread.main(ActivityThread.java:5417)06-22 13:25:21.371 7365 7365 W System.err: at java.lang.reflect.Method.invoke(Native Method)06-22 13:25:21.371 7365 7365 W System.err: at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)06-22 13:25:21.371 7365 7365 W System.err: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) 通过上述log，大家不难看出MotionEvent的来源以及传递顺序，本文止。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"Events","slug":"Events","permalink":"http://www.heqingbao.net/tags/Events/"}]},{"title":"About Android Splash Screen","date":"2016-03-11T11:39:59.000Z","path":"2016/03/11/About-Android-Splash-Screen/","text":"在Android开发中，个人感觉有一个很影响体验的问题，那就是闪屏（这个词可能是从Splash Scrren翻译过来的）。 The launch screen is a user’s first experience of your application. 找两个例子对比一下先： 很明显Google Map的体验好一些。在好奇心的驱使下，反编译了Google Map，我们一起来看看它是怎样实现的。 首先看它的AndroidManifest.xml，看看它的Launcher Activity有没有什么特殊的配置。 123456789101112131415161718&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;application ...&gt; ... &lt;activity android:alwaysRetainTaskState=\"true\" android:configChanges=\"orientation|uiMode|screenSize|fontScale\" android:launchMode=\"singleTask\" android:name=\"com.google.android.maps.MapsActivity\" android:screenOrientation=\"user\" android:theme=\"@style/GmmTheme.SplashScreen\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;category android:name=\"android.intent.category.APP_MAPS\"/&gt; &lt;/intent-filter&gt; ... &lt;/application&gt;&lt;/manifest&gt; 可以看到Mapsactivity设置了一个SplashScreen的Theme： 12345678910&lt;resources&gt;... &lt;style name=\"GmmTheme\" parent=\"@android:style/Theme.Holo.Light.NoActionBar\"&gt; &lt;item name=\"android:textColorHint\"&gt;@color/no_type_grey&lt;/item&gt; &lt;/style&gt; &lt;style name=\"GmmTheme.SplashScreen\" parent=\"@style/GmmTheme\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/local_new_launchscreen_maps&lt;/item&gt; &lt;/style&gt;...&lt;/resources&gt; 接下来找到这个local_new_launchscreen_maps： 1234567891011121314&lt;layer-list android:opacity=\"opaque\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@android:color/white\" /&gt; &lt;item android:bottom=\"@dimen/launchscreens_product_logo_bottom\"&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@drawable/product_logo_maps_color_144\" /&gt; &lt;/item&gt; &lt;item android:bottom=\"@dimen/launchscreens_google_logo_bottom\"&gt; &lt;bitmap android:gravity=\"bottom|center\" android:src=\"@drawable/googlelogo_dark20_color_120x44\" /&gt; &lt;/item&gt;&lt;/layer-list&gt; 这里product_logo_maps_color_144.png是中间显示的类似App Logo，googlelogo_dark20_color_120x44.png自然是下面那个Google字样的图片了。 看到这里应该明白了。 关于闪屏，还可参考： https://www.youtube.com/watch?v=pEGWcMTxs3I&amp;feature=youtu.be&amp;t=1434 https://www.google.com/design/spec/patterns/launch-screens.html# http://www.cyrilmottier.com/2012/05/03/splash-screens-are-evil-dont-use-them/","tags":[{"name":"splash screen","slug":"splash-screen","permalink":"http://www.heqingbao.net/tags/splash-screen/"}]},{"title":"Difference between Overloading and Overriding in Java","date":"2016-03-01T04:29:57.000Z","path":"2016/03/01/Difference-between-Overloading-and-Overriding-in-Java/","text":"原文： http://java67.blogspot.jp/2012/09/difference-between-overloading-vs-overriding-in-java.html作者： Java67 第一个主要不同点是Overloading发生在编译时，而Overriding发生在运行时。 第二个不同点是，overload可以发生在同一个类中，而override只能发生在子类里面。 在Java里面，你可以overload静态方法，但是不能override静态方法。事实上当你在子类里面声明一个相同的方法，它只是隐藏而不是覆盖超类的方法。 Overloaded的方法结合使用静态绑定和使用类型的引用变量，而Overridden方法结合使用动态结合基于实际对象。（方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现） 在Java中Overloading和Overriding的规则是不同的。为了overload一个方法你需要改变方法的签名，但overriding是不需要的。 另一个不同点是，私有(private)和final方法不能被overridden，但是可以overloaded。 在Java里面，Overloaded方法比Overridden方法更快。 这是所有关于Java的方法重载和重写的区别。","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"Overloading","slug":"Overloading","permalink":"http://www.heqingbao.net/tags/Overloading/"},{"name":"Overriding","slug":"Overriding","permalink":"http://www.heqingbao.net/tags/Overriding/"}]},{"title":"Java并发编程：volatile关键字解析","date":"2016-02-29T11:11:19.000Z","path":"2016/02/29/Java-Volatile/","text":"原文： http://www.cnblogs.com/dolphin0520/p/3920373.html作者：海 子 内存模型的相关概念大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： 1i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。 比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 1）通过在总线加LOCK#锁的方式 2）通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 并发编程中的三个概念在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念： 原子性原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ 1i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。 可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 举个简单的例子，看下面这段代码： 123456//线程1执行的代码int i = 0;i = 10; //线程2执行的代码j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 有序性 有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码： 1234int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： 1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 Java内存模型在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。 在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。 Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。 举个简单的例子：在java中，执行下面这个语句： 1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？ 原子性 在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作： 1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 可见性 对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 有序性 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下happens-before原则（先行发生原则）： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条原则摘自《深入理解Java虚拟机》。 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。 深入剖析volatile关键字在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。 volatile关键字的两层语义 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行： 12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 volatile保证原子性吗？ 从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？ 下面看一个例子： 1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 把上面的代码改成以下任何一种都可以达到效果： 采用synchronized： 1234567891011121314151617181920212223public class Test &#123; public int inc = 0; public synchronized void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用Lock： 1234567891011121314151617181920212223242526272829public class Test &#123; public int inc = 0; Lock lock = new ReentrantLock(); public void increase() &#123; lock.lock(); try &#123; inc++; &#125; finally&#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用AtomicInteger： 1234567891011121314151617181920212223public class Test &#123; public AtomicInteger inc = new AtomicInteger(); public void increase() &#123; inc.getAndIncrement(); &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 volatile能保证有序性吗？ 在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 volatile的原理和实现机制 前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。 下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 2）它会强制将对缓存的修改操作立即写入主存； 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 使用volatile关键字的场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 1）对变量的写操作不依赖于当前值 2）该变量没有包含在具有其他变量的不变式中 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 下面列举几个Java中使用volatile的几个场景。 状态标记量123456789volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125; 12345678910volatile boolean inited = false;//线程1:context = loadContext(); inited = true; //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context); ###double check 1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 至于为何需要这么写请参考： 《Java 中的双重检查（Double-Check）》http://blog.csdn.net/dl88250/article/details/5439024 和http://www.iteye.com/topic/652440 参考资料： 《Java编程思想》 《深入理解Java虚拟机》 http://jiangzhengjun.iteye.com/blog/652532 http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html http://ifeve.com/volatile/ http://blog.csdn.net/ccit0519/article/details/11241403 http://blog.csdn.net/ns_code/article/details/17101369 http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html http://www.cppblog.com/elva/archive/2011/01/21/139019.html http://ifeve.com/volatile-array-visiblity/ http://www.bdqn.cn/news/201312/12579.shtml http://exploer.blog.51cto.com/7123589/1193399 http://www.cnblogs.com/Mainz/p/3556430.html","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"volatile","slug":"volatile","permalink":"http://www.heqingbao.net/tags/volatile/"}]},{"title":"Be Careful With Transient Data","date":"2016-02-29T09:06:03.000Z","path":"2016/02/29/Be-Careful-With-Transient-Data/","text":"原文：http://www.devx.com/tips/Tip/13726作者：Behrouz Fallahi Java序列化提供一种优雅的和易于使用的持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。 transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 看一下例子，假设我们定义一个类： 1234567891011121314151617181920212223242526public class LoggingInfo implements Serializable &#123; private static final long serialVersionUID = 7702603582718186313L; private Date loggingDate = new Date(); private String uid; private transient String pwd; LoggingInfo(String user, String password) &#123; uid = user; pwd = password; &#125; @Override public String toString() &#123; String password = null; if (pwd == null) &#123; password = \"NOT SET\"; &#125; else &#123; password = pwd; &#125; return \"logon info: \\n \" + \"user: \" + uid + \"\\n logging date : \" + loggingDate.toString() + \"\\n password: \" + password; &#125;&#125; 现在我们可以创建这个类的实例，并且序列化它，最后把序列化的对象写入到磁盘： 12345678910LoggingInfo logInfo = new LoggingInfo(\"MIKE\", \"MECHANICS\"); System.out.println(logInfo.toString()); try &#123; ObjectOutputStream o = new ObjectOutputStream( new FileOutputStream(\"logInfo.out\")); o.writeObject(logInfo); o.close(); &#125; catch(Exception e) &#123;//deal with exception&#125; 然后读取这个对象： 12345678try &#123; ObjectInputStream in =new ObjectInputStream( new FileInputStream(\"logInfo.out\")); LoggingInfo logInfo = (LoggingInfo)in.readObject(); System.out.println(logInfo.toString()); &#125; catch(Exception e) &#123;//deal with exception&#125; 完整的例子： 12345678910111213141516171819202122232425262728293031public class Client &#123; public static void main(String[] args) &#123; LoggingInfo logInfo = new LoggingInfo(\"MIKE\", \"MECHANICS\"); System.out.println(logInfo.toString()); ObjectOutputStream out = null; try &#123; out = new ObjectOutputStream(new FileOutputStream(\"logInfo.out\")); out.writeObject(logInfo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException ignore) &#123; &#125; &#125; &#125; ObjectInputStream in = null; try &#123; in = new ObjectInputStream(new FileInputStream(\"logInfo.out\")); LoggingInfo info = (LoggingInfo) in.readObject(); System.out.println(info); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出： 12345678logon info: user: MIKE logging date : Mon Feb 29 17:14:34 CST 2016 password: MECHANICSlogon info: user: MIKE logging date : Mon Feb 29 17:14:34 CST 2016 password: NOT SET 我们会注意到从磁盘中读回(read–back(de-serializing))的对象打印password为NOT SET。这是当我们定义pwd域为transient时，所期望的正确结果。 现在，让我们来看一下粗心对待transient域可能引起的潜在问题。假设我们修改了类定义，提供给transient域一个默认值： 123456789101112131415161718public class GuestLoggingInfo implements Serializable &#123; private static final long serialVersionUID = 7702603582718186313L; private Date loggingDate = new Date(); private String uid; private transient String pwd; GuestLoggingInfo() &#123; uid = \"guest\"; pwd = \"guest\"; &#125; @Override public String toString() &#123; // 跟上面一样 &#125;&#125; 现在如果我们串行化GuestLoggingInfo的一个实例，将它写入磁盘，并且再将它从磁盘中读出，我们仍然看到读回的对象打印password为NOT SET。当从磁盘中读出某个类的实例时，实际上并不会执行这个类的构造函数，而是载入了一个该类对象的持久化状态，并将这个状态赋值给该类的另一个对象。 补充结论1：静态变量不管是否被transient修饰，均不能被序列化。 还是上面的例子，只是给uid声明成static类型。 12345678910111213141516171819202122public class LoggingInfo implements Serializable &#123; private static final long serialVersionUID = 7702603582718186313L; private Date loggingDate = new Date(); private static String uid; private transient String pwd; LoggingInfo(String user, String password) &#123; uid = user; pwd = password; &#125; public void setUid(String uid) &#123; this.uid = uid; &#125; @Override public String toString() &#123; // 跟上面一样 &#125;&#125; Client不动，直接run后结果： 12345678logon info: user: MIKE logging date : Mon Feb 29 17:39:42 CST 2016 password: MECHANICSlogon info: user: MIKE logging date : Mon Feb 29 17:39:42 CST 2016 password: NOT SET 我们发现在uid字段前面加上static关键字后，程序运行结果依然不变，即static类型的uid也读出来为MIKE了，这不与上面的结论矛盾吗？ 实际上是这样的：上面的结论确实没错，反序列化后类中static变量uid的值为当前JVM中对应static变量的值，这个值是JVM的不是反序列化得出的。不相信？好吧，下面我来证明： 在Client类里面加上一行12345678910111213public class Client &#123; public static void main(String[] args) &#123; LoggingInfo logInfo = new LoggingInfo(\"MIKE\", \"MECHANICS\"); System.out.println(logInfo.toString()); // 序列化到磁盘，跟上面一样 logInfo.setUid(\"TOM\"); // 从磁盘中读取，跟上面一样 &#125;&#125; 输出：12345678logon info: user: MIKE logging date : Mon Feb 29 17:45:53 CST 2016 password: MECHANICSlogon info: user: TOM logging date : Mon Feb 29 17:45:53 CST 2016 password: NOT SET 从结果中可以看到，user的值为修改后的 TOM，而不是序列化时的MIKE。 结论2：被transient关键字修改的变量真的不能被序列化吗？ 123456789101112131415161718192021222324252627public class ExternalizableTest implements Externalizable &#123; private transient String content = \"我会被序列化\"; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(content); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; content = (String) in.readObject(); &#125; public static void main(String[] args) throws Exception &#123; ExternalizableTest et = new ExternalizableTest(); ObjectOutput out = new ObjectOutputStream(new FileOutputStream(new File(\"test\"))); out.writeObject(et); ObjectInput in = new ObjectInputStream(new FileInputStream(new File(\"test\"))); et = (ExternalizableTest) in.readObject(); System.out.println(et.content); out.close(); in.close(); &#125;&#125; 运行的结果是：1我会被序列化 这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？ 我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"transient","slug":"transient","permalink":"http://www.heqingbao.net/tags/transient/"}]},{"title":"三个线程，顺序打印ABC","date":"2016-02-29T05:32:08.000Z","path":"2016/02/29/Thread-ABC/","text":"三个线程，顺序打印ABC输出：123456789101112131415161718192021222324252627282930ABCABCABCABCABCABCABCABCABCABC 使用wait()和notify()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class ABC_1 &#123; private int status = 0; public static void main(String[] args) &#123; new ABC_1().setup(); &#125; private void setup() &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; printA(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; printB(); &#125; &#125; &#125;); Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; printC(); &#125; &#125; &#125;); t1.start(); t2.start(); t3.start(); &#125; private synchronized void printA() &#123; while (status % 3 != 0) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"A\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; status++; this.notifyAll(); &#125; private synchronized void printB() &#123; while (status % 3 != 1) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"B\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; status++; this.notifyAll(); &#125; private synchronized void printC() &#123; while (status % 3 != 2) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"C\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; status++; this.notifyAll(); &#125;&#125; 使用Lock和Condition123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ABC_2 &#123; private Lock lock = new ReentrantLock(); private Condition aCondition = lock.newCondition(); private Condition bCondition = lock.newCondition(); private Condition cCondition = lock.newCondition(); private int status = 0; public static void main(String[] args) &#123; new ABC_2().setup(); &#125; private void setup() &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; printA(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; printB(); &#125; &#125; &#125;); Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; printC(); &#125; &#125; &#125;); t1.start(); t2.start(); t3.start(); &#125; private void printA() &#123; lock.lock(); try &#123; while (status % 3 != 0) &#123; try &#123; aCondition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"A\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; status++; bCondition.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; private void printB() &#123; lock.lock(); try &#123; while (status % 3 != 1) &#123; try &#123; bCondition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"B\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; status++; cCondition.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; private void printC() &#123; lock.lock(); try &#123; while (status % 3 != 2) &#123; try &#123; cCondition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"C\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; status++; aCondition.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 使用Semaphore123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.util.concurrent.Semaphore;public class ABC_3 &#123; private Semaphore aSemaphore = new Semaphore(1); private Semaphore bSemaphore = new Semaphore(0); private Semaphore cSemaphore = new Semaphore(0); public static void main(String[] args) &#123; new ABC_3().setup(); &#125; private void setup() &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; printA(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; printB(); &#125; &#125; &#125;); Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; printC(); &#125; &#125; &#125;); t1.start(); t2.start(); t3.start(); &#125; private void printA() &#123; try &#123; aSemaphore.acquire(); System.out.println(\"A\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; bSemaphore.release(); &#125; catch (Exception e) &#123; e.printStackTrace(); aSemaphore.release(); &#125; &#125; private void printB() &#123; try &#123; bSemaphore.acquire(); System.out.println(\"B\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; cSemaphore.release(); &#125; catch (Exception e) &#123; e.printStackTrace(); bSemaphore.release(); &#125; &#125; private void printC() &#123; try &#123; cSemaphore.acquire(); System.out.println(\"C\"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; aSemaphore.release(); &#125; catch (Exception e) &#123; e.printStackTrace(); cSemaphore.release(); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"http://www.heqingbao.net/tags/Thread/"}]},{"title":"ReadWriteLock","date":"2016-02-29T05:03:28.000Z","path":"2016/02/29/ReadWriteLock/","text":"java.util.concurrent.locks.ReadWriteLock 是一个高级的线程锁机制，它允许多个线程来读取一个特定的资源，但在同一时间，只有能一个线程执行写操作。一个ReadWriteLock中保持一对相关的锁，一个用于只读操作，另一个用于写操作。在没有写操作的情况下，读锁(read lock)可以同时被多个线程执行。写锁(write lock)是排它性的。在成功获取读锁后所读到的数据都是最新的。 读锁可以允许多个进行读操作的线程同时进入，但不允许写进程进入 写锁只允许一个写进程进入，在这期间任何线程都不能再进入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; final Queue3 q3 = new Queue3(); for (int i = 0; i &lt; 3; i++) &#123; new Thread(\"Read Thread-\" + i) &#123; @Override public void run() &#123; while (true) &#123; q3.get(); &#125; &#125; &#125;.start(); new Thread(\"Write Thread-\" + i) &#123; @Override public void run() &#123; while (true) &#123; q3.put(new Random().nextInt(10000)); &#125; &#125; &#125;.start(); &#125; &#125; private static class Queue3 &#123; private Object data = null; ReadWriteLock rwl = new ReentrantReadWriteLock(); public void get() &#123; rwl.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + \" is ready to read data\"); Thread.sleep((long) (Math.random() * 1000)); System.out.println(Thread.currentThread().getName() + \" has been read data : \" + data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125; public void put(Object data) &#123; rwl.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + \" is ready to write data\"); Thread.sleep((long) (Math.random() * 1000)); this.data = data; System.out.println(Thread.currentThread().getName() + \" has been write data : \" + data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; rwl.writeLock().unlock(); &#125; &#125; &#125;&#125; 输出：1234567891011121314151617181920212223242526272829303132Read Thread-0 is ready to read dataRead Thread-1 is ready to read dataRead Thread-2 is ready to read dataRead Thread-2 has been read data : nullRead Thread-1 has been read data : nullRead Thread-0 has been read data : nullWrite Thread-0 is ready to write dataWrite Thread-0 has been write data : 577Write Thread-0 is ready to write dataWrite Thread-0 has been write data : 8005Write Thread-2 is ready to write dataWrite Thread-2 has been write data : 8935Write Thread-2 is ready to write dataWrite Thread-2 has been write data : 0Write Thread-2 is ready to write dataWrite Thread-2 has been write data : 5878Write Thread-1 is ready to write dataWrite Thread-1 has been write data : 963Write Thread-1 is ready to write dataWrite Thread-1 has been write data : 4703Write Thread-1 is ready to write dataWrite Thread-1 has been write data : 7550Read Thread-2 is ready to read dataRead Thread-1 is ready to read dataRead Thread-0 is ready to read dataRead Thread-1 has been read data : 7550Read Thread-2 has been read data : 7550Read Thread-0 has been read data : 7550Write Thread-0 is ready to write dataWrite Thread-0 has been write data : 1733Write Thread-0 is ready to write dataWrite Thread-0 has been write data : 6151 123456789101112131415161718192021222324252627282930313233class CachedData &#123; Object data; volatile boolean cacheValid; final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() &#123; rwl.readLock().lock(); if (!cacheValid) &#123; // Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); try &#123; // Recheck state because another thread might have // acquired write lock and changed state before we did. if (!cacheValid) &#123; data = ... cacheValid = true; &#125; // Downgrade by acquiring read lock before releasing write lock rwl.readLock().lock(); &#125; finally &#123; rwl.writeLock().unlock(); // Unlock write, still hold read &#125; &#125; try &#123; use(data); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125; &#125; 123456789101112131415161718192021222324252627class RWDictionary &#123; private final Map&lt;String, Data&gt; m = new TreeMap&lt;String, Data&gt;(); private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); private final Lock r = rwl.readLock(); private final Lock w = rwl.writeLock(); public Data get(String key) &#123; r.lock(); try &#123; return m.get(key); &#125; finally &#123; r.unlock(); &#125; &#125; public String[] allKeys() &#123; r.lock(); try &#123; return m.keySet().toArray(); &#125; finally &#123; r.unlock(); &#125; &#125; public Data put(String key, Data value) &#123; w.lock(); try &#123; return m.put(key, value); &#125; finally &#123; w.unlock(); &#125; &#125; public void clear() &#123; w.lock(); try &#123; m.clear(); &#125; finally &#123; w.unlock(); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"http://www.heqingbao.net/tags/Thread/"}]},{"title":"传统线程机制的回顾","date":"2016-02-28T16:02:13.000Z","path":"2016/02/29/Traditional-Thread/","text":"传统线程机制的回顾创建线程的两种传统方式 在Thread子类覆盖的run方法中编写运行代码 在传递给Thread对象的Runnable对象的run方法中编写代码 总结：查看Thread类的run方法的源代码可以看到，其实这两种方式都是在调用Thread对象的run方法，如果Thread类的run方法没有被覆盖，并且为该Thread对象设置了Runnable对象，该run方法会调用Runnable的run方法。 问题：如果在Thread子类覆盖的run方法中编写了运行代码，也为Thread子类对象传递了一个Runnable对象，那么，线程运行时的执行代码是子类的run方法还是Runnable的run方法？ 12345678910111213141516171819202122232425262728293031public class Thread implements Runnable &#123; /* What will be run. */ private Runnable target; public Thread() &#123; init(null, null, \"Thread-\" + nextThreadNum(), 0); &#125; public Thread(Runnable target) &#123; init(null, target, \"Thread-\" + nextThreadNum(), 0); &#125; private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123; init(g, target, name, stackSize, null); &#125; private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) &#123; ... this.target = target; ... &#125; @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125;&#125; 定时器的应用 Time类 TimeTask类 1234567891011121314151617181920212223242526272829303132333435363738/** * Schedules the specified task for execution after the specified delay. */public void schedule(TimerTask task, long delay) &#123;...&#125;/** * Schedules the specified task for execution at the specified time. If * the time is in the past, the task is scheduled for immediate execution. */public void schedule(TimerTask task, Date time) &#123;...&#125;/** * Schedules the specified task for repeated &lt;i&gt;fixed-delay execution&lt;/i&gt;, * beginning after the specified delay. Subsequent executions take place * at approximately regular intervals separated by the specified period. */public void schedule(TimerTask task, long delay, long period) &#123;...&#125;/** * Schedules the specified task for repeated &lt;i&gt;fixed-delay execution&lt;/i&gt;, * beginning at the specified time. Subsequent executions take place at * approximately regular intervals, separated by the specified period. */public void schedule(TimerTask task, Date firstTime, long period) &#123;...&#125;/** * Schedules the specified task for repeated &lt;i&gt;fixed-rate execution&lt;/i&gt;, * beginning after the specified delay. Subsequent executions take place * at approximately regular intervals, separated by the specified period. */public void scheduleAtFixedRate(TimerTask task, long delay, long period) &#123;...&#125;/** * Schedules the specified task for repeated &lt;i&gt;fixed-rate execution&lt;/i&gt;, * beginning at the specified time. Subsequent executions take place at * approximately regular intervals, separated by the specified period. */public void scheduleAtFixedRate(TimerTask task, Date firstTime, long period) &#123;...&#125; 线程的互斥与同步 使用synchronized代码块及其原理 使用synchronized方法(this) 分析静态方法所使用的同步监视器是什么(class)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class TraditionalThreadSynchronized &#123; public static void main(String[] args) &#123; new TraditionalThreadSynchronized().init(); &#125; private void init() &#123; final Outputer outputer = new Outputer(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; outputer.output(\"hello\"); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; outputer.output3(\"world\"); &#125; &#125; &#125;).start(); &#125; static class Outputer &#123; public void output(String name) &#123; int len = name.length(); synchronized (Outputer.class) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125; &#125; public synchronized void output2(String name) &#123; int len = name.length(); for (int i = 0; i &lt; len; i++) &#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125; public static synchronized void output3(String name) &#123; int len = name.length(); for (int i = 0; i &lt; len; i++) &#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125; &#125;&#125; wait与notify实现线程间的通信子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class TraditionalThreadCommunication &#123; public static void main(String[] args) &#123; final Business business = new Business(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 50; i++) &#123; business.sub(i); &#125; &#125; &#125;).start(); for (int i = 1; i &lt;= 50; i++) &#123; business.main(i); &#125; &#125;&#125;class Business &#123; private boolean bShouldSub = true; public synchronized void sub(int i) &#123; while (!bShouldSub) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for (int j = 1; j &lt;= 10; j++) &#123; System.out.println(\"sub thread sequence of \" + j + \",loop of \" + i); &#125; bShouldSub = false; this.notify(); &#125; public synchronized void main(int i) &#123; while (bShouldSub) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for (int j = 1; j &lt;= 100; j++) &#123; System.out.println(\"main thread sequence of \" + j + \",loop of \" + i); &#125; bShouldSub = true; this.notify(); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"Thead","slug":"Thead","permalink":"http://www.heqingbao.net/tags/Thead/"}]},{"title":"Java理论与实践：处理InterruptedException","date":"2016-02-23T14:43:14.000Z","path":"2016/02/23/Dealing-with-InterruptedException/","text":"原文 http://www.ibm.com/developerworks/cn/java/j-jtp05236.html#ibm-pcon作者 Brian Goetz (brian@quiotix.com), 首席顾问, Quiotix 很多 Java™ 语言方法，例如 Thread.sleep() 和 Object.wait()，都可以抛出 InterruptedException。您不能忽略这个异常，因为它是一个检查异常（checked exception）。但是应该如何处理它呢？在本月的 Java 理论与实践中，并发专家 Brian Goetz 将解释 InterruptedException 的含义，为什么会抛出 InterruptedException，以及在捕捉到该异常时应该怎么做。 这样的情景您也许并不陌生：您在编写一个测试程序，程序需要暂停一段时间，于是调用 Thread.sleep()。但是编译器或 IDE 报错说没有处理检查到的 InterruptedException。InterruptedException 是什么呢，为什么必须处理它？ 对于 InterruptedException，一种常见的处理方式是 “生吞（swallow）” 它 —— 捕捉它，然后什么也不做（或者记录下它，不过这也好不到哪去）—— 就像后面的 清单 4 一样。不幸的是，这种方法忽略了这样一个事实：这期间可能发生中断，而中断可能导致应用程序丧失及时取消活动或关闭的能力。 阻塞方法当一个方法抛出 InterruptedException 时，它不仅告诉您它可以抛出一个特定的检查异常，而且还告诉您其他一些事情。例如，它告诉您它是一个阻塞（blocking）方法，如果您响应得当的话，它将尝试消除阻塞并尽早返回。 阻塞方法不同于一般的要运行较长时间的方法。一般方法的完成只取决于它所要做的事情，以及是否有足够多可用的计算资源（CPU 周期和内存）。而阻塞方法的完成还取决于一些外部的事件，例如计时器到期，I/O 完成，或者另一个线程的动作（释放一个锁，设置一个标志，或者将一个任务放在一个工作队列中）。一般方法在它们的工作做完后即可结束，而阻塞方法较难于预测，因为它们取决于外部事件。阻塞方法可能影响响应能力，因为难于预测它们何时会结束。 阻塞方法可能因为等不到所等的事件而无法终止，因此令阻塞方法可取消 就非常有用（如果长时间运行的非阻塞方法是可取消的，那么通常也非常有用）。可取消操作是指能从外部使之在正常完成之前终止的操作。由 Thread 提供并受 Thread.sleep() 和 Object.wait() 支持的中断机制就是一种取消机制；它允许一个线程请求另一个线程停止它正在做的事情。当一个方法抛出 InterruptedException 时，它是在告诉您，如果执行该方法的线程被中断，它将尝试停止它正在做的事情而提前返回，并通过抛出 InterruptedException 表明它提前返回。 行为良好的阻塞库方法应该能对中断作出响应并抛出 InterruptedException，以便能够用于可取消活动中，而不至于影响响应。 线程中断每个线程都有一个与之相关联的 Boolean 属性，用于表示线程的中断状态（interrupted status）。中断状态初始时为 false；当另一个线程通过调用 Thread.interrupt() 中断一个线程时，会出现以下两种情况之一。如果那个线程在执行一个低级可中断阻塞方法，例如 Thread.sleep()、 Thread.join() 或 Object.wait()，那么它将取消阻塞并抛出 InterruptedException。否则， interrupt() 只是设置线程的中断状态。 在被中断线程中运行的代码以后可以轮询中断状态，看看它是否被请求停止正在做的事情。中断状态可以通过 Thread.isInterrupted() 来读取，并且可以通过一个名为 Thread.interrupted() 的操作读取和清除。 中断是一种协作机制。当一个线程中断另一个线程时，被中断的线程不一定要立即停止正在做的事情。相反，中断是礼貌地请求另一个线程在它愿意并且方便的时候停止它正在做的事情。有些方法，例如 Thread.sleep()，很认真地对待这样的请求，但每个方法不是一定要对中断作出响应。对于中断请求，不阻塞但是仍然要花较长时间执行的方法可以轮询中断状态，并在被中断的时候提前返回。 您可以随意忽略中断请求，但是这样做的话会影响响应。 中断的协作特性所带来的一个好处是，它为安全地构造可取消活动提供更大的灵活性。我们很少希望一个活动立即停止；如果活动在正在进行更新的时候被取消，那么程序数据结构可能处于不一致状态。中断允许一个可取消活动来清理正在进行的工作，恢复不变量，通知其他活动它要被取消，然后才终止。 处理 InterruptedException如果抛出 InterruptedException 意味着一个方法是阻塞方法，那么调用一个阻塞方法则意味着您的方法也是一个阻塞方法，而且您应该有某种策略来处理 InterruptedException。通常最容易的策略是自己抛出 InterruptedException，如清单 1 中 putTask() 和 getTask() 方法中的代码所示。 这样做可以使方法对中断作出响应，并且只需将 InterruptedException 添加到 throws 子句。 清单 1. 不捕捉 InterruptedException，将它传播给调用者 1234567891011121314public class TaskQueue &#123; private static final int MAX_TASKS = 1000; private BlockingQueue&lt;Task&gt; queue = new LinkedBlockingQueue&lt;Task&gt;(MAX_TASKS); public void putTask(Task r) throws InterruptedException &#123; queue.put(r); &#125; public Task getTask() throws InterruptedException &#123; return queue.take(); &#125;&#125; 有时候需要在传播异常之前进行一些清理工作。在这种情况下，可以捕捉 InterruptedException，执行清理，然后抛出异常。清单 2 演示了这种技术，该代码是用于匹配在线游戏服务中的玩家的一种机制。 matchPlayers() 方法等待两个玩家到来，然后开始一个新游戏。如果在一个玩家已到来，但是另一个玩家仍未到来之际该方法被中断，那么它会将那个玩家放回队列中，然后重新抛出 InterruptedException，这样那个玩家对游戏的请求就不至于丢失。 清单 2. 在重新抛出 InterruptedException 之前执行特定于任务的清理工作 123456789101112131415161718192021222324252627public class PlayerMatcher &#123; private PlayerSource players; public PlayerMatcher(PlayerSource players) &#123; this.players = players; &#125; public void matchPlayers() throws InterruptedException &#123; try &#123; Player playerOne, playerTwo; while (true) &#123; playerOne = playerTwo = null; // Wait for two players to arrive and start a new game playerOne = players.waitForPlayer(); // could throw IE playerTwo = players.waitForPlayer(); // could throw IE startNewGame(playerOne, playerTwo); &#125; &#125; catch (InterruptedException e) &#123; // If we got one player and were interrupted, put that player back if (playerOne != null) players.addFirst(playerOne); // Then propagate the exception throw e; &#125; &#125;&#125; 不要生吞中断有时候抛出 InterruptedException 并不合适，例如当由 Runnable 定义的任务调用一个可中断的方法时，就是如此。在这种情况下，不能重新抛出 InterruptedException，但是您也不想什么都不做。当一个阻塞方法检测到中断并抛出 InterruptedException 时，它清除中断状态。如果捕捉到 InterruptedException 但是不能重新抛出它，那么应该保留中断发生的证据，以便调用栈中更高层的代码能知道中断，并对中断作出响应。该任务可以通过调用 interrupt() 以 “重新中断” 当前线程来完成，如清单 3 所示。至少，每当捕捉到 InterruptedException 并且不重新抛出它时，就在返回之前重新中断当前线程。 清单 3. 捕捉 InterruptedException 后恢复中断状态 1234567891011121314151617181920public class TaskRunner implements Runnable &#123; private BlockingQueue&lt;Task&gt; queue; public TaskRunner(BlockingQueue&lt;Task&gt; queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; while (true) &#123; Task task = queue.take(10, TimeUnit.SECONDS); task.execute(); &#125; &#125; catch (InterruptedException e) &#123; // Restore the interrupted status Thread.currentThread().interrupt(); &#125; &#125;&#125; 处理 InterruptedException 时采取的最糟糕的做法是生吞它 —— 捕捉它，然后既不重新抛出它，也不重新断言线程的中断状态。对于不知如何处理的异常，最标准的处理方法是捕捉它，然后记录下它，但是这种方法仍然无异于生吞中断，因为调用栈中更高层的代码还是无法获得关于该异常的信息。（仅仅记录 InterruptedException 也不是明智的做法，因为等到人来读取日志的时候，再来对它作出处理就为时已晚了。） 清单 4 展示了一种使用得很广泛的模式，这也是生吞中断的一种模式： 清单 4. 生吞中断 —— 不要这么做 1234567891011121314151617181920// Don't do this public class TaskRunner implements Runnable &#123; private BlockingQueue&lt;Task&gt; queue; public TaskRunner(BlockingQueue&lt;Task&gt; queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; while (true) &#123; Task task = queue.take(10, TimeUnit.SECONDS); task.execute(); &#125; &#125; catch (InterruptedException swallowed) &#123; /* DON'T DO THIS - RESTORE THE INTERRUPTED STATUS INSTEAD */ &#125; &#125;&#125; 如果不能重新抛出 InterruptedException，不管您是否计划处理中断请求，仍然需要重新中断当前线程，因为一个中断请求可能有多个 “接收者”。标准线程池 （ThreadPoolExecutor）worker 线程实现负责中断，因此中断一个运行在线程池中的任务可以起到双重效果，一是取消任务，二是通知执行线程线程池正要关闭。如果任务生吞中断请求，则 worker 线程将不知道有一个被请求的中断，从而耽误应用程序或服务的关闭。 实现可取消任务语言规范中并没有为中断提供特定的语义，但是在较大的程序中，难于维护除取消外的任何中断语义。取决于是什么活动，用户可以通过一个 GUI 或通过网络机制，例如 JMX 或 Web 服务来请求取消。程序逻辑也可以请求取消。例如，一个 Web 爬行器（crawler）如果检测到磁盘已满，它会自动关闭自己，否则一个并行算法会启动多个线程来搜索解决方案空间的不同区域，一旦其中一个线程找到一个解决方案，就取消那些线程。 仅仅因为一个任务是可取消的，并不意味着需要立即 对中断请求作出响应。对于执行一个循环中的代码的任务，通常只需为每一个循环迭代检查一次中断。取决于循环执行的时间有多长，任何代码可能要花一些时间才能注意到线程已经被中断（或者是通过调用 Thread.isInterrupted() 方法轮询中断状态，或者是调用一个阻塞方法）。 如果任务需要提高响应能力，那么它可以更频繁地轮询中断状态。阻塞方法通常在入口就立即轮询中断状态，并且，如果它被设置来改善响应能力，那么还会抛出 InterruptedException。 惟一可以生吞中断的时候是您知道线程正要退出。只有当调用可中断方法的类是 Thread 的一部分，而不是 Runnable 或通用库代码的情况下，才会发生这样的场景，清单 5 演示了这种情况。清单 5 创建一个线程，该线程列举素数，直到被中断，这里还允许该线程在被中断时退出。用于搜索素数的循环在两个地方检查是否有中断：一处是在 while 循环的头部轮询 isInterrupted() 方法，另一处是调用阻塞方法 BlockingQueue.put()。 清单 5. 如果知道线程正要退出的话，则可以生吞中断12345678910111213141516171819public class PrimeProducer extends Thread &#123; private final BlockingQueue&lt;BigInteger&gt; queue; PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; BigInteger p = BigInteger.ONE; while (!Thread.currentThread().isInterrupted()) queue.put(p = p.nextProbablePrime()); &#125; catch (InterruptedException consumed) &#123; /* Allow thread to exit */ &#125; &#125; public void cancel() &#123; interrupt(); &#125;&#125; 不可中断的阻塞方法并非所有的阻塞方法都抛出 InterruptedException。输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会提前返回。然而，对于套接字 I/O，如果一个线程关闭套接字，则那个套接字上的阻塞 I/O 操作将提前结束，并抛出一个 SocketException。java.nio 中的非阻塞 I/O 类也不支持可中断 I/O，但是同样可以通过关闭通道或者请求 Selector 上的唤醒来取消阻塞操作。类似地，尝试获取一个内部锁的操作（进入一个 synchronized 块）是不能被中断的，但是 ReentrantLock 支持可中断的获取模式。 不可取消的任务有些任务拒绝被中断，这使得它们是不可取消的。但是，即使是不可取消的任务也应该尝试保留中断状态，以防在不可取消的任务结束之后，调用栈上更高层的代码需要对中断进行处理。清单 6 展示了一个方法，该方法等待一个阻塞队列，直到队列中出现一个可用项目，而不管它是否被中断。为了方便他人，它在结束后在一个 finally 块中恢复中断状态，以免剥夺中断请求的调用者的权利。（它不能在更早的时候恢复中断状态，因为那将导致无限循环 —— BlockingQueue.take() 将在入口处立即轮询中断状态，并且，如果发现中断状态集，就会抛出 InterruptedException。） 清单 6. 在返回前恢复中断状态的不可取消任务 12345678910111213141516public Task getNextTask(BlockingQueue&lt;Task&gt; queue) &#123; boolean interrupted = false; try &#123; while (true) &#123; try &#123; return queue.take(); &#125; catch (InterruptedException e) &#123; interrupted = true; // fall through and retry &#125; &#125; &#125; finally &#123; if (interrupted) Thread.currentThread().interrupt(); &#125;&#125; 结束语您可以用 Java 平台提供的协作中断机制来构造灵活的取消策略。各活动可以自行决定它们是可取消的还是不可取消的，以及如何对中断作出响应，如果立即返回会危害应用程序完整性的话，它们还可以推迟中断。即使您想在代码中完全忽略中断，也应该确保在捕捉到 InterruptedException 但是没有重新抛出它的情况下，恢复中断状态，以免调用它的代码无法获知中断的发生。 参考资料 您可以参阅本文在 developerWorks 全球站点上的 英文原文。 Java 2 Platform API Specifications：用于 Java 2 Platform, Standard Edition, version 1.4.2 的 API 规范。 Java Concurrency in Practice（Addison-Wesley Professional，作者 Brian Goetz、Tim Peierls、Joshua Bloch、Joseph Bowbeer、David Holmes 和 Doug Lea，2006 年 6 月）：这个关于用 Java 语言开发并发程序的入门手册的第 7 章更深入地谈到了中断和取消的细节。 Java 理论与实践：Brian Goetz 撰写的完整系列。 Java 技术专区：这里有数百篇关于 Java 编程各方面的文章。","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"InterruptedException","slug":"InterruptedException","permalink":"http://www.heqingbao.net/tags/InterruptedException/"}]},{"title":"理解 Java 垃圾回收机制","date":"2016-02-15T13:55:40.000Z","path":"2016/02/15/Java-GC/","text":"原文 http://www.cubrid.org/blog/dev-platform/understanding-java-garbage-collection/作者 Sangmin Lee NHN公司，性能设计实验室高级工程师 理解java垃圾回收机制有什么好处呢？作为一个软件工程师，满足自己的好奇心将是一个很好的理由，不过更重要的是，理解GC的工作机制可以帮助你写出更好的Java程序。 这是我个人的主观观点，但我相信一个人精通了GC，往往会是一个更好的Java程序员。如果你对GC感兴趣，那就意味着你有一定大规模应用开发的经验。如果你已经仔细考虑选择合适的GC算法，这意味着你完全理解你开发的应用程序的功能。当然，这可能不是一个优秀开发者的共同标准。然而，很少有人反对我说的：理解GC是成为一个伟大的Java开发人员的要求。 这是“成为一个Java GC专家”系列文章的第一部分。这次我将讲述GC简介，而在下一篇文章中，我将讨论分析GC状态和来自NHN的GC调优的例子。 本文的目的是用简单的方式向你介绍GC。我希望这篇文章被证明是非常有帮助的。事实上，我的同事已经发表了一些关于Java内部机制的文章，它们已经在Twitter上变得很流行，你可以去看看。 回到GC，在学习GC之前，你应该知道一个技术名词，这个词是”stop-the-world”，无论你选择哪个算法，Stop-the-world都会发生。这意味着JVM停止应用程序，进而运行GC。当stop-the-world发生时，除了垃圾回收线程，其它所有线程都将停止运行。被中断的任务GC执行完成后恢复，GC调优往往意味着减少stop-the-world的时间。 分代垃圾收集在程序中，Java没有明确地指定分配内存和删除内存的方法，一些开发人员将相关对象设置为null或者使用System.gc()方法来显式地删除内存。设置为null不是一个大问题，但是调用System.gc()方法会大幅影响系统性能，一定不要这样做。（值得庆幸的是，我还没有看到在NHN的任何开发者调用这个方法） 在Java程序里面，开发者不会显式地删除内存，垃圾收集器会找到没有必要（垃圾）对象，然后删除它们。这个垃圾回收器被创建基于以下两个假设。（称为它们为前提条件更好，而不是假设） 大多数对象很快变得不可达 只有少量年老对象引用年轻对象 这些假设被称为弱代假设(weak generational hypothesis)。为了发挥这一假设的优势，在HotSpot虚拟机中，物理地将内存分为两个——年轻代(young generation)和年老代(old generation)。 年轻代：大多数新创建的对象被分配到这里。因为大多数对象很快变得不可达，所以很多对象在年轻代中创建，然后消失。当对象从这个区域消失时，我们说一个”minor GC“发生了。 年老代：这些对象没有变得不可达，从年轻代幸存下来的对象被复制到这里。一般比年轻代更大。因为它的规模大，GC比年轻代发生的频率更低。当对象从年老代消失，我们说一个”major GC“(或者一个”full GC“)发生了。 让我们来看看这个图： 上图中的永久代(permanent generation)也叫做”方法区(method area)“，它存储class对象和字符串常量（it stores classes or interned character strings），因此这块内存区域绝对不是永久地存放从年老代存活下来的对象。GC也可能发生在这个区域，发生在这里的垃圾回收也称为major GC。 一些人可能会问： 如果一个年老代的对象需要引用一个年轻代的对象怎么办？ 为了解决这个问题，在年老代中有一个叫做”卡表(card table)”的东西，它是一个512字节的块，每当在年老代中的一个对象引用年轻代中的对象，它记录在此表中。当对年轻代执行GC的时候，只需要对这张表进行搜索以确定是否需要进行垃圾回收，而不是检查所有年老代中所有对象的引用。这张表被”写闸(write barrier)”管理。写闸是一种装置，对minor GC有更快的性能。虽然这种机制会产生一些时间性能开销，但降低了整体的GC时间。 年轻代组成部分为了理解GC，我们学习一下年轻代，对象第一次创建发生在这块区域。年轻代分为3块。 Eden区 2个Survivor区 总共三个区，两个Survivor区。各个区的执行顺序如下： 绝大多数新创建的对象分配在Eden区 在Eden发生一次GC后，存活的对象移动到其中一个Survivor区 在Eden发生一次GC后，对象是存放到Survivor区，这个Survivor区已经存在其它存活的对象。 一旦一个Survivor已满，存活的对象移动到另外一个Survivor区。然后之前那个已满的Survivor区将置空，没有任何数据。 经过重复多次这样的步骤后依旧存活的对象被移到年老代。 正如你所看到的这些步骤，一个Survivor区必须保持为空。如果两个Survivor区都有数据，或者两个都没有使用，你可将这个情况作为系统错误的一个标志。 经过多次minor GC，数据被转移到年老代的过程如下图所示： 请注意，在HotSpot虚拟机中，使用两种技术加快内存的分配。一个被称为“指针碰撞(bump-the-pointer)”，另外一个被称为“TLABs（线程本地分配缓冲）”。 指针碰撞技术跟踪分配给Eden区上最新的对象。该对象将位于Eden区的顶部。如果之后有一个对象创建，只需检查Eden区是否有足够大的空间存放该对象。如果空间够用，它将被放置在Eden区，存放在空间的顶部。因此，在创建新对象时，只需检查最后被添加的对象，看是否还有更多的内存空间允许分配。然而，如果考虑多线程环境，则是另外一种情况。为了实现多线程环境下，在Eden区线程安全的去创建保存对象，那么必须加锁，因此性能会下降。在HotSpot虚拟机中TLABs能够解决这一问题。它允许每个线程在Eden区有自己的一小块私有空间。因为每个一个线程只能访问自己的TLAB，所以在这个区域甚至可以使用无锁的指针碰撞技术进行内存分配。 我们已经对年轻代有了一个快速的浏览，你不需要记住我刚才提到的两种技术。即便你不知道他们，也不会怎样。但请务必记住：对象第一次被创建发生在Eden区，长期存活的对象被从Survivor区移动到年老代。 老年代GC当年老代数据满时，基本上会执行一次GC。执行程序根据不同GC类型而变化，所以知道不同类型的垃圾收集器，会更容易理解垃圾回收过程。 在JDK7中，有5种垃圾收集器： Serial GC Parallel GC Parallel Old GC (Parallel Compacting GC) Concurrent Mark &amp; Sweep GC (or “CMS”) Garbage First (G1) GC 其中，serial GC 不能用于服务端，这个收集器类型仅应用于单核CPU桌面电脑。使用serial收集器会显著降低应用程序的性能。 现在让我们来了解每个收集器类型。 Serial GC (-XX:+UseSerialGC) 我们在前一段的解释了在年轻代发生的垃圾回收算法类型，在老年代的GC使用算法被称为”标记——清除——整理“。 该算法的第一步是在年老代标记存活的对象。（标记） 然后从头开始检查堆内存空间，只留下依然幸存的对象。（清除） 最后一步，从头开始，顺序地填满堆内存空间，将存活的对象连续放在一起，这样堆分成两部分：一边有存放对象，一边没有对象（整理） serial收集器应用于小内存和少量的CPU。 Parallel GC (-XX:+UseParallelGC) 从这幅图中，你可以很容易地看到Serial收集器和Parallel收集器的差异。serial收集器只使用一个线程来处理GC，而parallel收集器使用多线程并行处理GC，因此更快。当有足够大的内存和大量芯数时，parallel收集器是有用的。它也被称淡”吞吐量优先垃圾收集器(throughput GC)”。 Parallel Old GC(-XX:+UseParallelOldGC) Parallel Old收集器是自JDK5开始支持的。相比于parallel收集器，它们的唯一区别就是在年老代所执行GC的算法不同。它执行三个步骤：标记——汇总——压缩(mark – summary – compaction)。汇总步骤与清理的不同之处在于，其将依然幸存的对象分发到GC预先处理好的不同区域(The summary step identifies the surviving objects separately for the areas that the GC have previously performed)，算法相对清理来说略微复杂一点。 CMS GC (-XX:+UseConcMarkSweepGC) 如你在上图看到的那样，CMS垃圾收集器比之前我解释的各种算法都要复杂很多。初始标记(inital mark)比较简单。这一步骤只是查找距离类加载器最近的幸存对象。所以停顿时间非常短，之后的并发标记步骤，所有被幸存对象引用的对象会被确认是否已经被追踪检查。这一步不同之处在于，在标记的过程中，其它线程依然在执行。在重新标记步骤会修正那些在并发标记步骤中，因新增或者删除对象而导致变动的那部分标记记录。最后，在并发清除步骤，垃圾收集器执行。垃圾收集器进行垃圾收集时，其它线程依旧在工作。一旦采取了这种GC类型，由于垃圾回收导致的停顿时间会极其短暂。CMS收集器也被称为低延迟垃圾收集器。它经常被用在那些对于响应时间要求十分苛刻的应用上。 当然，这种GC类型在拥有stop-the-word时间很短的优点同时，也有如下缺点： 它会比其它GC类型占用更多的内存和CPU 默认情况下不支持压缩步骤 在使用这个GC类型之前你需要慎重考虑。如果因为内存碎片过多而导致压缩任务不得不执行，那么stop-the-word的时间要比其它任何GC类型都长，你需要考虑压缩任务的发生频率以及执行时间。 G1 GC 最后，我们来学习一下G1类型 如果你想要理解G1收集器，首先你要忘记你所理解的年轻代和年老代。正如你在上图所看到的，每个对象被分配到不同的网格中，随后执行垃圾回收。当一个区域填满之后，对象被转移到另一个区域，并再执行一次垃圾回收。在这种垃圾回收算法中，不再有从年轻代移动到年老代的三部曲。这个类型的垃圾收集算法是为替代CMS收集器而被创建的，因为CMS收集器在长时间持续运行时会产生很多问题。 G1的最大好处是它的性能，它比我们在上面讨论过的任何一种GC都要快。但是在JDK6中，他还只是一个早期试用版本。在JDK7之后才由官方正式发布。就我个人看来，NHN在将JDK7正式投入商用之前需要很长的一段测试期（至少一年）。因此你可能需要再等一段时间。并且，我也听过几次使用了JDK6中的G1而导致Java虚拟机宕机的事件。请耐心的等待它更稳定吧。 下一次我将讨论GC优化相关的问题，但是在此之前我要先明确一件事件。假如应用中创建的所有对象的大小和类型都是统一的，在我们公司，这种情况下使用的WAS的GC参数可以是相同的。但是WAS所创建对象的大小和生命周期根据服务以及硬件的不同而不同。换句话说，不能因为某个应用使用的GC参数是”A”，就说明同样的参数也能给其它服务带来最佳的效果。而是要因地制宜，有的放矢。我们需要找到适合每个WAS线程的最佳参数，并且持续的监控和优化每个设备上的WAS实例。这并不是我的一家之谈，而是负责Oracle Java虚拟机研发的工程师在JavaOne 2010上已经讨论过的。 本文中我们简略地介绍了Java的垃圾回收机制，请继续关注我们的后续文章，我们会讨论如何监控Java GC状态以及GC调优。 另外我特别推荐一本2011年12月发布的”Java Performance“(Amazon，如果公司提供一个账户，它可以使用Safari在线阅读)，还有在Oracle官网发布的白皮书”Memory Management in the Java HotSpotTM Virtual Machine,“（这本书与”Java Performance Tuning“不是同一本）","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"GC","slug":"GC","permalink":"http://www.heqingbao.net/tags/GC/"}]},{"title":"《Java编程思想》笔记（第5章 初始化与清理）","date":"2016-02-14T09:22:25.000Z","path":"2016/02/14/Think_in_Java-notes-Initialization & Cleanup/","text":"第五章 初始化与清理清理：终结处理与垃圾回收 程序员都了解初始化的重要性，但常常会忘记同样也重要的清理工作。毕竟，谁需要清理一个int呢？但在使用程序库时，把一个对象用完后就“弃之不顾”的做法并非总是安全的。当然Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象（并非使用new）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象这块“特殊”内存。为了应对这样的情况，Java允许在类中定义一个名为finalize()的方法。它的工作原理“假定”是这样的：一旦垃圾回收准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。 这里有一个潜在的编程陷阱，因为有些程序员（特别是C++程序员）刚开始可能会误把finalize()当作C++的析构函数（C++中销毁对象必须用到这个函数）。所以有必要明确区分一下：在C++中，对象一定会被销毁（如果程序中没有缺陷的话）；而Java里面的对象却并非总是被垃圾回收。或者换句话说： 对象可能不被垃圾回收 垃圾回收并不等于“析构” 牢记这些，就能远离困扰。这意味着在你不需要某个对象之前，如果必须执行某些动作，那么你得自己去做。Java并未提供“析构函数”或相似的概念，要做类似的清理工作，必须自己动手创建一个执行清理工作的普通方法。例如，假设某个对象在创建过程中将自己绘制到屏幕上，如果不是明确地从屏蔽上将其擦除，它可能永远得不到清理。如果在finalize()里加加入某种擦除功能，当“垃圾回收”发生时（不能保证一定会发生），finalize()得到了调用，图片就会被擦除。要是“垃圾回收”没有发生，图像就会一直保留一下来。 也许你会发现，只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，并且垃圾回收器一直都没有释放你创建的任何对象的存在空间，则随着程序的退出，那些资源也会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付部分开销了。 finalize()的用途何在 此时，读者已经明白了不该将finalize()作为通用的清理方法。那么，finalize()的真正用途是什么呢？ 这里引出要记住的第三点： 3.垃圾回收只与内存有关。 也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），它们必须同内存及其回收有关。 但这是否意味着要是对象中含有其它对象，finalize()就应该明确释放那些对象呢？不，无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这就将对finalize()的需求限制到一种特殊的情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。不过，读者也看到了，Java中一切皆为对象，那这种特殊情况是怎么回事呢？ 看来之所以要有finalize()，是由于在分配内存时可能彩了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。本地方法目前只支持C和C++，但它们可以调用其它语言写的代码，所以实际上可以调用任何代码。在非Java代码中，也许会调用C的malloc()函数系列来分配存储空间，而且除非调用free()函数，否则存储空间将得不到释放，从而千万内存泄露。当然free()是C和C++中的函数，所以需要在finalize()中用本地方法调用它。 垃圾回收器如何工作 在以前所用过的程序语言中，在堆上分配对象的代价十分高昂，因此读者自然会觉得Java中所有对象（基本类型除外）都在堆上分配的方式也非常高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。听起来很奇怪——存储空间的释放竟然会影响存储空间的分配，但这确实是某些Java虚拟机的工作方式。这也意味着，Java从堆分配空间的咁速度，可以和其它语言从堆栈上分配空间的速度相媲美。 要想更好地理解Java中的垃圾回收，先了解其它系统中的垃圾回收机制将会很有帮助。引用记数是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用记数器当有引用 连接至对象时，引用计数加1。当引用离开作用域或被置为null时，引用记数减1。虽然管理引用记数的开销不大，但这项开销在整个程序生命周期中将持续发生。垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占用的空间（但是，引用记数模式经常会在记数值变为0时立即释放对象）。这种方法有个缺陷，如果对象之间存在循环引用，可交互自引用的对象组所需要的工作量极大。引用记数常用来说明垃圾回收的工作方式，但似乎从未被应用于任何一种Java虚拟机实现。 在一些更快的模式中，垃圾回收器并非基于引用记数技术。它们依据的思想是：对任何“活“的对象，一定能最终追溯到其存在堆栈或静态存储区之中的引用。这个引用链条可能会穿过数个对象层次。由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“活”的对象。对发现的每个引用，必须追踪它所引用的对象，然后是此对象包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。你所访问过的对象必须都是“活”的。注意，这就解决了“交互自引用的对象组”的问题——这种现象根本不会被发现，因此也就被自动回收了。 在这种方式下，Java虚拟机将可采用一种自适应的垃圾回收技术。至于如何处理找到的存活对象，取决于不同的Java虚拟机实现。有一种做法名为停止—复制。显然这意味着，先暂停程序的运行（所以它不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。当对象被复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列，然后就可以按前述方法简单、直接地分配新空间了。 当把对象从一处搬到另一处时，所有指向它的那些引用都必须修正。位于堆或静态存储区的引用可以直接被修正，但可能还有其它其它指向这些对象的引用，它们在遍历的过程中才能被找到（可以想像成有个表格，将旧地址映射到新地址）。 对于这种所谓的复制式回收器而言，效率会降低，这有两个原因，首先，得有两个堆，然后得在这两个分离的堆之间来回捣腾，从而得维护比实际需要多一倍的空间。某些Java虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。 第二个问题在于复制。程序进入稳定状态之后，可能只会产生觉得是垃圾。甚至没有垃圾。尽管如此，复制式回收器仍然会将所有存储自一处复制到另一处，这很浪费。为了避免这种买情形，一些Java虚拟机会进行检查：要是没有新垃圾产生，就会转换到另一种工作模式（即自适应）。这种模式称为标记-清扫，Sun公司早期版本的Java虚拟机使用了这种技术。对一般用途而言，标记-清扫方式速度相当慢，但是当你知道只会产生少量垃圾甚至不会产生垃圾时，它的速度就很快了。 标记-清扫所依据的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的的对象。每当它找到一个存活的对象，就会给对象设一个标记，这个过程中不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。所以剩下的堆空间是不连续的，垃圾回器要是希望得到连续空间的话，就得重新整理剩下的对象。 停止-复制的意思是这种垃圾回收动作不是在后台进行的；圾回收动作发生的同时，程序将会被暂停。在Sun公司的文档中会发现，许多参考文献将垃圾回收视为低优先级的后台进程，但事实上垃圾回收器在Sun公司早期版本的Java虚拟机器并非以这种方式实现的。当可用内存数量较低时，Sun版本的垃圾回器会暂停运行程序，同样，标记-清扫工作也必须在程序暂停的情况下才能进行。 如前文所述，在这里所讨论的Java虚拟机中，内存分配以较大的“块”为单位。如果对象较大，它会占用单独的块。严格来说，停止-复制要求在释放旧有对象之前，必须先把所有存活对象从旧堆里复制到新堆，这将导致大量内存复制行为。有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝对象了。每个块都有相应的代数来记录它是否还在存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器将对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。增加回收器会定期进行完整的清理动作——大型对象仍然不会被复制（只是其代数会增加），内含小型对象的那些块则被复制并整理。Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到标记-清扫方式；同样，Java虚拟会跟踪“标记——清扫”的效果，要是堆空间出现很多碎片，就会切换回“停止——复制 ”方式。这就是“自适应”技术，你可以给它个罗嗦的称呼：“自适应的、分代的、停止——复制，标记——清扫”式垃圾回收器。 Java虚拟机中有许多附加技术用以提升速度。尤其是与加载器操作有关的，被称为“即时”(Just-In-Time，JIT)编译器的技术。这种技术可以把程序全部或部分翻译成本地机器码（这本来是Java虚拟机的工作），程序运行速度因此得以提升，当需要装载某个类（通常是在为该类创建第一个对象）时，编译器会先找到其.class文件，然后将该类的字节码装入内存，此时，有两种方案可供选择。一种是就让即时编译器编译所有代码。但这种做法有两个缺陷：这种加载动作散落在整个程序生命周期内，累加起来要花更多时间；并且会增加可执行代码的长度（字节码比即时编译器展开后的本地机器码小很多），这将导致页面调度，从而降低程序速度。另一种做法称为惰性评估，意思是即时编译器只在必要的时候才编译代码。这样，从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的Java HotSpot技术就采用了类似的方式，代码每次被执行的时候都会做一些优化，所以执行的次数越多，它的速度就越快。 静态数据的初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class StaticInitialization &#123; public static void main(String[] args) &#123; System.out.println(\"Creating new Cupboard() in main\"); new Cupboard(); System.out.println(\"Creating new Cupboard() in main\"); new Cupboard(); table.f2(1); cupboard.f3(1); &#125; static Table table = new Table(); static Cupboard cupboard = new Cupboard();&#125;class Bowl &#123; Bowl(int marker) &#123; System.out.println(\"Bowl(\" + marker + \")\"); &#125; void f1(int marker) &#123; System.out.println(\"f1(\" + marker + \")\"); &#125;&#125;class Table &#123; static Bowl bowl1 = new Bowl(1); Table() &#123; System.out.println(\"Table()\"); &#125; void f2(int marker) &#123; System.out.println(\"f2(\" + marker + \")\"); &#125; static Bowl bowl2 = new Bowl(2);&#125;class Cupboard &#123; Bowl bowl3 = new Bowl(3); static Bowl bowl4 = new Bowl(4); Cupboard() &#123; System.out.println(\"Cupboard()\"); bowl4.f1(2); &#125; void f3(int marker) &#123; System.out.println(\"f3(\" + marker + \")\"); &#125; static Bowl bowl5 = new Bowl(5);&#125; 输出：123456789101112131415161718Bowl(1)Bowl(2)Table()Bowl(4)Bowl(5)Bowl(3)Cupboard()f1(2)Creating new Cupboard() in mainBowl(3)Cupboard()f1(2)Creating new Cupboard() in mainBowl(3)Cupboard()f1(2)f2(1)f3(1) 初始化的顺序是先静态对象（如果它们尚未因前面的对象创建过程而被初始化），而后是“非静态”对象。从输出结果中可以观察到这一点。要执行main()（非静态方法），必须加载StaticInitialization类，然后其静态域table和cupboard被初始化，这将导致它们对应类也被加载，并且由于它们也都包含静态Bowl对象，因此Bowl随后也被加载了。实际情况通常并非如此，因为在典型的程序中，不会像在本例中所做的那样，将所有的事物都通过static联系起来。 总结一下对象的创建过程，假设有个名为Dog的类： 即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定义Dog.class文件。 然后载入Dog.class（这将创建一个Class对象），有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。 当用new Dlog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。 这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据设置成了默认值（对数字来说是0，对布尔类和字符型也相同），而引用则被设置成了null。 执行所有出现于字段定义处的初始化动作。 执行构造器。这可能会牵涉到很多动作，尤其是涉及到继承的时候。 显式的静态初始化 Java允许将多个静态初始化动作组织成一个特殊的“静态子句”（有时也叫做“静态块”）。尽管静态块看起来像个方法，但它实际只是一段跟在static关键字后面的代码。与其它静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象）。 12345678910111213141516171819202122232425262728293031public class ExplicitStatic &#123; public static void main(String[] args) &#123; System.out.println(\"Inside main()\"); Cups.cup1.f(99); &#125;&#125;class Cup &#123; Cup(int marker) &#123; System.out.println(\"Cup(\" + marker + \")\"); &#125; void f(int marker) &#123; System.out.println(\"f(\" + marker + \")\"); &#125;&#125;class Cups &#123; static Cup cup1; static Cup cup2; static &#123; cup1 = new Cup(1); cup2 = new Cup(2); &#125; Cups() &#123; System.out.println(\"Cups()\"); &#125;&#125; 输出：1234Inside main()Cup(1)Cup(2)f(99) 非静态实例初始化12345678910111213141516171819202122232425262728293031323334353637public class Mugs &#123; Mug mug1; Mug mug2; &#123; mug1 = new Mug(1); mug2 = new Mug(2); System.out.println(\"mug1 &amp; mug2 initialized\"); &#125; public Mugs() &#123; System.out.println(\"Mugs()\"); &#125; public Mugs(int i) &#123; System.out.println(\"Mugs(int)\"); &#125; public static void main(String[] args) &#123; System.out.println(\"Inside main()\"); new Mugs(); System.out.println(\"new Mugs() completed\"); new Mugs(1); System.out.println(\"new Mugs(1) completed\"); &#125;&#125;class Mug &#123; Mug(int marker) &#123; System.out.println(\"Mug(\" + marker + \")\"); &#125; void f(int marker) &#123; System.out.println(\"f(\" + marker + \")\"); &#125;&#125; 输出：1234567891011Inside main()Mug(1)Mug(2)mug1 &amp; mug2 initializedMugs()new Mugs() completedMug(1)Mug(2)mug1 &amp; mug2 initializedMugs(int)new Mugs(1) completed 这种语法对于支持“匿名内部类”的初始化是必须的，但是它也使得你可以保证无论调用了哪个显式构造器，某些操作都会发生。从输出中可以看到实例初始化子句是在两个构造器之前执行的。","tags":[{"name":"Think in Java","slug":"Think-in-Java","permalink":"http://www.heqingbao.net/tags/Think-in-Java/"}]},{"title":"View事件分发机制","date":"2015-12-13T14:04:37.000Z","path":"2015/12/13/View-Dispatch-Event/","text":"点击事件的传递规则所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发的过程。点击事件的分发过程由三个很重要的方法来共同完成： public boolean dispatchTouchEvent(MotionEvent ev) 用来进行事件分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 public boolean onInterceptTouchEvent(MotionEvent event) 在上述方法内部调用，用来判断是否拦截这个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 public boolean onTouchEvent(MotionEvent event) 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。 上述三个方法的关系可以用如下伪代码表示： 12345678910public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 对于一个根ViewGroup来说，点击事件产生以后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回True就表示它要拦截这个事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回False就表示它不拦截这个事件，这时这个事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件最终被处理。 事件分发源码解析Activity对点击事件的分发过程Activity#dispatchTouchEvent 12345678910111213141516171819/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 当一个点击操作发生时，事件最先传递给当前的Activity，由Activity的dispatchTouchEvent来进行事件派发，事件首先交给Activity所属的Window，如果返回True，整个事件循环就结束了，返回False就意味着没人处理，所有View的onTouchEvent都返回了False，那么Activity的onTouchEvent就会被调用。 Window#superDispatchTouchent1234567/** * Used by custom windows, such as Dialog, to pass the touch screen event * further down the view hierarchy. Application developers should * not need to implement or call this. * */public abstract boolean superDispatchTouchEvent(MotionEvent event); 这是一个抽象方法，这里Window的实现类就是PhoneWindow，这点从Window的类注释中可以看出来： 123456789101112131415/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.policy.PhoneWindow, which you should instantiate when needing a * Window. Eventually that class will be refactored and a factory method * added for creating Window instances without knowing about a particular * implementation. */public abstract class Window &#123;...&#125; PhoneWindow#superDispatchTouchEvent1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; PhoneWindow把事件直接传递给了DecorView。这个DecorView是什么呢？ 12345678910111213141516PhoneWindow.java// This is the top-level view of the window, containing the window decor.private DecorView mDecor;private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123;...&#125;@Overridepublic final View getDecorView() &#123; if (mDecor == null) &#123; installDecor(); &#125; return mDecor;&#125; 这个DecorView就是getWindow().getDecorView()返回的View。我们通过setContentView设置的View就是它的一个子View。目前事件传递了DecorView这里，由于DecorView继承自FrameLayout且是父View，所以最终事件传递给View。 顶级View对点击事件的分发过程点击事件达到顶级View（一般是一个ViewGroup）以后，会调用ViewGroup的dispatchTouchEvent方法，然后的逻辑是这样的：如果顶级ViewGroup拦截事件即onInteerceptTouchEvent返回True，则事件由ViewGroup处理，这时如果ViewGroup的mOnTouchListener被设置，则onTouch被调用，否则onTouchEvent会被调用。也就是说，如果都提供的话，onTouch会屏蔽掉onTouchEvent。在onTouchEvent中，如果设置了mOnClickListener，则onClick被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。至此为止，事件已经从顶级View传递给了下一层View，接下来的传递过程和顶级View是一致的，如此循环，完成整个事件的分发。 ViewGroup#dispatchTouchEvent 1234567891011121314151617181920212223242526// Handle an initial down.if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); // 重置FLAG_DISALLOW_INTERCEPT标记位&#125;// Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; 从上面的代码可以看出，ViewGroup在如下两种情况下会判断是否要拦截当前事件：事件类型为ACTION_DOWN或者mFirstTouchTarget != null。ACTION_DOWN事件好理解，那么mFirstTouchTarget != null是什么意思呢？这个从后面代码逻辑可以看出来，当事件由ViewGroup的子元素处理成功时，mFirstTouchTarget会被赋值并指向子元素，换种方式说，当ViewGroup不拦截事件并将事件交由子元素处理埋mFirstTouchTarget != null。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget != null就不成立 。那么当ACTION_MOVE和ACTION_UP到来时，由于actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null条件为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，并且同一序列中的其它事件都会默认交给它处理。 FLAG_DISALLOW_INTERCEPT这个标记位是通过requestDisallowInterceptTouchEvent来设置的，一般用于子View中。FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其它点击事件。当面对ACTION_DOWN事件时，ViewGroup总会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。因此子View调用requestDisallowInterceptTouchEvent方法并不能影响ViewGroup对ACTION_DOWN的处理。 从ViewGroup的dispatchTouchEvent中可以看出，当ViewGroup决定拦截事件后，那么后续的点击事件会默认交给它处理并且 不再调用它的onInterceptTouchEvent方法。 接着看ViewGroup不拦截事件的时候，事件会向下分发交给它的子View进行处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869final View[] children = mChildren;for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; // 判断子元素是否能够接收到点击事件 // 1. 子元素是否在播放动画 // 2. 点击事件的坐标是否落在子元素的区域内 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法 // 如果子元素的dispatchTouchEvent返回True，那么mFirstTouchTarget会被赋值并且跳出循环 // 如果返回Fase，就会继续循环下一个子元素 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); // addTouchTarget里面会对mFirstTouchTarget赋值 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false);&#125; mFirstTouchTarget会在addTouchTarget里面被赋值，mFirstTouchTarget是一种单链表结构，mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截策略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来的同一序列中的所有点击事件。 12345678910/*** Adds a touch target for specified child to the beginning of the list.* Assumes the target child is not already present.*/private TouchTarget addTouchTarget(View child, int pointerIdBits) &#123;TouchTarget target = TouchTarget.obtain(child, pointerIdBits);target.next = mFirstTouchTarget;mFirstTouchTarget = target;return target;&#125; 如果遍历完所有子元素后都没有被合适地处理，包含两种情况：第一种是没有子元素，第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。这两种情况下，ViewGroup会自己处理点击事件： 1234// Dispatch to touch targets.if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); 12345678910111213/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125;&#125; 上面第三个参数child为null，它会调用super.dispatchTouchEvent(event)，这里就转到了View的dispatchTouchEvent方法。 View对点击事件的处理View#dispatchTouchEvent 12345678910111213141516171819202122232425262728293031/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */public boolean dispatchTouchEvent(MotionEvent event) &#123; ... boolean result = false; if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ... return result;&#125; 因为View（这里不包含子ViewGroup）是一个单独的元素，它没有子元素可以向下传递事件，所以它只能自己处理事件。从上面源码可以看出View对点击事件的处理过程。首先判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回True，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent. View#onTouchEvent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; // 当View处于不可用状态下照样会消耗点击事件 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; // 如果有设置代理，会调用TouchDelegate的onTouchEvent方法，这个onTouchEvent的机制看起来和OnTouchListener类似 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; ... &#125; break; ... &#125; return true; &#125; return false;&#125; 从源码来看，只要View的CLICKABLE和LONG_CLICKABLE有一个为True，那么它就会消耗这个事件，即onTouchEvent返回True（DISABLE状态也会消耗事件，见代码中的注释）。当ACTION_UP事件发生时会触发performClick()方法，如果View有设置OnClickListener，那么performClick方法内部会调用它的onClick方法： 1234567891011121314public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; View的LONG_CLICKABLE属性默认为False，而CLICKABLE属性是否为False和具体的View有关，确切地说是可点击的View其CLICKABLE为True，不可点击的View其CLICKABLE为False，比如Button是可点击的，TextView是不可点击的。通过setClickable和setLongClickable可以分别改变View的CLICKABLE和LONG_CLICKABLE属性。setOnClickListener/setLongClickListener会改变这两个属性： 12345678910111213public void setOnClickListener(OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125;public void setOnLongClickListener(OnLongClickListener l) &#123; if (!isLongClickable()) &#123; setLongClickable(true); &#125; getListenerInfo().mOnLongClickListener = l;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"events","slug":"events","permalink":"http://www.heqingbao.net/tags/events/"}]},{"title":"Java Mocking入门——使用Mockito","date":"2015-05-23T11:23:17.000Z","path":"2015/05/23/Java-Test-Mockito/","text":"考虑下面这个示例模型类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.example.mock;import java.util.List;/** * Model class for the book details. */public class Book &#123; private String isbn; private String title; private List&lt;String&gt; authors; private String publication; private Integer yearOfPublication; private Integer numberOfPages; private String image; public Book(String isbn, String title, List&lt;String&gt; authors, String publication, Integer yearOfPublication, Integer numberOfPages, String image) &#123; super(); this.isbn = isbn; this.title = title; this.authors = authors; this.publication = publication; this.yearOfPublication = yearOfPublication; this.numberOfPages = numberOfPages; this.image = image; &#125; public String getIsbn() &#123; return isbn; &#125; public void setIsbn(String isbn) &#123; this.isbn = isbn; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public List&lt;String&gt; getAuthors() &#123; return authors; &#125; public void setAuthors(List&lt;String&gt; authors) &#123; this.authors = authors; &#125; public String getPublication() &#123; return publication; &#125; public void setPublication(String publication) &#123; this.publication = publication; &#125; public Integer getYearOfPublication() &#123; return yearOfPublication; &#125; public void setYearOfPublication(Integer yearOfPublication) &#123; this.yearOfPublication = yearOfPublication; &#125; public Integer getNumberOfPages() &#123; return numberOfPages; &#125; public void setNumberOfPages(Integer numberOfPages) &#123; this.numberOfPages = numberOfPages; &#125; public String getImage() &#123; return image; &#125; public void setImage(String image) &#123; this.image = image; &#125;&#125; 操作Book模型的DAL类： 1234567891011121314151617181920212223242526272829303132package com.example.mock;import java.util.Collections;import java.util.List;/** * API layer for persisting and retrieving the Book objects. */public class BookDAL &#123; private static BookDAL bookDAL = new BookDAL(); public static BookDAL getInstance() &#123; return bookDAL; &#125; public List&lt;Book&gt; getAllBooks() &#123; return Collections.emptyList(); &#125; public Book getBook(String isbn) &#123; return null; &#125; public String addBook(Book book) &#123; return book.getIsbn(); &#125; public String updateBook(Book book) &#123; return book.getIsbn(); &#125;&#125; 当前DAL层以上没有任何功能，我们将对这段代码TDD进行单元测试，DAL层可能与ORM映射API或者数据库API通信，而我们不关心这些API是如何设计的。 测试驱动DAL层对单元测试和Java Mock有很多框架，对这个例子，我将选择JUnit做单元测试，Mockito作为Java mock。我们会在Maven的pom.xml文件中更新依赖属性。 123456789101112131415161718192021222324252627282930313233&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example.mock&lt;/groupId&gt; &lt;artifactId&gt;MockSimple&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;MockSimple&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-all&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 现在进行BookDAL类的单元测试。单元测试中，我们将注入mock数据到BookDAL类，因此我们可以不依赖数据源就可以完成API的测试。 最初我们有一个空的测试类： 12345678910111213141516171819package com.example.mock;public class BookDALTest &#123; public static void setUp() throws Exception &#123; &#125; public void testGetAllBook() throws Exception &#123; &#125; public void testGetBook() throws Exception &#123; &#125; public void testAddBook() throws Exception &#123; &#125; public void testUpdateBook() throws Exception &#123; &#125;&#125; 我们将使用下面的setUp()函数把BookDAL类注入mock对象，并设置mock对象数据： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.mock;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import java.util.Arrays;import java.util.List;import org.junit.BeforeClass;import org.junit.Test;public class BookDALTest &#123; private static BookDAL mockedBookDAL; private static Book book1; private static Book book2; @BeforeClass public static void setUp() throws Exception &#123; // Create mock object of BookDAL mockedBookDAL = mock(BookDAL.class); // Create few instances of Book class. book1 = new Book(\"1561451365165\", \"Java开发\", Arrays.asList(\"大神1\", \"大神2\"), \"清华大学出版社\", 2015, 500, \"Book Image\"); book2 = new Book(\"1561451365166\", \"Android开发\", Arrays.asList(\"大神3\", \"大神4\"), \"电子工业出版社\", 2016, 700, \"Book Image\"); // Stubbing the methods of mocked BookDAL with mocked data. when(mockedBookDAL.getAllBooks()).thenReturn(Arrays.asList(book1, book2)); when(mockedBookDAL.getBook(\"1561451365166\")).thenReturn(book2); when(mockedBookDAL.addBook(book1)).thenReturn(book1.getIsbn()); when(mockedBookDAL.updateBook(book2)).thenReturn(book2.getIsbn()); &#125; public void testGetAllBook() throws Exception &#123; &#125; public void testGetBook() throws Exception &#123; &#125; public void testAddBook() throws Exception &#123; &#125; public void testUpdateBook() throws Exception &#123; &#125;&#125; 在上面的setUp()方法中，我做了： 创建一个BookDAL的mock对象 mockedBookDAL = mock(BookDAL.class); 存根带mock数据的BookDAL对象的API，这样无论何时调用API都可以返回mock数据。 12345// When getAllBooks() is invoked then return the given data and so on for the other methods.when(mockedBookDAL.getAllBooks()).thenReturn(Arrays.asList(book1, book2));when(mockedBookDAL.getBook(\"1561451365166\")).thenReturn(book2);when(mockedBookDAL.addBook(book1)).thenReturn(book1.getIsbn());when(mockedBookDAL.updateBook(book2)).thenReturn(book2.getIsbn()); 填充剩余的测试方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.example.mock;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import java.util.Arrays;import java.util.List;import org.junit.BeforeClass;import org.junit.Test;public class BookDALTest &#123; private static BookDAL mockedBookDAL; private static Book book1; private static Book book2; @BeforeClass public static void setUp() throws Exception &#123; mockedBookDAL = mock(BookDAL.class); book1 = new Book(\"1561451365165\", \"Java开发\", Arrays.asList(\"大神1\", \"大神2\"), \"清华大学出版社\", 2015, 500, \"Book Image\"); book2 = new Book(\"1561451365166\", \"Android开发\", Arrays.asList(\"大神3\", \"大神4\"), \"电子工业出版社\", 2016, 700, \"Book Image\"); when(mockedBookDAL.getAllBooks()).thenReturn(Arrays.asList(book1, book2)); when(mockedBookDAL.getBook(\"1561451365166\")).thenReturn(book2); when(mockedBookDAL.addBook(book1)).thenReturn(book1.getIsbn()); when(mockedBookDAL.updateBook(book2)).thenReturn(book2.getIsbn()); &#125; @Test public void testGetAllBook() throws Exception &#123; List&lt;Book&gt; allBooks = mockedBookDAL.getAllBooks(); assertEquals(2, allBooks.size()); Book book = allBooks.get(0); assertEquals(\"1561451365165\", book.getIsbn()); assertEquals(\"Java开发\", book.getTitle()); assertEquals(2, book.getAuthors().size()); assertEquals(\"清华大学出版社\", book.getPublication()); assertEquals(2015, book.getYearOfPublication().intValue()); assertEquals(500, book.getNumberOfPages().intValue()); assertEquals(\"Book Image\", book.getImage()); &#125; @Test public void testGetBook() throws Exception &#123; String isbn = \"1561451365166\"; Book book = mockedBookDAL.getBook(isbn); assertNotNull(book); assertEquals(\"1561451365166\", book.getIsbn()); assertEquals(\"Android开发\", book.getTitle()); assertEquals(2, book.getAuthors().size()); assertEquals(\"电子工业出版社\", book.getPublication()); assertEquals(2016, book.getYearOfPublication().intValue()); assertEquals(700, book.getNumberOfPages().intValue()); assertEquals(\"Book Image\", book.getImage()); &#125; @Test public void testAddBook() throws Exception &#123; String isbn = mockedBookDAL.addBook(book1); assertNotNull(isbn); assertEquals(book1.getIsbn(), isbn); &#125; @Test public void testUpdateBook() throws Exception &#123; String isbn = mockedBookDAL.updateBook(book2); assertNotNull(isbn); assertEquals(book2.getIsbn(), isbn); &#125;&#125; 使用maven命令：mvn test进行测试。输出如下： 1234567891011121314151617------------------------------------------------------- T E S T S-------------------------------------------------------Running com.example.mock.BookDALTestTests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.194 secResults :Tests run: 4, Failures: 0, Errors: 0, Skipped: 0[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 2.589 s[INFO] Finished at: 2016-05-23T19:20:01+08:00[INFO] Final Memory: 13M/154M[INFO] ------------------------------------------------------------------------ 至此，通过使用mock框架，在不用实际配置数据源的情况下，就可以测试DAL类。 参考： 原文 https://dzone.com/articles/getting-started-mocking-java","tags":[{"name":"Java","slug":"Java","permalink":"http://www.heqingbao.net/tags/Java/"},{"name":"Mockito","slug":"Mockito","permalink":"http://www.heqingbao.net/tags/Mockito/"}]},{"title":"Android IPC","date":"2015-04-05T11:28:40.000Z","path":"2015/04/05/Android-IPC/","text":"Android IPC简介IPC是Inter-Process Communication的缩写，含义为进程间通信或才跨进程通信，是指两个进程之间进行数据交换的过程。说起进程间通信，我们首先要理解什么是进程，什么是线程。进程和线程是截然不同的概念。按照操作系统中的描述，线程是CPU调度的最小单元，同时线程是一种有限的系统资源。而进程一般指一个执行单元，在PC和移动设备上指一个程序或一个应用。一个进程可以包含多个线程，因此进程与线程是包含与被包含的关系。最简单的情况下，一个进程可以只有一个线程，即主线程，在Android里面主线程也叫UI线程，在UI线程中才可以操作界面元素。很多时候，一个进程中需要执行大量耗时任务，如果这些任务放在主线程中去执行就会造成界面无法响应，严重影响用户体验，这种情况在PC和移动操作系统上都存在，在Android中有一个特殊的名字叫做ANR（Application Not Response），即应用无响应。解决这个问题就要用到线程，把一些耗时任务放到线程里面去执行。 IPC不是Android中所独有的，任何一个操作系统都需要相应的IPC机制，比如Windows上可以通过剪贴板来进行进程间通信，Linux上可以通过命名管道、共享内存、信号量等来进行进程间通信。不同的操作系统平台有着不同的进程间通信方式。对于Android来说，它是一种基于Linux内核的移动操作系统，它的进程间通信方式并不是完全继承自Linux，它也有自己的进程间通信方式。在Android中最有特色的进程间通信方式就是Binder了，通过Binder可以轻松实现进程间通信。除了Binder，Android还支持Socket，通过Socket也可以实现任意两个终端之间的通信，当然一个设备上的两个进程通过Socket通信也是可以的。 只有在多进程的场景下才需要使用IPC跨进程通信，多进程的情况分为两种。第一种情况是一个应用因为某些原因自身需要采用多进程模式来实现，比如为了加大一个应用可使用的内存所有需要通过多进程来获取多份内存空间。Android对单个应用使用的最大内存做了限制，早期的一些版本可能是16MB，不同设备有不同的大小。另一种情况是当前应用需要向其它应用获取数据，由于不是同一个应用，所以必须采用跨进程的方式来获取所需数据，当我们通过系统提供的ContentProvider去查询数据库的时候，其实也是一种进程间通信，只不过通信细节系统内部屏蔽了。 Android中的多进程模式开启多进程模式在Android中使用多进程只有一种方法，就是给四大组件（Activity、Service、BroadcastReceiver、ContentProvider）在AndroidMenifest中指定android:process属性，除此之外没有其它方法，也就是说无法给一个线程或者一个实体烊指定其运行时所在的进程。其实还有一种非常规的多进程方法，就是通过JNI在native层去fork一个新的进程，但这种方法属于特殊方法。 12345678910111213141516&lt;activity android:name=\"com.example.MainActivity\" ... &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.Main\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=\"com.example.SecondActivity\" ... android:process=\":remote\" /&gt;&lt;activity android:name=\"com.example.ThirdActivity\" ... android:process=\"com.example.remote\" /&gt; 上面示例分别为SecondActivity和ThirdActivity指定了process属性，并且它们属性值不同。假设当前的包为是com.example，当SecondActivity启动时，系统会为它创建一个单独的进程com.example:remote，当ThirdActivity启动的时候，系统会为它创建一个单独的进程com.example.remote.同时入口Activity没有指定process，那它运行在默认进程中，默认进程名是包名。 对于两种命名的区别： :的含义是指要在当前的进程名前面附加上当前的包名，这是一种简单的写法，对于SecondActivity来说，它完事的进程名为com.example:remote，而对于ThirdActivity的声明方式，它是一种完整的命名方式。 进程名以:开头的进程属于当前应用的私有进程，其它应用的组件不可以和它跑在同一个进程中，而进程名不以:开头的进程属于全局进程，其它应用通过SharUID方式可以和它跑在同一个进程中。 Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。这里要说明的是，两个应用通过ShareUID跑在同一个进程中是有条件的，需要这两个应用具有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了共享data目录、组件信息，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。 多进程模式的运行机制所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这是多进程带来的主要影响。 一般来说，使用多进程会造成如下账方面的问题： 静态成员和单例模式失效 线程同步机制完全失效 SharedPreference的可可靠性下降 Application会多次创建 第4个问题，当一个组件跑在一个新的进程中的时候，由于系统要在创建新的进程中同时分配独立的虚拟机，所以这个过程其实就是启动一个应用的过程。因此相当于系统又把这个应用重新启动了一遍，既然重新启动了，那么自然会创建新的Application。 IPC 基础概念主要包含三方面内容：Serializable接口和Parcelable接口以及Binder。Serializable和Parcelable接口可以完成对象的序列化过程，当我们需要通过Intent和Binder传输数据时就需要使用Parcelable或者Serializable，还有的时候我们需要对象持久化到存储设备上或者通过网络传输给其它客户端，这个时候也需要使用Serialzable完成对象的序列化。 Serializable接口Serialization接口是Java所提供一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。这里要注意serialVersionUID这个字段。 Parcelable接口Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并可以通过Intent和Binder传递。系统已经为我们提供了许多实现了Parcelable接口的类，它们都是可以直接序列化的，比如Intent、Bundle、Bitmap等，同时List和Map也可以序列化，前提是它们里面的每个元素都是可序列化的。 既然Parcelable和Serializable都能实现序列化并且都可用于Intent间数据传递，那么二者该如何选取呢？Serializable是Java中的序列化接口，其使用起来简单但是开销比较大，序列化和反序列化过程需要大量的I/O操作。而Parcelable是Android中的序列化方式，因此更适合用在Android平台上，它的缺点就是使用起来稍微麻烦点，但它的效率比较高，这是Android推荐的序列化方式，因此应当首选Parcelable。 Binder直观来说，Binder是Android中的一个类，它实现了IBinder接口。从IPC的角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有。从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager等）和相应ManagerService的桥梁。从Android应用层来说，Binder是客户端和服务端进行通信的媒体，当bindService的时候，服务端会返回一个包含了服务端业务调用Binder对象，通过个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通的服务和基于AIDL的服务。 Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，Messenger的底层其实是AIDL。这里选择AIDL来分析Binder的工作机制。 Book.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.myapplication;import android.os.Parcel;import android.os.Parcelable;public class Book implements Parcelable &#123; private int bookId; private String bookName; public Book(int bookId, String bookName) &#123; this.bookId = bookId; this.bookName = bookName; &#125; protected Book(Parcel in) &#123; bookId = in.readInt(); bookName = in.readString(); &#125; public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel in) &#123; return new Book(in); &#125; @Override public Book[] newArray(int size) &#123; return new Book[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(bookId); dest.writeString(bookName); &#125;&#125; 1234// Book.aidlpackage com.example.myapplication;parcelable Book; 123456789// IBookManager.aidlpackage com.example.myapplication;import com.example.myapplication.Book;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; Book.java是一个表示图书信息的类，它实现了Parcelable接口。Book.aidl是Book类在AIDL中的声明。IBookManager.aidl是我们定义的一个接口，里面有两个方法：getBookList和addBook，其中getBookList用于从远程服务端获取图书列表，addBook用于往图书列表中添加一本图书。 可以看到，尽管Book类和IBookManager位于相同的包中，但是在IBookManager中仍然要导入Book类，这就是AIDL的特殊之处。来看一下系统为IBookManager.aidl生产的Binder类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/* * This file is auto-generated. DO NOT MODIFY. * Original file: /Users/heqingbao/Documents/Android/workspace/MyApplication/app/src/main/aidl/com/example/myapplication/IBookManager.aidl */package com.example.myapplication;public interface IBookManager extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.example.myapplication.IBookManager &#123; private static final java.lang.String DESCRIPTOR = \"com.example.myapplication.IBookManager\"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.example.myapplication.IBookManager interface, * generating a proxy if needed. */ public static com.example.myapplication.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.myapplication.IBookManager))) &#123; return ((com.example.myapplication.IBookManager) iin); &#125; return new com.example.myapplication.IBookManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.example.myapplication.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); com.example.myapplication.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = com.example.myapplication.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.example.myapplication.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public java.util.List&lt;com.example.myapplication.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.example.myapplication.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.example.myapplication.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(com.example.myapplication.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public java.util.List&lt;com.example.myapplication.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.example.myapplication.Book book) throws android.os.RemoteException;&#125; 上述代码是系统生成的。它继承了IInterface接口，同时它自己也还是个接口，所有可以在Binder中传输的接口都需要继承IInterface接口。 首先，它声明了两个方法getBookList和addBook，显然这就是我们在IBookManager.aidl中声明的方法，同时在内部类Stub里面还声明了两个int类型的id分别用于标识这两个方法，这两个id用于标识在transact过程中客户端所请求的到底是哪个方法。接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部代理类Proxy来完成。这么来看这个IBookManager这个接口的核心实现就是它的内部类Stub和Stub的内部代理类Proxy。 DESCRIPTOR Binder的唯一标识，一般用当前Binder的类名表示。 asInterface(android.os.IBinder obj) 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身。 asBinder 此方法返回当前的Binder对象。 onTransact 这个方法运行在服务端的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)。服务端通过code可以确定客户端请求的方法是什么，接着从data中取出目标方法所需的参数(如果目标方法有参数的话)，然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值，如果此方法返回false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也没希望随便一个远程都能远程调用我们的服务。 Proxy#getBookList 这个方法运行在客户端，当客户端远程调用此方法时，它的内部实现是这样的：首先创建该方法所需要的输入类型Parcel对象_data、输出型Parcel对象_reply和返回值对象List _result，然后把该方法的参数信息写入_data中(如果有参数的话)，接着调用transact方法来发起RPC（远程方法调用）请求，同时当前线程挂起，然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。 Proxy#addBook 这个方法运行在客户端，它的执行过程和getBookList是一样的，addBook没有返回值，所以它不需要从_reply中取出返回值。 通过上面的分析，应该已经了解了Binder的工作机制，但是有两点还是需要说明：首先，当客户端发起远程请求时，由于当前线程会被挂起起码至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程中发起此远程请求；其次，由于服务端的Binder方法运行在Binder线程池中，所以Binder方法不管是否耗时都该采用同步的方法去实现，因为它已经运行在一个线程池中了。 Android中的IPC方式使用Bundle四大组件中的三大组件（Activity、Service、BroadcastReceiver）都支持在Intent中传递Bundle数据，由于Bundle实现了Parcelable接口，所以它可以方便在不同进程间传输。基于这一点，当我们在一个进程中启动了另一个进程的Activity、Service和BroadcastReceiver，就可以在Bundle中附加需要传输给远程进程的信息并通过Intent发送出去。 使用文件共享文件共享也是一种不错的进程间通信方式，两个进程通过读写同一个文件来交换数据。除了可以交换文本数据外，还可以序列化一个对象到文件系统中的同时从另一个进程中恢复这个对象。但是这种方式是有局限性的，比如并发读写的问题。 使用MessengerMessenger是一种轻量级的IPC方案，它的底层实现是AIDL。 12345678910111213141516public final class Messenger implements Parcelable &#123; public Messenger(Handler target) &#123; mTarget = target.getIMessenger(); &#125; /** * Create a Messenger from a raw IBinder, which had previously been * retrieved with &#123;@link #getBinder&#125;. * * @param target The IBinder this Messenger should communicate with. */ public Messenger(IBinder target) &#123; mTarget = IMessenger.Stub.asInterface(target); &#125;&#125; Messenger的使用方法很简单，它对AIDL做了封装，使得我们可以更简便进行进程间通信。同时，由于它一次处理一请求，因此在服务端我们不用考虑线程同步的问题。 使用AIDL前面通过Messenger可以发现它是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理，如果有大量的并发请求，那么用Messenger就不太合适了。同时，Messenger的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形Messenger就无法做到了。但我们还可以使用AIDL来实现跨进程方法调用。 AIDL所支持的数据类型 基本数据类型（int、long、char、boolean、double等） String和CharSequence List：只支持ArrayList，里面每个元素都必须能够被AIDL支持 Map：只支持HashMap，里面每个元素都必须能够被AIDL支持 Parcelable：所有实现了Parcelable接口的对象 AIDL：所有的AIDL接口本身也可以在AIDL文件中使用 特别说明，自定义的Parcelable对象和AIDL对象必须要显式import进来，不管它们是否和当前的AIDL文件在同个package下。 另一个需要注意的，如果AIDL文件中用到了自定久的Parcelable对象，那么必须新建一个和它同名的AIDL文件，并在其中声明它为parcelable类型。除此之外，AIDL中除了基本数据类型，其它类型的参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数。最后，AIDL接口中只支持方法，不支持声明静态常量。 如何在AIDL中使用权限验证 在onBind中进行验证，难不通过就直接返回null。验证的方式可以有多种，比如常用的permission。 在服务端的onTransact方法中进行权限验证，如果验证失败，直接返回false。这样服务端就会终止执行AIDL中的方法从而达到保护服务端的上的。 除了这两种，肯定还有其它方法，比如为Service指定android:permisstion属性等。 使用ContentProviderContentProvider是Android中提供的专门用于不同应用间进行数据共享的方式，从这一点来看，它天生就适合进行间通信。 使用SocketSocket也称为套接字，是网络通信中的概念，它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议。TCP协议是面向连接的协议，提供稳定的双向通信功能，TCP的建立需要经过三次握手才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；UDP是无连接的，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。在性能上，UDP具有更好的效率，其缺点是不保证数据能够正常传输，尤其在网络拥塞的情况下。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"IPC","slug":"IPC","permalink":"http://www.heqingbao.net/tags/IPC/"}]},{"title":"Activity LaunchMode","date":"2015-03-22T07:50:49.000Z","path":"2015/03/22/Activity-Launch-Mode/","text":"Activity的LaunchMode我们知道，在默认情况下，当我们多次启动同一个Activity的时候，系统会创建多个实例并把它们一一放入任务栈中，当我们单周Back返回时，会发现这些Activity会一一返回。任务栈是一种后进先出的栈结构，这个比较好理解，每按一下Back键就会有一个Activity出栈，直到栈空为止，当栈中无任何Activity的时候，系统会回收这个任务栈。 目前有四种启动模式：standard、singleTop、singleTask和singleInstance。 standard 标准模式，这也是系统的默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。被创建的实例的生命周期符合典型 情况下的Activity的生命周期，它的onCreate、onStart、onResume都会被调用。这是一种典型的多实例实现，一个任务栈中可以有多个实例。每个实例也可以属于不同的任务栈。在这种模式下，谁启动了这个Activity，那么这个Activity就支行在启动它的那个Activity所在的栈中。比如Activity A启动了Activity B（B是标准启动模式），那么B就会进入 到A所在的栈中。当我们用ApplicationContext去启动standardActivity的时候会报错，错误如下： 1E/AndroidRuntime(674): android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? 这是因为standardActivity默认会进入启动它的Activity所属的任务栈中，但是由于非Activity类型的Context（如ApplicationContext）并没有所谓的任务栈，所以这就有问题了。解决这个问题的方法是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就会为它创建一个新的任务栈，这个时候待启动的Activity实际上以singleTask模式启动的。 singleTop栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被调用，通过此方法的参数我们可以取出当前Intent的信息。需要注意的是，这个Activity的onCreate、onStart方法不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但不是位于栈顶，那么新Activity依然会重新创建。举个粟子，假设目前栈内的情况为ABCD，其中ABCD为四个Activity，A位于栈底，D位地栈顶，这个时候假设要再次启动D，如果D的启动模式是singleTop，那么栈内的情况仍然为ABCD；如果D的启动模式为standard，那么由于D被重新创建，导致栈内的情况就会变为ABCDD。 singleTask栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在 ，那么多次启动都不会重新创建实例，和singleTop一样，系统也会调用其onNewIntent。具体一点，当一个具有singleTask模式的Activity请求启动后，比如Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放到栈中。如果存在A需要的任务栈，这时要看A是否在栈中有实例存在 ，如果有实例存在，那么系统就会把A调到栈顶并调用它的onNewIntent方法，如果实例不存在，就创建A的实例并把A压入栈中。举几个例子： 比如目前任务栈S1中的情况为ABC，这个时候D以singleTask模式请求启动，共所需要的任务栈为S2，由于S2和D的实例均不存在，所以系统会先创建任务栈S2，然后再wbffD的实例并将其入栈到S2. 另外一种情况，假设D所需的任务栈为S1，其它情况如下面例子所示，那么由于S1已经存在，所以系统会直接创建D的实例并将其入栈到S1. 如果D所需的任务栈为S1，并且当前任务栈S1的情况下ADBC，根本栈内利用的原则，此时D不会重新创建，系统会把D切换到栈顶并调用其onNewIntent方法，同时由于singleTask默认具有clearTop效果，会导致栈内所有在D上面的Activity全部出栈，于是最终S1的情况为AD。 singleInstance单实例模式，这是一种加强的singleTask模式，它除了具有singleTasl模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中，换句话说，比如A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁了。 这里需要指出一种情况，我们假设目前有两个任务栈，前台任务栈的情况为AB，后台任务栈的情况为CD，这里假设CD的启动模式均为singleTask。现在请求启动D，那么整个后台任务栈都会被切换到前台，这个时候整个后退列表变成了ABCD。当用户按Back返回的时候，列表中的Activity会一一出栈。如果不是请求启动D而是启动C，那么整个后退表就变成ABC。 另外一个问题，在singleTask启动械模式中多次提到某个Activity所需的任务栈，什么是Activity所需的任务栈呢？这要从一个参数说起：TAskAffinity，可以翻译为任务相关性。这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。当然我们可以为每个Activity都单独指定TaskAffinity属性，这个属性值必须不能和包名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其它模式下没有意义 。另外，任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位为暂停状态，用户可以通过切换将后台任务栈再次调到前台。 当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该 模式的Activity的目前任务栈的名字，待启动的Activity会支行在名字和TaskAffinity相同的任务栈中。 当TaskAffinity和allowTaskReparenting结合的时候，这种情况比较复杂，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allowTaskReparenting属性为True的话，那么当应用B被启动后，此Activity会直接从应用A的任务栈转移到应用B的任务栈中。比如现在有两个应用A和B，A启动了B的一个Activity C，然后按Home键回到桌面，然后再单击B的桌面图标，这个时候并不是启动了B的主Activity，而是重新显示了已经被应用A启动的Activity C，或者说，C从A的任务栈转移 到了B的任务栈中。可以这么理解，由于A启动了C，这个时候 C只能运行在A的任务栈中，但是C属于B应用，正常情况下，它的TaskAffinity值能和A的任务栈相同（因为包名不同）。所以，当B被启动后，B会创建自己的任务栈，这个时候系统发现C原本所想要的任务栈已经被创建了，所以就把C从A的任务栈中转移过来了。 有两种方法给Activity指定启动模式：第一种是通过AndroidMenifest为Activity指定启动模式： 12345&lt;activity android:anme\"xxx\" android:configChanges=\"xxx\" android:launchMode=\"singleTask\" android:label=\"@string/app_name\" /&gt; 另一种情况是通过在Intent中设置标志位来为Activity指定启动模式，比如： 123Intent intent = new Intent(this, SecondActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 这两种方式都可以为Activity指定启动模式，但是二者还是有区别的。首先，优先级上，第二种方式的优先级要高于第一种，当两种同时存在时，以第二种方式为准。其次，上述两种方式在限定范围上有所不同，比如，第一种方式无法直接为Activity设定FLAG_ACTIVITY_CLEAR_TOP标识，第二种方式无法为Activity指定singleInstance模式。 Activity的FlagsActivity的Flags有很多，这里主要分析一些比较常用的标识位。标识位的作用有很多，有的标识位可以设定Activity的启动模式，比如FALG_ACTIVITY_NEW_TASK和FALG_ACTIVITY_SINGLE_TOP等。还有的标识位可以影响Activity的运行状态，比如FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS等。 FLAG_ACTIVITY_NEW_TASK这个标识位的作用是为Activity指定singleTask的启动模式，其效果和在XML中指定该模式相同。 FALG_ACTIVITY_SINGLE_TOP这个标识位的作用是为Activity指定singleTop启动模式，其效果和在XML中指定该 模式相同中。 FALG_ACTIVITY_CLEAR_TOP具有标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要被出栈。这个标记位一般会和singleTask启动模式一起出现，在这种情况下，被启动Activity的实例如果已经存在，那么系统就会调用它的onNewIntent。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS具体这个标记位的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表找到我们的Activity的时候这个标识比较有用。它等同于在XML中指定Activity的属性android:excludeFromRecents=&quot;true&quot;。 IntentFilter的匹配规则启动Activity分为两种，显式调用和隐式调用。显式调用需要明确地指定被启动的对象的组件信息，包括包名和类名，而隐式调用则不需要明确指定组件信息。原则上一个Intent不应该既是显式调用又是隐式调用，如果二者共存的话以显式调用为主。显式调用很简单，这里主要介绍一下隐式调用。隐式调用需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配将无法启动目标Activity。IntentFilter的过滤信息有action、category、data。为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。一个过滤列表中的action、category、data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程 。只有一个Intent同时匹配action类别、category类别、data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。另外一点，一个Activity可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity。 action的匹配规则action是一个字符串，系统预定义了一些action，同时我们也可以在应用中定义自己的action。action的匹配规则是Intent中的action必须能够和过滤规则中的action匹配，这里说的匹配是指action的字符串值完全一样。一个过滤规则中可以有多个action，那么只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功。action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同，这里需要注意它和category匹配规则不同。另外action区分大小写，大小写不同字符串相同的action会匹配失败。 category的匹配规则category是一个字符串，系统预定义了一些category，同进我们也可以在应用中定义自己的category。category的匹配规则和action不同，它要求Intent中如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同。换句话说，Intent如果定义了category，不管有几个category，对于每个category来说，它必须是过滤器规则中已经定义了的category。当然，Intent可以没有category，如果没有category的话，按照上面的描述，这个Intent仍然可以匹配成功。这里要注意下它和action匹配过程的不同，action是要求Intent中必须有一个action且必须能够和过滤规则中的某个action相同，而category要求Intent可以没有category，但是如果你一旦有category，不管有几个，每个都要能够和过滤规则中的任何一个category相同。为什么不设置category也可以匹配呢？原因是系统在调用startActivity或者startActivityForResult的时候会默认为Intent加上android:intent.category.DEFAULT这个category，所以为了我们的Activity能够接收隐式调用，就必须在intent-filter中指定android.intent.category.DEFAULT这个category。 data的匹配规则data的匹配规则和action类似，如果过滤规则中定义了data，那么Intent中必须也要定义可匹配的data。 data的语法：123456&lt;data android:scheme=\"string\" android:host=\"string\" android:port=\"string\" android:path=\"string\" android:pathPattern=\"string\" android:mimeType=\"string\" /&gt; data由两部分组成，mimeType和URI。memeType指媒体类型，比如image/jpeg、audio/mpeg4-generic和video/*等，可以表示图片、文本、视频等不同的媒体格式，而URI中包含的数据就比较多了，下面是URI的结构： 1&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|[&lt;pathPrefix&gt;]|[&lt;pathPattern&gt;]] 这里再给出几个实际例子就好理解了12content://com.example.project:200/folder/subfolder/etchttp://www.baidu.com:80/search/info Scheme:URI的模式，比如http、file、content等，如果URI中没有指定scheme，那么整个URI无效。 Host:URI的主机名，比如www.baidu.com，如果host未指定，URI无效。 Port:URI中的端口号，比如80，仅当URI中指定了scheme和host参数的时候port参数才是有意义的。 Path、pathPattern和pathPrefix: 这三个参数表示路径信息，其中path表示完整的路径信息；pathPattern表示完整的路径信息，但是它里面可以包含通配符*，*表示0个或多个任意字符，需要注意的是，由于正则表达式的规范，如果想表示真实的字符串，那么*要写成\\\\*，\\要写成\\\\\\\\；pathPrefix表示路径的前缀信息。 介绍完data的数据格式后，我们要说一下data的匹配规则了。前面说到，data的匹配规则和action类似，它也要求Intent中必须含有data数据，并且data数据能够完全过滤规则中的某一个data，这里的完全匹配是指过滤规则中出现的data部分也出现在了Intent中的data中。 如过滤如下规则：1234&lt;intent-filter&gt; &lt;data android:mimeType=\"image/*\" /&gt; ...&lt;/intent-filter&gt; 这种规则指定了媒体类型为所有类型的图片，那么Intent中的mimeType属性必须为image/*才能匹配，这种情况下虽然过滤规则没有指定URI，但是却有默认值，URI的默认值为content或file。也就是说，虽然没有指定URI，但是Intent中的URI部分的scheme必须为content或者file才能匹配，这点是需要尤其注意的。为了匹配上面的规则，我们可以写出如下示例：1intent.setDAtaAndType(Uri.parse(\"file://abc\"), \"image/png\"); 另外，如果要为Intent指定完整的data，必须要调用setDataAndType方法，不能先计用setData再调用setType，因为这两个方法彼此会清除对方的值： Intent#setData12345public Intent setData(Uri data) &#123; mData = data; mType = null; return this;&#125; 可以发现，setData会把mimeType置为null，同理setType也会把URI置为null。 如下过滤规则：1234&lt;intent-filter&gt; &lt;data android:mimeType=\"video/mpeg\" android:scheme=\"http\" ... /&gt; &lt;data android:mimeType=\"video/mpeg\" android:scheme=\"http\" ... /&gt;&lt;/intent-filter&gt; 这种规则指定了两组data规则，且每个data都指定了完整的属性值，既有URI又有mimeType。为了匹配上面的规则，可以这样：1intent.setDataAndType(Uri.parse(\"http://abc\"), \"video/mpeg\"); 或者1intent.setDataAndTyep(Uri.parse(\"http://abc\"), \"audio/mpeg\"); 通过上面两个示例，应该已经明白了data的匹配规则，关于data还有一个特殊情况需要说明下，这也是它和action不同的地方，如下两种特殊的写法，它们的作用是一样的：123456789&lt;intent-filter&gt; &lt;data android:scheme=\"file\" android:host=\"www.baidu.com\" /&gt; ...&lt;/intent-filter&gt;&lt;intent-filter&gt; &lt;data android:scheme=\"file\" /&gt; &lt;data android:host=\"www.baidu.com\" /&gt; ...&lt;/intent-filter&gt; 另外一点，intent-filter匹配规则对于Service和BroadcastReceiver也是同样的道理，不过系统对于Service的建议是尽量使用显式调用方式来启动服务。 最后当我们通过隐式方式启动一个Activity的时候，可以做一下判断，看是否有Activity能够匹配我们的隐式Intent，如果不做判断就有可能出现错误。判断方法有两种：采用PackageManager的resolveActivity方法或者Intent的resolveActivity方法，如果它们找不到匹配的Activity就会返回null，我们通过判断返回值就可以规避错误。另外PackageManager还提供了queryIntentActivities方法，这个方法和resolveActivity方法不同的是：它不是返回最佳匹配的Activity信息而是返回所有成功匹配的Activity信息：12public abstract List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent, int flags);public abstract ResolveInfo resolveActivity(Intent intent, int flags); 上述两个方法第一个参数比较好理解，第二个参数需要注意，我们要使用MATCH_DEFAULT_ONLY这个标记位，这个标记位的含义是仅仅匹配那些在intent-filter中声明了&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;&gt;这个category的Activity。使用这个标记位的意义在于，只要上述两个方法不返回null，那么startActivity一定可以成功。如果不用这个标记位，就可以把intent-filter中category不含DEFAULT的那些activity给匹配出来，从而导致startActivity可能失败。因为不含有DEFAULT这个category的Activity是无法接收隐式Intent的。在action和category中，有一类aciton和category比较重要，它们是：12&lt;action android:name=\"android.intent.action.MAIN\" /&gt;&lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; 这二者共同作用是用来标明这是一个入口Activity并且会出现在系统的应用列表中，少了任何一个都没有意义，也无法出现在系统的应用列表中，也就是二者缺一不可。另外针对Service和BroadcastReceiver，PackageManager同样提供了类似的方法去获取成功匹配的组件信息。","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"LaunchMode","slug":"LaunchMode","permalink":"http://www.heqingbao.net/tags/LaunchMode/"}]},{"title":"Activity生命周期","date":"2015-03-12T05:50:28.000Z","path":"2015/03/12/Activity-Lifecycle/","text":"Activity生命周期全面分析典型情况下的生命周期分析在正常情况下，Activity会经历如下生命周期 onCreate：表示Activity正在被创建，这是生命周期的第一个方法。在这个方法中，我们可以做一些初始化工作，比如调用setContentView去加载界面布局资源、初始化Activity所需数据等。 onRestart：表示Activity正在重新启动。一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart就会被调用。这种情形一般是用户行为所导致的，比如用户按Home键切换到桌面或者用户打开了一个新的Activity，这时当前的Activity就会暂停，也就是onPause和onStop被执行了，接着用户又回到这个Activity，就会出现这种情况。 onStart：表示Activity正在被启动，即将开始，这时Activity已经可见了，但是还没有出现在前台，还无法和用户交互。这个时候其实可以理解为Activity已经显示出来了，但是我们还看不到。 onResume：表示Activity已经可见了，并且出现在前台并开始活动。要注意这个和onStart的对比，onStart和onResume都表示Activity已经可见，但onStart的时候Activity还在后台，onResume的时候Activity才显示到前台。 onPause：表示Activity正在停止，正常情况下，紧接着onStop就会被调用。在特殊情况下，如果这个时候快速地再回到当前Activity，那么onResume会被调用。此时可以做一些存储数据、停止动画等工作，但是注意不能太耗时，因为这会影响到新Activity的显示，onPause必须先执行，新Activity的onResume才会执行。 onStop：表示Activity即将停止，可以做一些稍微重量级的回收工作，同样不能太耗时。 onDestroy：表示Activity即将被销毁，这是Activity生命周期中的最后一个回调方法，在这里，我们可以做一些回收工作和最终的资源释放。 正常情况下，Activity的常用生命周期就只有上面7个。 针对一个特定的Activity，第一次启动，回调如下：onCreate-&gt;onStart-&gt;onResume。 当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause-&gt;onStop。如果新Activity采用了透明主题，那么当前Activity不会回调onStop。 当用户再次回到原Activity时，回调如下：onRestart-&gt;onStart-&gt;onResume。 当用户按Back键回退时，回调如下：onPause-&gt;onStop-&gt;onDestroy。 当Activity被系统回收后再次打开，生命周期方法回调过程和1一样，注意只是生命周期方法一样，不代表所有过程都一样。 从整个生命周期来说，onCreate和onDestroy是配对的，分别标识着Activity的创建和销毁，并且只可能有一次调用。从Activity是否可见来说，onStart和onStop是配对的，随着用户的操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次；从Activity是否在前台来说，onResume和onPause是配对的，随着用户操作或者设备屏幕的点亮和熄灭，这两个方法可能会被多次调用。 问题：假设当前Activity为A，如果这时用户打开一个新的Activity B，那么B的onResume和A的onPause哪个先执行呢？ 这个可以从Android的源码里得到解释。Activity的启动过程的源码相当复杂，涉及Instrumentation、ActiivtyThread和ActivityManagerService（简称AMS）。启动Acitivity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护着一个ActivityStack并负责栈内Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期方法的调用。在ActivityStack中的resumeTopActivityInnerLocked方法中有这么一段代码： 12345678// We need to start pausing the current activity so the top one// can be resumed...boolean dontWaitForPause = (next.info.flags&amp;ActivityInfo.FLAG_RESUME_WHILE_PAUSING) != 0;boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, true, dontWaitForPause);if (mResumedActivity != null) &#123; if (DEBUG_STATES) Slog.d(TAG, \"resumeTopActivityLocked: Pausing \" + mResumedActivity); pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);&#125; 可以看出，在新Activity启动之前，栈顶的Activity需要先onPause后，新Activity才能启动。最终在ActivityStackSupervisor中的realStartActivityLocked方法会调用如下代码： 12345app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), r.compat, r.launchedFromPackage, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); 这个app.thread的类型是IApplicationThread，而IApplicationThread的具体实现是ActivityThread中的ApplicationThread。所以这段代码实际上调用了ActivityThread中，即ApplicatonThread的scheduleLaunchActivity方法，而scheduleLaunchActivity最终会完成Activity的onCreate、onStart、onReusme的调用过程。因此，可以得出结论，是旧Activity先onPause，然后新Activity再启动。 至于ApplicationThread的scheduleLaunchActivity方法为什么会完成新Activity的onCreate、onPause、onResume的调用过程，请看下面的代码。scheduleLaunchActivity最终会调用如下方法，而如下方法的确会完成onCreate、onPause、onResume的调用过程。 ActivityThread里面的ApplicationThread类:12345678910111213141516171819202122232425262728293031323334public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 最后sendMessage 123456789101112131415161718private void sendMessage(int what, Object obj) &#123; sendMessage(what, obj, 0, 0, false);&#125;private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what) + \": \" + arg1 + \" / \" + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125; 这里mH实际上是一个Handler：123456789101112131415161718private class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ... &#125; &#125;&#125; 所以这里实际上是调用handleLaunchActivity方法： 1234567891011121314151617181920212223242526272829303132private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, \"Handling launch of \" + r); // Initialize before creating the activity WindowManagerGlobal.initialize(); // 这里新Activity被创建出来，其onCreate和onStart会被调用 Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; // 这里新Activity的onResume会被调用 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); ... &#125;&#125; 从上面的分析可以看出，当前启动一个Activity的时候，旧Activity的onPause会先调用，然后才会启动新的Activity。 异常情况下的生命周期分析Activity除了受用户操作所导致的正常的生命周期方法调用，还有一些异常情况，比如当资源相关的系统配置发生改变以及系统内存不足时，Activity就可能被杀死，下面具体分析这两种情况： 资源相关的系统配置发生改变导致Activity被杀死并重新创建理解这个问题，我们首先要对系统的资源加载机制有一定了解。拿最简单的图片来说，当我们把一张图片放在drawable目录后，就可以通过Resource去获取这张图片。同时为了兼容不同的设备，我们可能还需要在其他一些目录放置不同的图片，比如drawable-mdpi、drawable-hdpi、drawable-land等。这样，当应用程序启动时，系统就会根据当前情况去加载合适的Resource资源，比如说横屏手机和竖屏手机会拿到两张不同的图片（设定了landscape或portrait状态下的图片）。比如说当前Actiivty处于竖屏状态，如果突然旋转屏幕，由于系统配置发生了改变，在默认情况下，Activity会被销毁并且重新创建，当然我们也可以阻止系统重新创建我们的Activity。 在默认情况下，如果我产的Activity不做特殊处理，那么当系统配置发生改变后，Activity就会并重新创建。 当系统配置发生改变后，Activity会被销毁，其onPause、onStop、onDestroy均会被调用，同时由于Actiivty是在异常情况下终止的，系统会调用onSaveInstanceState来保存当前Activity的状态。这个方法的调用时机是在onStop之前，它和onPause没有既定的时序关系，它既可能在onPause之前调用，也可以之后调用。需要强调的一点，这个方法只会出现在Activity被异常终止的情况下，正常情况下系统不会回调这个方法。当Activity被重新创建后，系统会调用onRestoreInstanceState，并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState和onCreate方法。因此我们可以通过onRestoreInstanceState和onCreate来判断Activity是否被重建了，如果被重建了，那么我们就可以取出数据并恢复，从时序上来说，onRestoreInstanceState的调用时机在onStart之后。 同时，我们要知道，在onSaveInstanceState和onRestoreInstanceStae方法中，系统自动为我们做了一定的恢复工作。当Activity在异常情况下需要重新创建时，系统会默认为我们保存当前Activity的视图结构，并且在Activity重启后为我们恢复这些数据，比如EditText中的用户输入数据、ListView滚动的位置等，这些View相关的状态系统都能够默认为我们恢复。具体针对某一个特定的View系统能为我们恢复哪些数据，我们可以查看View的源码。和Activity一样，每个View都有onSaveInstanceState和onRestoreInstanceState方法，看一下它们的具体实现，就能知道系统能够自动为每个View恢复哪些数据。 关于保存和恢复View层次结构，系统的工作流程是这样的：首先Activity被异常终止时，Activity会调用onSaveInstanceState去保存数据，然后Activity会委托Window去保存数据，接着Window再委托它上面的顶级容器去保存数据。顶层容器是一个ViewGroup，一般来说它很可能是DecorView。最后顶层容器再去一一通知它的子元素来保存数据，这样整个数据保存过程就完成了。可以发现，这是一种典型的委托思想，上层委托下层、父容器委托子元素去处理一件事情，这种思想在Android中有很多应用，比如View的绘制过程、事件分发等都是采用类似的思想。至于数据恢复过程也是类似的，这里就不再介绍了。 Activity#onSaveInstanceState:12345678protected void onSaveInstanceState(Bundle outState) &#123; outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); Parcelable p = mFragments.saveAllState(); if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p); &#125; getApplication().dispatchActivitySaveInstanceState(this, outState);&#125; 这里调用mWindow.saveHierarchyState()方法：mWindow是抽象类Window里面一个抽象方法，这里的实际类型是PhoneWindow： 1234567891011121314@Overridepublic Bundle saveHierarchyState() &#123; Bundle outState = new Bundle(); if (mContentParent == null) &#123; return outState; &#125; SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;(); // mContentParent是一个ViewGroup类型，一般情况下是DecorView mContentParent.saveHierarchyState(states); outState.putSparseParcelableArray(VIEWS_TAG, states); ... return outState;&#125; View：123456789101112131415161718192021222324252627282930public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123; dispatchSaveInstanceState(container);&#125;/** * Called by &#123;@link #saveHierarchyState(android.util.SparseArray)&#125; to store the state for * this view and its children. May be overridden to modify how freezing happens to a * view's children; for example, some views may want to not store state for their children. * * @param container The SparseArray in which to save the view's state. * * @see #dispatchRestoreInstanceState(android.util.SparseArray) * @see #saveHierarchyState(android.util.SparseArray) * @see #onSaveInstanceState() */protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123; mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED; Parcelable state = onSaveInstanceState(); if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123; throw new IllegalStateException( \"Derived class did not call super.onSaveInstanceState()\"); &#125; if (state != null) &#123; // Log.i(\"View\", \"Freezing #\" + Integer.toHexString(mID) // + \": \" + state); container.put(mID, state); &#125; &#125;&#125; dispatchSaveInstanceState方法被ViewGroup override了： ViewGroup#dispatchSaveInstanceState：123456789101112@Overrideprotected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; super.dispatchSaveInstanceState(container); final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; count; i++) &#123; View c = children[i]; if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123; c.dispatchSaveInstanceState(container); &#125; &#125;&#125; 到此，这里来看一下TextView到底保存了哪些数据。 TextView#onSaveInstanceState：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic Parcelable onSaveInstanceState() &#123; Parcelable superState = super.onSaveInstanceState(); // Save state if we are forced to boolean save = mFreezesText; int start = 0; int end = 0; if (mText != null) &#123; start = getSelectionStart(); end = getSelectionEnd(); if (start &gt;= 0 || end &gt;= 0) &#123; // Or save state if there is a selection save = true; &#125; &#125; if (save) &#123; SavedState ss = new SavedState(superState); // XXX Should also save the current scroll position! ss.selStart = start; ss.selEnd = end; if (mText instanceof Spanned) &#123; Spannable sp = new SpannableStringBuilder(mText); if (mEditor != null) &#123; removeMisspelledSpans(sp); sp.removeSpan(mEditor.mSuggestionRangeSpan); &#125; ss.text = sp; &#125; else &#123; ss.text = mText.toString(); &#125; if (isFocused() &amp;&amp; start &gt;= 0 &amp;&amp; end &gt;= 0) &#123; ss.frozenWithFocus = true; &#125; ss.error = getError(); return ss; &#125; return superState;&#125; 从源码中可以看出，TextView保存了自己的文本选中状态和文本内容，并且通过查看其onRestoreInstanceState方法的源码，可以发现它的确恢复了这些数据，具体源码就不贴出来了。 资源内存不足导致低优先级的Activity被杀死Activity按照优先级从高到低，可以分为如下三种： 前台Activity——正在和用户交互的Activity的，优先级最高。 可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。3.后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。 当系统内存不足时，系统就会按照上述优先级去回收Activity，并在后续通过onSaveInstanceState和onRestoreInstanceState来存储和恢复数据。迢迢晒个进程中没有四大组件在执行，那么这个进程将很快被系统杀死，因此一些后台工作不适合脱离四大组件而独自支行在后台中，这样进程很容易被杀死。比较好的方法是将后台工作放入Service中从而保证进程有一定的优先级，这样就不会轻易地被系统杀死。 上面分析了系统的数据存储和恢复机制，我们知道，当系统配置发生改变后，Activity会被重新创建，那么有没有办法不重新创建呢？系统配置中有很多内容，如果当某项内容发生改变后，我们不想系统重新创建Activity可以给Activity指定configChanges属性。比如不想让Activity在屏幕旋转的时候重新创建，就可以给configChanges属性添加orientation这个值： 1android:configChanges=\"orientation\" 如果想指定多个值，可以用|连接起来，比如android:configChagnes=&quot;orientation|keyboardHidden&quot; 下面列出一些常见的属性： 属性 含义 locale 设备的本地位置发生了改变，一般指切换了系统语言 keyboard 键盘类型发生了改变，比如用户使用了外接键盘 keyboardHidden 键盘的可访问性发生了改变，比如用户调出了键盘 fontScale 系统字体缩放比例发生了改变，比如用户选择了一个新的字号 uiMode 用户界面模式发生了改变，比如是否开户了夜间模式（API8新添加） orientation 屏幕方向发生了改变，这个是最常用的，比如旋转了手机屏幕 layoutDirection 当布局方向发生变化，这个属性用的比较少，正常情况下无须修改布局的layoutDirection属性（API17新添加）","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"},{"name":"lifecycle","slug":"lifecycle","permalink":"http://www.heqingbao.net/tags/lifecycle/"}]},{"title":"Ubuntu 14.04使用PPTP配置VPN","date":"2015-03-01T10:21:19.000Z","path":"2015/03/01/Ubuntu-PPTP/","text":"第一步 安装PPTP1apt-get update 1apt-get install pptpd 修改pptpd的配置文件/etc/pptpd.conf，将以下两行的注释符#去掉： 12localip 192.168.0.1remoteip 192.168.0.234-238,192.168.0.245 修改/etc/ppp/chap-secrets文件，添加认证用户： 1234# Secrets for authentication using CHAP# client server secret IP addresstest1 pptpd 123456 *test2 * 123456 * 第二步 添加DNS服务器修改/etc/ppp/pptpd-options文件，添加两行： 12ms-dns 8.8.8.8ms-dns 8.8.4.4 现在可以开启PPTP守护进程了： 1service pptpd restart 可以使用netstat -alpn | grep :1723验证运行状态。 第三步 设置IP转发简单地编辑/etc/sysctl.conf文件，添加下面这一行（如果不存在的话）： 1net.ipv4.ip_forward = 1 执行sysctl -p使之立即生效。 第四步 为iptables创建NAT规则1iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE &amp;&amp; iptables-save 然后重启pptpd服务： 1service pptpd restart 然后应该可以妥妥地翻墙了。","tags":[{"name":"VPN","slug":"VPN","permalink":"http://www.heqingbao.net/tags/VPN/"},{"name":"PPTP","slug":"PPTP","permalink":"http://www.heqingbao.net/tags/PPTP/"}]},{"title":"Ubuntu 14.04配置OpenVPN","date":"2015-03-01T09:51:42.000Z","path":"2015/03/01/Ubuntu-OpenVPN/","text":"第一步 安装和配置OpenVPN环境OpenVPN配置在安装任何包之前，首先我们将更新Ubuntu的库列表。 1apt-get update 1apt-get install openvpn easy-rsa 1gunzip -c /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz &gt; /etc/openvpn/server.conf 在server.conf文件中，我们将做一些修改。 首先找到类似如下的块： 123456# Diffie hellman parameters.# Generate your own with:# openssl dhparam -out dh1024.pem 1024# Substitute 2048 for 1024 if you are using# 2048 bit keys.dh dh1024.pem 把dh1024.pem改成dh2048.pem，这样当生成server和client key的时候，这将使用两倍的RSA key长度。 然后找到这一段： 123456789# If enabled, this directive will configure# all clients to redirect their default# network gateway through the VPN, causing# all IP traffic such as web browsing and# and DNS lookups to go through the VPN# (The OpenVPN server machine may need to NAT# or bridge the TUN/TAP interface to the internet# in order for this to work properly).;push \"redirect-gateway def1 bypass-dhcp\" 取消最后一行的注释push &quot;redirect-gateway def1 bypass-dhcp&quot;。 再找到这个区域： 12345678# Certain Windows-specific network settings# can be pushed to clients, such as DNS# or WINS server addresses. CAVEAT:# http://openvpn.net/faq.html#dhcpcaveats# The addresses below refer to the public# DNS servers provided by opendns.com.;push \"dhcp-option DNS 208.67.222.222\";push \"dhcp-option DNS 208.67.220.220\" 取消最后两行的注释，并改成： 12push \"dhcp-option DNS 8.8.8.8\"push \"dhcp-option DNS 8.8.4.4\" 最后找到这个区域： 1234# You can uncomment this out on# non-Windows systems.;user nobody;group nogroup 取消最后两行的注释，改完后看起来长这样： 12user nobodygroup nogroup 配置包转发1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 1vim /etc/sysctl.conf 在这个文件顶部附近，我将看到： 12# Uncomment the next line to enable packet forwarding for IPv4#net.ipv4.ip_forward=1 取消注释net.ipv4.ip_forward 简单的防火墙ufw1ufw allow ssh 1ufw allow 1194/udp 打开/etc/default/ufw，找到DEFAULT_FORWARD_POLICY=&quot;DROP&quot;，把DROP改成ACCEPT。 接下来需要配置网络地址转换和IP伪装，打开/etc/ufw/before.rules，添加# START OPENVPN RULES到# END OPENVPN RULES之间的内容： 123456789101112131415161718192021## rules.before## Rules that should be run before the ufw command line added rules. Custom# rules should be added to one of these chains:# ufw-before-input# ufw-before-output# ufw-before-forward## START OPENVPN RULES# NAT table rules*nat:POSTROUTING ACCEPT [0:0] # Allow traffic from OpenVPN client to eth0-A POSTROUTING -s 192.168.1.0/24 -o eth0 -j MASQUERADECOMMIT# END OPENVPN RULES# Don't delete these required lines, otherwise there will be errors*filter 1ufw enable 检查ufw的主要防火墙规则 1ufw status 会看到类似的输出： 12345678Status: activeTo Action From-- ------ ----22 ALLOW Anywhere1194/udp ALLOW Anywhere22 (v6) ALLOW Anywhere (v6)1194/udp (v6) ALLOW Anywhere (v6) 第二步 创建一个证书频发机构和服务端证书/Key配置和编译证书频发机构1cp -r /usr/share/easy-rsa/ /etc/openvpn 1mkdir /etc/openvpn/easy-rsa/keys 编辑/etc/openvpn/easy-rsa/vars，然后改变相应的内容： 123456export KEY_COUNTRY=\"US\"export KEY_PROVINCE=\"TX\"export KEY_CITY=\"Dallas\"export KEY_ORG=\"My Company Name\"export KEY_EMAIL=\"sammy@example.com\"export KEY_OU=\"MYOrganizationalUnit\" 为了方便，我们将使用server作为key的名字，紧临着上面这一段修改： 1export KEY_NAME=\"server\" 我们需要生成Diffie-Hellman参数，这可能会花几分钟时间：1openssl dhparam -out /etc/openvpn/dh2048.pem 2048 1cd /etc/openvpn/easy-rsa 初始化PKI(Public key Infrastructure)。(注意点和空格) 1. ./vars 1./clean-all 1./build-ca 如果不需要改变，直接回车即可。 生成服务端证书和key仍然在/etc/openvpn/easy-rsa目录：1./build-key-server server 跟./build-ca有相似的输出，如果不需要修改，直接回车即可。但最后两步需要回复y确认。 移动服务端证书和keyOpenVPN期望在/etc/openvpn目录里看到服务端的CA。1cp /etc/openvpn/easy-rsa/keys/&#123;server.crt,server.key,ca.crt&#125; /etc/openvpn 到此，OpenVPN服务端做好了，可以开始了： 12service openvpn startservice openvpn status 第三步 为客户端生成证书和keyKey和证书绑定仍然在/etc/openvpn/easy-rsa目录。 1./build-key client1 如果不需要修改直接回车，最后两项需要明确的y回应。 复制例子配置到我们的目录，再修改。 1cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/easy-rsa/keys/client.ovpn 将证书和密钥转移到客户端设备需要将以下这些文件转移到客户端设备： 1234/etc/openvpn/easy-rsa/keys/client.ovpn/etc/openvpn/easy-rsa/keys/client1.crt/etc/openvpn/easy-rsa/keys/client1.key/etc/openvpn/ca.crt 可以使用scp或者pscp拷贝： 1scp root@your-server-ip:/etc/openvpn/easy-rsa/keys/client1.key . 拷贝完成后，最终客户端将得到这四个文件： client1.crt client1.key client.ovpn ca.crt 第四步 为客户端创建一个统一的OpenVPN属性文件打开client.ovpn文件，找到;remote my-server-2 1194这行，取消注释，并且使用你自己的VPN IP。 对user nobody和group nogroup取消注释： 123# Downgrade privileges after initialization (non-Windows only)user nobodygroup nogroup 然后需要把ca.crt,client1.crt和client1.key的内容粘贴到这个.ovpn的文件的末尾，使用基本的xml格式语法，类似这种： 123456789&lt;ca&gt;(insert ca.crt here)&lt;/ca&gt;&lt;cert&gt;(insert client1.crt here)&lt;/cert&gt;&lt;key&gt;(insert client1.key here)&lt;/key&gt; 当粘贴完成，这个文件的末尾应该类似这样的： 12345678910111213141516171819&lt;ca&gt;-----BEGIN CERTIFICATE-----. . .-----END CERTIFICATE-----&lt;/ca&gt;&lt;cert&gt;Certificate:. . .-----END CERTIFICATE-----. . .-----END CERTIFICATE-----&lt;/cert&gt;&lt;key&gt;-----BEGIN PRIVATE KEY-----. . .-----END PRIVATE KEY-----&lt;/key&gt; 保存并退出，现在我们已经有一个为client1生成的统一的OpenVPN客户端配置文件。 第五步 安装客户端配置文件WindowWindows可以直接安装OpenVPN。 安装完成后，把前面生成的client.ovpn拷贝到安装目录下的config文件夹下。 然后当你启动OpenVPN，它将自动识别这个配置文件。之后可以使用图形化的界面连接和断开等操作。 OS XOS X可以使用免费的Tunnelblick，安装完成后，双击client.ovpn文件，Tunnelblick将自动安装这个客户端配置。 AndroidAndroid端可以使用Android OpenVPN Connect iOSiOS设备可以使用OpenVPN Connect，不过可能需要进入美区AppStore才可以搜索得到，或者使用一些助手类工具安装。然后可以使用QQ简单地把client.opvpn发送到手机端，再选择使用OpenVPN打开即可。 然后就可以妥妥地翻墙了。","tags":[{"name":"OpenVPN","slug":"OpenVPN","permalink":"http://www.heqingbao.net/tags/OpenVPN/"},{"name":"VPN","slug":"VPN","permalink":"http://www.heqingbao.net/tags/VPN/"}]},{"title":"签名你的应用程序","date":"2014-05-24T14:23:41.000Z","path":"2014/05/24/qian-ming-ni-de-ying-yong-cheng-xu/","text":"签名你的应用程序Android系统要求所有的应用程序都需要被持有开发者信息的key签名。Android系统使用证书作为识别应用程序的作者和建立应用程序之间的信任关系的一种手段。该证书不能控制应用程序是否可以安装。该证书不需要由证书颁发机构进行签名：它是完全允许和典型的，为Android应用程序使用自签名证书。 要了解有关Android应用程序签名的要点是： 所有应用程序都必须签名。系统不允许安装未签名的应用程序，包括模拟器和真实设备。 测试和调试应用程序，编译工具会使用一个默认的key去签名你的应用程序，这个key是由Android SDK编译工具创建的。 当你准备向你的最终用户发布应用程序时，你必须使用一个适当的私有key去签名你的应用程序。不能发布由默认key签名的应用程序。 你可以使用自签名证书去签名你的应用程序。不需要任何证书颁发机构。 系统只有在安装应用程序的时候检测签名证书的有效期。如果应用程序安装后应用程序的签名证书过期，应用程序将继续正常工作。 你可以使用标准工具（keytool和jarsigner）去生成密钥和签名应用程序的.apk文件。 当你签名完后准备发布，我们建议你使用zipalign工具来优化最终的APK包。 Android系统不会安装或运行未签名成功的应用程序，这适应于所有运行的Android系统，无论是模拟器还是实际设备。出于这个原因，在真机或者模拟器运行或者调试之前，你必须为你的应用程序设置签名。 签名过程 应用程序不同的编译模式对于不同的签名过程。有两种编译模式：debug和release，当你开发或者测试的时候使用debug模式，当你想编译一个直接给用户的release版本或者发布到市场的应用程序使用release模式，例如Google Play。 当你在debug模式下的时候，Android SDK编译工具使用Keytool工具（在JDK里面）创建一个debug key.因为这个debug key是SDK编译工具创建的，所以它知道这个debug key的别名(alias)和密码，当你每次在debug模式下编译你的应用程序，这个编译工具使用这个debug key一起的Jarsigner工具（也在JDK里面）去签名你的应用程序的 .apk 文件。因为编译工具知道这个别名和密码，所以每次在编译的时候不需要提示你输入这个debug key的别名和密码。 当你在release模式下的时候，你需要使用你自己的私有key去签名你的应用程序。如果你没有一个私有的key，你可以使用Keytool工具创建一个，当你在release模式下编译你的应用程序，编译工具使用这个私有key和Jarsigner去签名你的应用程序的 .apk 文件，因为这个证书和私有key是你自己的，你必须向这个keystore和key alias提供密码。 当你使用Eclipse和ADT插件来开发应用程序的话，这个 debug 模式下的签名过程自动发生当你运行或者调试你的应用程序的时候。当你使用Ant编译脚本（debug）选项的时候，debug签名也会自动发生。你可以使用Exlipse Exprort Wizard或者修改Ant编译脚本（release）去编译应用程序让 release 签名自动发生。 签名策略 应用程序签名的某些方面可能会影响你如何对待你所开发的应用程序，特别是如果你计划推出多个应用程序。 通常，在整个应用程序的预期寿命里面，推荐所有的开发者都使用相同的证书去签名所有的应用程序，有几个原因，你应该这样做： 应用程序升级。当你发布应用更新，如果你想让用户无疑地更新到新版本，你必须使用相同的证书签名更新程序。当系统安装一个更新的应用程序，它会比较新版本的证书和旧版本的证书（如果有的话），如果两个证书完全匹配，包括证书数据和序列，系统允许安装更新。如果你使用一个不匹配的证书签名，你还必须指定一个不同的包名称的应用程序，相当于用户安装一个新的应用程序。 应用程序模块化。Android系统允许应用相同签名的应用程序运行在同一个进程里，如果应用程序请求，从而系统会将其视为一个单一的应用程序。通过这种方式，你可以在模块中布置你的应用程序，用户可以根据需要单独更新某一个模块。 代通过权限实现代码/数据共享。Android系统提供了基于签名的权限执行，这样应用程序可以公开功能到与指定证书签名的另一个应用程序。通过订阅多个应用程序使用相同的证书，并使用基于签名的权限检查，你的应用程序可以在一个安全的方式共享代码和数据。 决定你的签名策略的另一个重要的考虑是怎样设置你将要签名的应用程序的key的有效期。 如果你打算支持升级一个单一的应用程序，你应该确保你的key有超过程序的预期寿命的有效期。建议设置25年的有效期。当你的key的有效期满后，用户将无法无缝地升级到新你的应用程序的新版本。 如果你计划使用相同的key布置多个应用程序，你应该确保你的key的有效期超过所有版本的所有应用程序，包括未来可能被增加到套件中来的应用程序。 如果你计划把你的应用程序发布到Google Play,你所使用的签名key的有效期必须支持到2033年10月22日之后。Google Play强制执行这一要求，确保用户 可以无缝地升级到应用程序的新版本是可用的。 当你设计你的应用程序时，请保持以上几点，确保使用合适的证书签名你的应用程序。 基本设置 在开始之前，确保Keytook工具和Jarsigner工具对于SDK编译工具可用。这两个工具都在JDK中，在大多数情况下，你可以告诉SDK编译工具如何通过设置 JAVA_HOME 环境变量来查找这些工具，以便它引用一个合适的JDK。或者你也可以添加JDK版本的Keytool和Jarsigner到你的 PATH 环境变量。 如果你是在一个基于Linux的平台上开发，系统原本附带有一个GNU编译器的Java，请确保系统使用的是JDK版本的Keytool，如果Keytool已经在PATH里面，它可能是一个指向 user/bin/keytool 的一个符号链接，在这种情况下，确保它指向JDK下面的keytool Debug模式下签名 Android编译工具提供一个debug签名模式，使得你开发或者调试应用程序更方便。同时还能满足Android系统需要签署过的应用程序的需求。当你使用debug模式编译app，SDK工具调用Keytool来自动创建一个debug的keystore和key，这个debug key将自动签名你的app，因此你不需要用你自己的key去签名你的app。SDK使用确定的names和password创建debug模式的keystore/key： Keystore name:”debug.keystore” Keystore password:”android” Key alias:”androiddebugkey” Key password:”android” CN:”CN=Android Debug,O=Android,C=US” 如果需要，你可以更改debug keystore/key 的位置或者名称或者提供一个自定义的debug keystore/key来使用。然而，任何自定义的 debug keystore/key都必须使用默认的keystore/key 名字和密码（如上所述）。（例如在Eclipse/ADT，Windows &gt; Preferences &gt; Android &gt; Build） 警告：无法发布使用debug证书签名的应用程序 Eclipse用户如果你使用Eclipse/ADT，debug签名模式是默认启用的。当你运行或者调试应用程序，ADT会使用debug证书签名 .apk 文件，并且对package应用 zipalign ，然后安装在被选择的模拟器或者设备上。不需要自己做什么额外的操作，ADT可以访问Keytool. Ant用户如果你正在使用Ant来构建你的 .apk 文件，通过Ant命令使用 debug 选项是可用的（假使你使用一个 build.xml 文件生成android工具）。当你运行你的Ant调试编译你的应用程序，build脚本生成一个keystore/key并且签名的apk文件给你，然后该脚本还会使用 zipalign 工具apigns这个apk文件。不需要你自己做任何操作。阅读命令行编译和运行程序了解更多信息 Debug证书的有效期在debug模式会使用自签名的证书去签名你的应用程序，这个自签名的证书将会有365天的有效期（从创建的时候算起）。当你的证书过期，你会得到一个编译错误，如果使用Ant编译，这个错误大概长这样： 123debug:[echo] Packaging bin/samples-debug.apk, and signing it with a debug key...[exec] Debug Certificate expired on 8/4/08 3:43 PM 在Eclipse/ADT，你将在Android控制台看到相似的错误信息。 删除 debug.keystore 文件就可以解决此问题。如果是OS X或者Linux系统，默认存储在 ~/.android目录下，如果是Windows XP系统，默认存储在 C:\\Documents and Settings\\&lt;user&gt;\\.android/ 目录下，如果是Windows Vista或者Windows 7，默认存储在 C:\\Users\\&lt;user&gt;\\.android/ 目录下。 在你下次编译的时候，编译工具会生成一个新的keystore和debug key. 需要注意的是，如果你使用的开发机器使用的是一个非公历的语言环境，构建工具可能会错误地生成一个已经过期的debug证书，所以你在编译的时候会出现错误。有关解决方法的信息，参阅I can’t compile my app because the build tools generated an expired debug certificate Release模式下签名 当你的应用程序已经准备好向用户发布，你必须： 获取一个合适的私钥 在release模式下编译你的应用程序 用私钥签名你的应用程序 Align最终的Apk包 如果你使用Eclipse开发，你可以使用Export向导完成编译、签名和Align程序，Export向导过程中甚至可以让你生成一个新的keystore和private key.所以，如果你使用Eclipse，你可以跳至Compile and sign with Eclipse ADT 1. 获取一个合适的私钥在准备签名你的应用程序的时候，你必须首先确定你有一个合适的私钥。一个合适的私钥是一个： 是你自己拥有的 代表个人、企业或组织的实体去标记你的应用程序 有效期超过应用程序或程序套件所期望的生命周期。有效期超过25年是被推荐的。 如果你计划在Google Play上发布一个或多个应用程序，注意有效期应该是在2033年10月22日之后，如果有效期在这之前，你将不能上传到Google Play. 不能是构建工具生的debug key 这个key可以是自签名的，如果你没有一个适合的key, 你必须使用Keytool生成一个，确保你有一个可用的Keytool，参考上面的基本设置。 要使用Keytool生成一个自签名key，使用keytool命令，并通过下面列出的选项（如果需要）。 警告：保持你的私钥安全。在运行Keytool之前，请务必阅读Securing Your Private Key，它向用户描述了怎样保持你的私钥安全和为什么这样做很重要。特别的，当你生成你的密钥，你应该对keystore和key使用强密码类型。 警告：保持生成的keystore文件在一个安全的地方，你必须使用相同的key去签名你将来要更新的应用程序。如果你使用一个新key发布一个应用程序，Google Play将认为它是一个新的app，在应用程序的整个生命周期，你必须保持相同的签名文件。详细请参考Android开发博客Things That Cannot Change. Keytool选项 描述 -genkey Generate a key pair (public and private keys) -v Enable verbose output. -alias An alias for the key. Only the first 8 characters of the alias are used. -keyalg The encryption algorithm to use when generating the key. Both DSA and RSA are supported. -keysize The size of each generated key (bits). If not supplied, Keytool uses a default key size of 1024 bits. In general, we recommend using a key size of 2048 bits or higher. -dname A Distinguished Name that describes who created the key. The value is used as the issuer and subject fields in the self-signed certificate. Note that you do not need to specify this option in the command line. If not supplied, Jarsigner prompts you to enter each of the Distinguished Name fields (CN, OU, and so on). -keypass The password for the key. As a security precaution, do not include this option in your command line. If not supplied, Keytool prompts you to enter the password. In this way, your password is not stored in your shell history. -validity The validity period for the key, in days. Note: A value of 10000 or greater is recommended. -keystore .keystore A name for the keystore containing the private key. -storepass A password for the keystore. As a security precaution, do not include this option in your command line. If not supplied, Keytool prompts you to enter the password. In this way, your password is not stored in your shell history. 下面是一个使用keytool生成私钥的例子： 12$ keytool -genkey -v -keystore my-release-key.keystore-alias alias_name -keyalg RSA -keysize 2048 -validity 10000 运行上面例子中的命令，keytool将提示你为keystore和key输入密码，将为你的key提供专有名称字段，它将生成一个叫my-release-key.keystore的文件。这个keystore和key将受到密码保护。这个keystore只包含一个key,有效期1000天，这个别名是你将使用的名字。 关于keytool的更多信息，请参考 http://docs.oracle.com/javase/6/docs/technotes/tools/windows/keytool.html 2. 在release模式下编译你的应用程序必须在release模式下编译你的应用程序。在release模式下编译应用程序不会使用debug签名，你将使用你的private key去签名它。 警告：你不能发布未签名或者使用debug签名的应用程序 使用Eclipse从Eclipse里面导出一个未签名的APK，在Package Explorer视图右击项目名，选择Android Tools &gt; Export Unsigned Application Package然后为未签名的APK指定位置（或者，打开AndroidManifest.xml文件，选择Manifest标签，点击Export an unsigned APK） 注意，你可以结合编译和签名步骤导出向导。请参见使用Eclipse ADT编译和签名 使用Ant如果你使用Ant,你可以在命令行使用release选项开启release模式。例如，如果你在包含build.xml的目录下运行ant,命令大概长这样： 1$ ant relase 默认编译脚本编译这个应用程序APK，但不是为它签名。它将输出在bin/目录下面。类似&lt;your_project_name&gt;-unsigned.apk.因这个apk仍然未签名，你必须手动地为它签名，并且使用zipalign 然后，如果你有在ant.properties文件里面指定keystore的路径和key的名字，Ant的编译脚本也能执行签名和aligning，当你在执行ant release命令的时候将提示你输入密码。最终的输出文件在bin/目录下，类似&lt;your_project_name&gt;-release.apk,这些步骤是自动的。学习怎样在ant.properties文件中指定keystore和alias，参考Building and Running Apps on the Command Line. 3. 用私钥签名你的应用程序当你有一个应用程序包准备签名，你可以使用jarsigner工具为它签名，如在基本设置中所述请确保jarsigner工具在你的机器上可用。此处，确保keystore中所包含的private key是可用的。 运行jarsigner签名你的应用程序，引用将要签名的apk和所要签名的keystore，下表中列出了一些可以使用的参数： Jarsigner选项 描述 -keystore .keystore The name of the keystore containing your private key. -verbose Enable verbose output. -sigalg The name of the signature algorithim to use in signing the APK. Use the value SHA1withRSA. -digestalg The message digest algorithim to use in processing the entries of an APK. Use the value SHA1. -storepass The password for the keystore. As a security precaution, do not include this option in your command line unless you are working at a secure computer. If not supplied, Jarsigner prompts you to enter the password. In this way, your password is not stored in your shell history. -keypass The password for the private key. As a security precaution, do not include this option in your command line unless you are working at a secure computer. If not supplied, Jarsigner prompts you to enter the password. In this way, your password is not stored in your shell history. 下面的例子演示了怎样使用jarsigner签名my_application.apk 12$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystoremy_application.apk alias_name 运行上面的例子命令，jarsigner提示你输入密码，然后它会原地修改这个apk,意味着这个apk现在已经被签名，注意，你可以使用不同的keys去多次签名一个apk。 警告：在JDK 7中，默认的签名算法已经改变，当你签名一个apk需要你自己指定签名和算法摘要(-sigalg and -digestalg) 你可以使用命令验证你的apk签名： 1$ jarsigner -verify my_signed.apk 如果这个apk被正确地签名了，Jarsigner打印“jar verified”,如果你想更多详细信息，你可以试试这些命令： 1$ jarsigner -verify -verbose my_application.apk 或者 1$ jarsigner -verify -verbose -certs my_application.apk 上面的命令，如果加上-certs,将显示CN=描述谁创建了这个key 注意：如果你看到“CN=Android Debug”，意味着这个apk使用的是debug key签名，如果你准备发布你的应用程序，你必须使用private key去签名它。 更多Jarsigner的信息，请参考文档 http://docs.oracle.com/javase/6/docs/technotes/tools/windows/jarsigner.html 4. Align最终的Apk包一旦你用你自己的private key签名了你的应用程序，在文件上运行 zipalign。此工具确保所有未压缩的数据开始一个特定的字节对齐，相对于文件的起点，当安装在设备上的时候，确保对齐在4个字节边界提供一个性能优化。当应用了aligned,Android系统可以使用mmap()读取文件，即使它们包含对齐限制的二进制数据，而不是从包里面复制所有的数据。其好处是在RAM中运行的应用程序所消耗的内存空间减少。 这个 zipalign 在Android SDK中是提供的，在 tools/ 目录下面。使用align你的签名的apk,执行： 1$ zipalign -v 4 your_project_name-unaligned.apk your_project_name.apk 这个-v标志打开详细输出（可选），4字节对齐（不要使用任何超过4的数字），第一个文件参数是你的签名的apk文件（输入），第二个文件参数是目标apk文件（输出），如果你覆盖一个已经存在的apk，增加 -f 参数。 警告：在你使用 zipalign 优化这个包的时候，你输入的APK必须是使用private key签名过的。如果你使用 zipalign 之后再签名，对齐将被撤销。 更多信息，请阅读ziplign工具。 使用Ecilpse ADT编译并签名如果你使用Eclipse的ADT插件,你可以使用Export向导导出一个签名的apk(乃至创建一个新的keystore，如果需要的话)。Export向导使用keytool和jarsigner为你执行所有的交互，它允许你使用GUI而不是执行手动程序来编译、签名和对齐。如上面所讨论的签名包的所有互动。一旦向导编译并签名你的包，它也将使用zipalign对齐这个包。因为导出向导同时使用keytool和Jarsigner,你应该确保在你的电脑上面这些是有效的。如上面基本签名所述。 在Eclipse里面创建一个签名并且对齐的APK： 在Package Explorer视图选择项目，选择File&gt;Export 打开Android文件夹，选择 Export Android Application,点击 Next。Export Android Application现在已经开始，这将引导你完成签名你的应用程序，包括用于选择private key与签名的apk（或者创建一个新的keystore和private key）步骤的过程。完成导出向导，你的应用程序将被编译、签名，对齐并准备进行发布。 私钥安全 对于你自己和用户来说，保持你的private key安全是至关重要的。如果你让别人使用你的key,或许如果你让你的keystore和密码在一个不安全的地主，使得第三方可以找到并使用它们，你的作者身份和用户的信任将会受到损害。 如果第三方在你不知情的情况下获得了你的key,这个可以签名和发布应用程序，恶意替换你真实的的应用程序或对齐造成损害。这样的人也可以根据你的身份签名或发布攻击其它应用程序或系统本身，或损坏或窃取用户数据。 你的private key需要签名你的应用程序的所有未来版本。如果你遗失或者找不到你的private key，你将无法更新发布到你现在有的应用程序。你不能再创建一个先前创建的key. 在任何时候，直到private key已过期，你作为一个开发者的声誉取决于确保private key的安全性。以下是保持你的private key安全的一些提示： 对keystore和key使用强密码 当你使用keytool生成你的key,不要在命令行上使用 -storepass 和 -keypass 选项，如果你这样做，你的密码将被记录在shell历史里面，你计算机上的任何用户都可以访问。 同样的，当使用Jarsigner签名你的应用程序的时候，不要在命令行上使用 -storepass 和 -keypass 选项。 不要把你的private key给或者借给任何人，不要让未经授权的人知道你的keystore和key密码。 确保你使用keytool生成的包含private key的keystore在一个安全可靠的地方。 一般情况下，当你遵循常性性的预防措施生成、使用、存储你的key,它会保持安全。 原文参考：http://developer.android.com/tools/publishing/app-signing.html","tags":[{"name":"Android","slug":"Android","permalink":"http://www.heqingbao.net/tags/Android/"}]},{"title":"Android Studio引入第三方类库","date":"2014-03-22T17:57:13.000Z","path":"2014/03/23/android-studioyin-ru-di-san-fang-lei-ku/","text":"Android Studio中引入第三方类库有两种方式，一种是引入本地的jar包，另一种是远程的，类似于Maven里面添加dependency。 添加本地jar把jar文件放到工程模块下面的libs文件夹下面，没有就新建一个。然后在当前模块下面的build.gradle添加本地dependency: 12345dependencies &#123; ... compile files('libs/weibosdkcore.jar') ...&#125; 或者直接指定添加某个目录下面的所有类库 12345dependencies &#123; ... compile fileTree(dir: 'libs', include: '*.jar’) ...&#125; 添加一个Maven仓库中的jar这里拿commons-io这个类库为例： 12345dependencies &#123; ... compile 'commons-io:commons-io:2.4' ...&#125; 引入另外一个library工程源码在Android Studio里面，引入一个library工程源码相对来说稍微麻烦一点。这里就拿ViewPagerIndicator来举例。假设说我们要把它项目里面的library项目源码引入到Android Studio里面来的话，需要把基于Eclipse的项目移植到Android Studio上面来。先把library工程import到Eclipse里面，然后右建工程名，选择export然后选择Android列表下的Generate gradle build files，之后会为这个项目生成一个build.gradle的文件，这正是Android Studio所需要的。然后把library整个目录拷贝到我们的目标workspace里面，与我们的目标工程文件夹（假设说叫app）平行的某个位置，并且改名叫ViewPagerIndicator。然后在Android Studio里面就可以看到一个叫ViewPagerIndicator的目录了，根据自己的需求删掉一些没用的目录，比如gen和bin。 然后修改在workspace级别目录下面的settings.gradle，把新添加的module添加进来： 1include ':app','ViewPagerIndicator' 然后再在我们的app模板里面引入刚添加的library module，修改app下面的build.gradle12345dependencies &#123; ... compile project(':ViewPagerIndicator') ...&#125; 至此，应该就ok了。","tags":[]},{"title":"GoAgent配置简易教程","date":"2014-02-22T12:30:26.000Z","path":"2014/02/22/goagentpei-zhi-jian-yi-jiao-cheng/","text":"GoAgent是一个基于Google Appengine的，全面兼容IE，FireFox，chrome的代理工具，使用Python和Google App EngineSDK编写，程序可以在MicrosoftWindows，Mac，Linux，Android，iPod Touch，iPhone，iPad，webOS，OpenWrt，Maemo上使用。关键它还是免费的。 简易教程 部署 goagent 申请 Google Appengine并创建appid 下载 goagent 最新版http://goo.gl/qFyRk 个性 local/proxy.ini 中的 [gae] 下的 appid= 你的 appid (多 appid 请用 | 隔开) 双击 server\\uploader.bat 开始上传, 成功后即可使用了(地 址127.0.0.1:8087)* MacOS/Linux 请在 Terminal 执行 `cd server &amp;&amp; python uploader.zip` 使用goagent Chrome请安装 SwitchySharp 插件（拖放 SwitchySharp.crx 到 扩展设置），然后导入 SwitchyOptions.bak 这里暂不介绍IE或其它浏览器 图文教程goagent GAE平台部署教程 goagent GAE平台部署教程 一、申请Google App Engine并创建appid 二、下载goagent并上传到Google App Engine 三、运行客户端 谷歌Chrome配合Proxy Switchy Sharp扩展 goagent适用环境 关于软件更新 一、申请Google Ap Engine并创建appid 申请注册一个Google App Engine账号https://appengine.google.com。没有Gmail账号先注册一个， 用你的Gmaill账号登录。 登录之后，自动转向Application注册页面. 接下来的页面，输入你的手机号码，需要注意的是，手机号码前面要+86（中国区号） 格式如：+86 13888888888。 然后等待收取手机短信，收到短信后（一串数字号码）填入表 单，点send提交.（有的手机收不到信息，解决办法：详细教程 到 https://appengine.google.com/waitlist/sms_issues 提交 该情况，一个工作日就能收到谷歌提示Google App Engine成功开 通）。 提交完成之后，GAE账号即被激活，然后就可以创建新的应用程序了。转入“My Applications”页面，点击“Create an Application”新建应用。 一个Gmail账户最多可以创建十个GAE应用，每个应用每天1G免费流 量。这里我们只创建一个应用就可以了。进入下一步，填写新应用的必要 信息，如下图。在图中第一处添加一个应用名称，如abc555,验证一下 是否可用，如果显示“Yes”那么abc555就是你的Appid（记住这个 id），而abc555.appspot.com就是你的应用服务器地址了。第二个空 可随便填，点击Create Application按钮提交 二、下载goagent并上传到Google App Engine 下载goagent并解压，http://goo.gl/qFyRk 上传 Windows用户：双击 server 文件夹下的 upload.bat ，输入你上步创 建的 appid（同时上传多appid在appid之间用 | 隔开,一次只能上传 同一个谷歌帐户下的 appid ）填完按回车。根据提示填你的谷歌帐户邮箱 地址，填完按回车。根据提示填你的谷歌帐户密码(注意：如果开启了两 步验证，密码应为16位的应用程序专用密码而非谷歌帐户密码，否则会 出现 AttributeError: can&#39;t set attribute 错误），填完按回 车。如果要上传多个谷歌帐户下的appid，先上传一个账号的，传完一个 账号后删除 uploader.bat 同目录下的 .appcfg_cookies 文件再传另 一个。 Linux/Mac用户上传方法：在server目录下执行：python uploader.zip。 如遇到 getaddrinfo failed，error10054，Error 10061 目 标计算机积极拒绝等错误而不能上传，可以先运行 goagent.exe (要先 修改appid)并把IE代理设置为 127.0.0.1：8087 再运行 uploader.bat 。 要使用IPv6上传或者上传遇到11004错误可以按照此贴进行修改或者 下载这个已经修改好的 uploader.zip 文件覆盖原 uploader.zip 文 件。 上传成功后编辑 local\\proxy.ini，把其中 appid = goagent 中的 goagent 改成你已经上传成功的应用的appid (用windows的记事本也可以）。 如果要使用多个appid，appid之间用 | 隔开，如：appid1|appid2|appid3 ，每个 appid必须确认上传成功才能使用。 12[gae]appid = appid1|appid2|appid3 三、运行客户端 Windows用户运行local文件夹中的 goagent.exe， Linux/Mac用户运行 proxy.py 设置浏览器或其他需要代理的程序代理地址为 127.0.0.1:8087 注意：使用过程中要一直运行 goagent.exe/proxy.py 代理地址 127.0.0.1:8087；如需使用PAC，设置pac地址为 http:// 127.0.0.1:8086/proxy.pac；也可以配合 SwitchySharp/AutoProxy 等浏览器扩 展（SwitchySharp用户可从local文件夹中的 SwitchyOptions.bak 文件导入配置） 导入证书 IE/Chrome：使用管理员身份运行 goagent.exe 会自动向系统导入IE/Chrome的证 书，你也可以双击 local 文件夹中的 CA.crt 安装证书（需要安装到“ 受信任的根证书颁发 机构 ”）； 注意：请勿重复安装证书 四、Chrome浏览器设置（安装Proxy Switchy Sharp扩展） 安装扩展 地址栏输入 chrome://extensions/ 后按回车，打开扩展管理页，将local文件夹中 的 SwitchySharp-0.9-beta-r48.crx 拖拽到该页面之后点击确定即可安装，扩展也可 以从chrome应用商店获得 https://chrome.google.com/webstore/detail/ proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm 导入设置 点击 Proxy SwitchySharp图标》选项》倒入/导出》从文件恢复 浏览到SwitchyOptions.bak，点击确定导入设置 更新自动切换规则（如果遇到无法更新规则列表，可以先运行goagent，并把浏览器代理设置为GoAgent?模式再更新规则，不更新规则只会影响自动切换模式，不会影响其他模式的使用，若确实无法更新也可不更新，直接使用PAC模式即可） 在扩展设置页点击“切换规则”，点击“立即更新列表”，最后点击“保存”。 单击地址栏右侧Proxy SwitchySharp图标即可进行模式选择 GoAgent模式 除匹配proxy.ini中sites的直连外，其他全部通过GAE GoAgent PAAS模式 全部通过PAAS GoAgent Socks5模式 全部通过Socks5（暂不可用） 自动切换模式 根据切换规则自动选择是否进行代理，自动选择使用何种代理 遇到规则中没有的，可以使用扩展的“新建规则”按钮自行添加 这个扩展偶尔会出BUG，出现设置无误但浏览器提示错误130无法连接到代理服务器，可以将自己的设置导出之后卸载重装 如果遇到无法更新规则列表，可以先运行goagent，并把浏览器代理设置为GoAgent模式再更新规则，不更新规则只会影响自动切换模式，不会影响其他模式的使用，若确实无法更新也可不更新，直接使用PAC模式即可 附：Mac电脑上面关于安装证书的问题关于在Mac电脑上面双击CA.crt，成都把证书导入到钥匙串以后，访问某些网站可能会提示”无法连接到真正的 twitter.com”，此时需要修改证书的信任信息。 打开钥匙串访问app 从右上角的搜索框中搜索 goagent,然后下面列表中会列出刚刚安装的证书。 鼠标右击证书》显示简介 展开 信任，下拉 使用此证书时：选择 总是信任即可","tags":[]},{"title":"随笔","date":"2014-01-30T08:33:52.000Z","path":"2014/01/30/sui-bi/","text":"引子很久没有写过东西了，其实脑袋里面经常闪现一些可以记录下来的东西，但很多都是一闪而过，我自己是个比较懒散的人，再者也不是随身携带纸和笔或者什么可以立即记录下来的东西，虽说手机版的Evernote或者有道云笔记这些也挺好使，但我除了工作之外不喜欢使用这些东西，再者呢，自己的语言组织能力不强，有些一闪而过的灵感，当你准备用文字记录下来的时候却不知道用什么词去组织它，结果是改了又改，最后呢，你会发觉这个过程并不是在记录东西，甚至发展到与之毫不相关的事情上面，越往后越会有一种不可控的感觉，就仿佛是在写代码的过程中遇到一个很小的问题，如果你准备去研究它，想弄个来龙去脉的话，会涉及到很多东西，然后你会感觉越来越多的东西自己不了解，越来越多的东西需要去研究…到后来感觉自己越来越一无是处…完全偏离了我的初衷，导致最后有种“郁郁而终”或者“死不冥目”的感觉，他们都说这就是“积累”，而我称它是一种“煎熬”。 以前呢，还是有写博客的习惯的，比如CSDN啊、博客园之类的。记得刚出来实习的时候，Boss就鼓励大家写一些技术性的博客，一是对自己的总结，二是分享经验，可能因为当时工作比较轻松，很多在开发当中遇到的问题都喜欢记录下来，当时私想以后遇到类似问题方便查阅，后来发现这种方式效率不高，写博客耽搁太多时间，并且自己经验有限，也怕误导后人，再者查阅也确实不方便，心想与其这样记录，还不如建立自己的代码库，每个问题可以做一个Demo，这样查阅起来岂不是方便得多？后来照做了，并且那些Demo都放在了网盘上面，当时用过Dropbox、Google Driver、115网盘、快盘，现在百度云也在用，现在想想，那个过程已经偏离了当时要保存代码库的初衷了，而且记录的那些Demo什么的，过后基本上不会再去看它，或许是因为当时解决方法不“完美”吧，再次遇到类似问题总会有比之前更好的办法解决，难道这也是“积累”？ 搭建博客的初衷呢，主要是想真正地记录一些自己想记录下来的东西，当时是想用Wordpress的，自己买空间和域名，本来都准备部署了，后来从朋友那听到可以把博客托管到GitHub上面，这样自己就不用管理后台啦，而且稳定上面没的说，并且使用的人还不少，所以决定用Octopress框架在GitHub上面搭个博客了，我想说这个过程也很折腾人，当时选主题就选了很久，一个一个地试，也参考了很多其它的博客，后来安装好主题以后始终有些地方感觉不“完美”，一遍一遍地改，还重新做了多次，颜色也换了很多种，有时候网络问题GitHub访问不了…感觉用“煎熬”来形容它一点不为过。这何尝不是又一次偏离了初衷呢？ 不扯淡了，回到我现在为什么写这篇博客中吧！ 生活值此新春佳节，祝各位已经回家的和没有回家的小伙伴们新春快乐，大吉大利！ 到处都充满了祥和的氛围，而我怎么也高兴不起来，如果偶尔不听到外面放鞭炮的声音，还真不知道这就是在过年！因为我现在并没有回家和父母团聚，也没有朋友作陪…我只想说，深圳真的太远了。 去年7月份来的深圳，现在算算也有一年半了，说长不长，说短不短。前段时间在知乎看了一篇文篇写的甚好：为什么现在的很多年轻人愿意来北上广打拼，即使过得异常艰苦，远离亲人，仍然义无反顾？ 引用里面的一段话： 80后者,未及义务教育之免费,不见高等学校之分配,适值扩招,寒窗数载,二十二乃成.觅生计,背井离乡,东渡苏浙,南下湖广,西上志愿,北漂京都,蓄十万.楼市暴涨,遂投股市,翌年缩水.气急入院,无医保而返.友怜之,送三鹿,饮之,卒 还深圳这么久了，硬是没有自己专门出去玩过，除了上次“弟文”过来出差一起去世界之窗转了转，其它时间除了公司活动以外，真心没有和她一起出去耍过，甚至和她连一场电影都没看过。这边也有几个朋友，经常说聚聚，但是一直没有机会。就拿今天来说，我本可以去找没有回家的小伙伴的，我为什么不去呢？有时候没事我宁愿在家里睡觉也不想出去，只有有事的时候才外出，办完事后立马就会回来，莫非这就是传说中的“宅”？→_→ 年前请了两周假回成都把房子按揭了，我也不知道这件事情到底做的对不对，期间也遇到过一些波折，本来今年没有打算做这件事情的，在意料之外。不过这样也好，房子迟早要买的，而且就目前的情况来看，早点也并不一定吃亏，只是这样的话，压力更大了…不过我倒不是很担心它，指不准以后就一次性还完了也不是不可能，只能一步一步地走了。现在离交房的时间差不多还有两年，到时候再看情况了。只是有一事比较气愤，本来上次回去一切都可以办妥的，不然的话信年过年就不回去了，来回一趟真的很折腾。或许是那个置业顾问对业务流程不是很熟悉吧，也或许我们的情况真的很特殊也不一定。事已至此，后悔也无用了。 这里真的想吐槽12306，那玩意儿真的太烂了… 工作我热爱我现在的行业，热爱写代码，热爱一些有科技含量的东西。 目前这是我在深圳的第二份工作，除了某方面不是很满意之外，其它都还ok，我们组三个人，Leader很牛。从他身上学到了不少东西。虽然有时候会很累，但至少心里面没有排斥它。 … 行了，工作上暂时不想记录太多，担心写的时候情不自禁一发不可收拾。 结尾关于2014，新的一年，又老了一截，身边的小伙伴们很多都结婚了，我也得加油！ 末尾了，对即将到来的2014提几点愿望吧： 父母身体健康 多挣点Money 工作顺利一点 就这么多了，祝我身边的小伙伴们新年快乐，大吉大利，也不想挨个打电话了…","tags":[]},{"title":"深圳","date":"2014-01-29T16:14:51.000Z","path":"2014/01/30/shen-zhen/","text":"","tags":[]},{"title":"在多台电脑上写Octopress博客","date":"2014-01-18T08:22:18.000Z","path":"2014/01/18/zai-duo-tai-dian-nao-shang-xie-octopressbo-ke/","text":"我将介绍如何在多台电脑上部署Octopress博客，我假设你已经在一台电脑上面部署过Octopress并且已经push到GitHub上面。如果你还不会或者不知道Octopress是什么的话，建议你先看看Octopress的官网，然后跟着Document一步步部署自己的博客。如果你弄坏了本地的Octopress配置，或者是你重装了系统，又或者是你在另一个电脑上面想继续编辑Octopress博客的话，那么这篇文章会告诉你该怎么做。 Octopress原理这里以部署到GitHub为例，Octopress的git仓库(repository)有两个分支，分别是master和source。master存储的是生成的博客网站本身，而source则存储的是生成博客的源文件。master所存储的内容可以通过source生成，也就是说，只要有源代码(source分支里面所存储的内容)就可以部署博客。master的内容在根目录的_deploy文件夹内，当你push源文件时会忽略，它使用的是rake deploy命令来更新到master分支上面去的。 创建一个本地的Octopress仓库重新创建一个已经存在的本地Octopress仓库只需要以下几个步骤： 克隆(clone)博客内容到本地首先将博客的源文件(source分支)clone到本地的octopress目录： 1$ git clone -b source git@github.com:username/username.github.io.git octopress 然后将博客网站内容(master分支)clone到octopress文件夹下的_deploy目录里： 12$ cd octopress/$ git clone git@github.com:username/username.github.io.git _deploy 然后安装依赖（如果之前在本机部署过octopress博客的话，这一步可以略过）： 123$ gem install bundler$ rbenv rehash # If you use rbenv, rehash to be able to run the bundle command$ bundle install 生成博客 1$ rake generate 这样就建好了一个新的本地仓库了。 更新和推送当你要在另一台电脑上写博客或者修改博客配置的话，首先更新source支分。更新master不是必须的，因为你更改源文件后还是需要rake generate的，它会更新本地的_deploy文件夹下的内容。 1234$ cd octopress$ git pull origin source # update the local source branch$ cd ./_deploy$ git pull origin master # update the local master branch 写完博客之后不要忘了推送到remote，下面的步骤在每次更改之后都必须做一遍。 12345$ rake generate$ git add .$ git commit -am \"Some comment here.\" $ git push origin source # update the remote source branch $ rake deploy # update the remote master branch","tags":[]}]